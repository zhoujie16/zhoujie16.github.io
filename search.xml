<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jsbase64]]></title>
    <url>%2F2019%2F08%2F23%2Fjsbase64%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718const CryptoJS = require('crypto-js')function base64Encode(str) &#123; const parseStr = CryptoJS.enc.Utf8.parse(str); const base64 = CryptoJS.enc.Base64.stringify(parseStr); return base64&#125;function base64Decode(str)&#123; const words = CryptoJS.enc.Base64.parse(str); const parseStr = words.toString(CryptoJS.enc.Utf8); return parseStr&#125;module.exports = &#123; base64Encode, base64Decode&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue课件准备]]></title>
    <url>%2F2019%2F07%2F29%2FVue%E8%AF%BE%E4%BB%B6%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[一、Vue介绍问 ​ 有没有看过vue文档，看完的，看过一点的​ 会不会用vue脚手架 运行一个 hellworld vue是什么： ​ 一个mvvm框架库，容易，上手，简单高效灵活 ​ 2014年诞生 ​ 作者：尤雨溪 vue 官网： vue流行程度 github活跃 react比较 优点 门槛低 效率高 学习vue能干什么 怎么学习好学 入门快 学习Vue需要哪些基础 HTML的基础知识，写前端页面的结构代码完全没有问题。 CSS的基础知识，最好了解CSS3的知识。 Javascript的基础知识，对基本语法掌握。 node.js初级知识，只需要会npm的使用和项目初始化就可以了 课程安排 Vue基础 ​ vue 思想​ hello vue 应用​ 指令 （数据绑定，事件绑定）​ 条件渲染 列表渲染 Vue 组件 Vue全家桶 vue-cli 工具 调试方法 vue-router vuex axios element-ui 介绍学习路线核心知识点 和课程内容介绍模板语法 条件渲染 列表渲染 事件处理 生命周期 组件封装vue全家桶先在html浏览器环境下学习vue然后在node环境下写vue 前置环境ide nodejs 调试工具 二、Vue基础入门指令 数据绑定 事件绑定 三、组件生命周期 定义组件 组件传值 四、脚手架node npm axios 组件化开发 Element-ui 路由 vuex 五、公司框架]]></content>
  </entry>
  <entry>
    <title><![CDATA[创建React Native应用程序]]></title>
    <url>%2F2019%2F07%2F26%2F%E5%88%9B%E5%BB%BAReactNative%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[2个脚手架工具 Expo CLI它们允许您在不安装和配置Xcode或Android Studio的情况下启动项目。Expo CLI在您的本地计算机上设置开发环境，您可以在几分钟内开始编写React Native应用程序。 123456789101112# Node 10 或更高版本# 安装教脚手架npm install -g expo-cli# 初始化项目expo init AwesomeProjectcd AwesomeProject# 启动一个开发服务器npm start # you can also use: expo start 在iOS或Android手机上安装Expo客户端应用程序，并连接到与计算机相同的无线网络。在Android上，使用Expo应用程序扫描终端的QR码以打开您的项目。在iOS上，按照屏幕上的说明获取链接。 注意事项 因为在使用Expo创建项目时不构建任何本机代码，所以除了React Native API和Expo客户端应用程序中可用的组件之外，不可能包含自定义本机模块。 如果您知道最终需要包含自己的本机代码，那么Expo仍然是一个很好的入门方式。在这种情况下，您最终只需要“ 弹出 ”以创建自己的本机构建。如果确实弹出，则需要“React Native CLI快速入门”说明继续处理项目。 Expo CLI将您的项目配置为使用Expo客户端应用程序支持的最新React Native版本。在React Native版本发布稳定后大约一周，Expo客户端应用程序通常会获得对给定React Native版本的支持。您可以查看此文档以了解支持的版本。 如果您将React Native集成到现有项目中，则需要跳过Expo CLI并直接设置本机构建环境。选择“React Native CLI Quickstart”，以获取有关为React Native配置本机构建环境的说明。 React Native CLI它需要Xcode或Android Studio才能开始。如果您已经安装了这些工具之一，那么您应该能够在几分钟内启动并运行。如果未安装它们，您应该花费大约一个小时来安装和配置它们。 1234567891011121314151617181920212223# MacOS 命令 ；Node 8.3或更高版本# 安装依赖项brew install nodebrew install watchmanbrew tap AdoptOpenJDK/openjdkbrew cask install adoptopenjdk8# 安装教脚手架npm install -g react-native-cli# 初始化项目react-native init AwesomeProject# 如果要使用特定的React Native版本启动新项目，可以使用以下--version参数react-native init AwesomeProject --version X.XX.Xreact-native init AwesomeProject --version react-native@next# 运行react-native run-ioscd AwesomeProjectreact-native run-ios# 运行react-native run-ios 指定设备react-native run-ios --simulator "iPhone 7 Plus"]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用GitHub结合PicGo自建图床]]></title>
    <url>%2F2019%2F07%2F25%2F%E5%88%A9%E7%94%A8GitHub%E7%BB%93%E5%90%88PicGo%E8%87%AA%E5%BB%BA%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[之前都用微博图床，然而微博图床从2019年4月开始实行了防盗链😂，不建议继续使用。 改用 PicGo 和 Github Pages 自建图床，在绑定自己的域名。稳定迁移也方便。缺点就是网速慢了点。 PicGo主页 PicGo GitHub主页 PicGo插件 PicGo-Core主页]]></content>
  </entry>
  <entry>
    <title><![CDATA[github访问慢和clone慢解决方案]]></title>
    <url>%2F2019%2F07%2F25%2Fgithub%E8%AE%BF%E9%97%AE%E6%85%A2%E5%92%8Cclone%E6%85%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[经常要clone github中的一些项目，无奈如果不爬梯子的话速度实在是龟速，经常1k/s，于是搜了下解决方法，改HOSTS大法。 1234567yonyouautodeMacBook-Pro:~ yonyouauto$ nslookup github.comServer: 210.22.70.3Address: 210.22.70.3#53Non-authoritative answer:Name: github.comAddress: 13.229.188.59 上面可以看出当前dns给我们分配的Github的IP是 13.229.188.59，这个IP我们访问很慢。其实github应该还有很多其他ip的，如果从其他城市访问github.com就可能得到不一样的ip。因而，我们需要模拟其他地点的访问以拿到github.com的其他ip。这个通过 DNS查询 工具可做到, 该工具在各地都有服务器，可以实现各地请求这个域名，然后显示返回的ip。 通过修改HOST文件 更改GitHub域名指向的IP 我选择的是台湾中华电信的 IP，速度明显快了很多。 Mac OS 的 HOST 文件在 /private/etc/hosts 目录，]]></content>
  </entry>
  <entry>
    <title><![CDATA[入坑yarn]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%85%A5%E5%9D%91yarn%2F</url>
    <content type="text"><![CDATA[前言最近研究Taro，用npm安装taro环境那是一个巨慢啊，公司还有一个老的vue项目，npm安装依赖很难成功，有时安装成功了也运行报错，要反复删掉重装直到运行成功，今天运行项目就折腾了一上午，最终用yarn一次解决，那个蛋疼啊。 看taro文档也支持yarn安装，之前也听说过有yarn这个东西，yarn出现很久了但是从来没有用过，当时想学yarn有毛用，当今npm扫天下。现在yarn经常出现在眼球中，总之学习下不吃亏。 当然大神都是全学的，像我等个渣渣就经常纠结是用npm还是yarn、是学习vue还是学习react、是用sass还是用less，是用webpack还是rollup。😂。 简介Yarn 是 Facebook, Google, Exponent 和 Tilde 开发的一款新的 JavaScript 包管理工具。就像我们可以从官方文档了解那样，它的目的是解决这些团队使用 npm 面临的少数问题，即： 安装的时候无法保证速度/一致性安全问题，因为 npm 安装时允许运行代码 Yarn 同样是一个从 npm 注册源获取模块的新的 CLI 客户端。注册的方式不会有任何变化 —— 你同样可以正常获取与发布包。 安装yarn参照文档 安装yarn 因为我安装了 nvm，应该排除安装 Node.js 以便使用 nvm 的 Node.js 版本，用如下命令 1brew install yarn --without-node 运行命令来测试 Yarn 是否安装： 12yarn --version# 1.17.3 yarn常用命令初始化新项目 1yarn init 添加依赖包 123yarn add [package]yarn add [package]@[version]yarn add [package]@[tag] 将依赖项添加到不同依赖项类别 分别添加到 devDependencies、peerDependencies 和 optionalDependencies： 123yarn add [package] --devyarn add [package] --peeryarn add [package] --optional 升级依赖包 123yarn upgrade [package]yarn upgrade [package]@[version]yarn upgrade [package]@[tag] 移除依赖包 1yarn remove [package] 安装项目的全部依赖 1yarn 或者 1yarn install 从 npm 迁移对多数用户来说，从npm迁移的过程应该非常简单。Yarn和npm使用相同的package.json格式，而且Yarn可以从npm安装依赖包。 如果你打算在现有项目中尝试Yarn，只需执行： 1yarn Yarn将通过自己的解析算法来重新组织node_modules 目录，这个算法和node.js 模块解析算法是兼容的。 yarn 与 npm 命令比较 npm (v5) Yarn npm install yarn install (不适用) yarn install --flat (不适用) yarn install --har npm install --no-package-lock yarn install --no-lockfile (不适用) yarn install --pure-lockfile npm install [package] yarn add [package] npm install [package] --save-dev yarn add [package] --dev (不适用) yarn add [package] --peer npm install [package] --save-optional yarn add [package] --optional npm install [package] --save-exact yarn add [package] --exact (不适用) yarn add [package] --tilde npm install [package] --global yarn global add [package] npm update --global yarn global upgrade npm rebuild yarn install --force npm uninstall [package] yarn remove [package] npm cache clean yarn cache clean [package] rm -rf node_modules &amp;&amp; npm install yarn upgrade]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac安装和使用nginx]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FMac%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8nginx%2F</url>
    <content type="text"><![CDATA[Nginx和环境准备Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。 Nginx的优点 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的了，比如我们用Nginx+PHP，在3万并发链接下，开启10个Nginx进程消耗150M内存。 免费使用可以商业化：Nginx为开源软件，采用的是2-clause BSD-like协议，可以免费使用，并且可以用于商业。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 Mac安装nginx1brew install nginx 终端运行并按提示操作。如下内容，则安装成功。 安装目录和配置文件目录都已经显示。 1234567891011121314151617181920212223242526272829303132333435363738394041yonyouautodeMacBook-Pro:~ yonyouauto$ brew install nginx==&gt; Installing dependencies for nginx: pcre==&gt; Installing nginx dependency: pcre==&gt; Downloading https://homebrew.bintray.com/bottles/pcre-8.43.mojave.bottle.tar.gz==&gt; Downloading from https://akamai.bintray.com/08/08e7414a7641d1e184c936537ff67f72f52649374d2308b89######################################################################## 100.0%==&gt; Pouring pcre-8.43.mojave.bottle.tar.gz🍺 /usr/local/Cellar/pcre/8.43: 204 files, 5.5MB==&gt; Installing nginx==&gt; Downloading https://homebrew.bintray.com/bottles/nginx-1.17.1.mojave.bottle.tar.gz==&gt; Downloading from https://akamai.bintray.com/a1/a1114fd86181db06ebb31c5f3fb5e666fafb3d10e0e65ed0f######################################################################## 100.0%==&gt; Pouring nginx-1.17.1.mojave.bottle.tar.gz==&gt; CaveatsDocroot is: /usr/local/var/wwwThe default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.To have launchd start nginx now and restart at login: brew services start nginxOr, if you don't want/need a background service you can just run: nginx==&gt; Summary🍺 /usr/local/Cellar/nginx/1.17.1: 25 files, 2MB==&gt; Caveats==&gt; nginxDocroot is: /usr/local/var/wwwThe default port has been set in /usr/local/etc/nginx/nginx.conf to 8080 so thatnginx can run without sudo.nginx will load all files in /usr/local/etc/nginx/servers/.To have launchd start nginx now and restart at login: brew services start nginxOr, if you don't want/need a background service you can just run: nginxyonyouautodeMacBook-Pro:~ yonyouauto$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac安装和使用homebrew]]></title>
    <url>%2F2019%2F07%2F16%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FMac%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8homebrew%2F</url>
    <content type="text"><![CDATA[HomebrewmacOS 缺失的软件包的管理器 Homebrew 是一款 macOS 平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。包管理工具可以让你安装和更新程序变得更方便，目前在 OS X 系统中最受欢迎的包管理工具就是 Homebrew。 安装 Homebrew进入 Homebrew官方网站 复制安装命令粘贴至终端 更换镜像源参考清华的镜像 清华大学开源软件镜像站 同样复制安装命令粘贴至终端]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端跨平台开发的深度解析]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[移动端跨平台开发的深度解析 跨平台一直是老生常谈的话题，cordova、ionic、react-native、weex、kotlin-native、flutter等跨平台框架的百花齐放，颇有一股推倒原生开发者的势头。（事实上更多是共存发展）看完本篇，相信你会对于当下跨平台移动开发的现状、实现原理、框架的选择等有更深入的理解。 全篇内容较多，需耐心食用！ (///▽///) 一、前言 为什么我们需要跨平台开发？ 本质上，跨平台开发是为了增加代码复用，减少开发者对多个平台差异适配的工作量，降低开发成本，提高业务专注的同时，提供比web更好的体验。嗯～通俗了说就是：省钱、偷懒。 本篇主要以react-native、weex、flutter，结合资讯展望，深入聊聊当前跨平台移动开发的实现原理、现状与未来。至于为什么只讲它们，因为对比ionic、phoneGap，它们更于 “naive” (˶‾᷄ ⁻̫ ‾᷅˵)。 超完整跨平台开源项目 类型 链接 react-native github.com/CarGuo/GSYG… weex github.com/CarGuo/GSYG… Flutter github.com/CarGuo/GSYG… 二、原理与特性目前移动端跨平台开发中，大致归纳为以下几种情况： react native、weex均使用JavaScript作为编程语言，目前JavaScript在跨平台开发中，可谓占据半壁江山，大有“一统天下”的趋势。 kotlin-native开始支持 iOS 和 Web 开发，（kotlin已经成为android的一级语言）也想尝试“一统天下”。 flutter是Google跨平台移动UI框架，Dart作为谷歌的亲儿子，毫无疑问Dart成为flutter的编程语言，如下图，作为巨头新生儿，在flutter官网也可以看出，flutter同样“心怀天下”。 1、React Native Facebook 出品，JavaScript语言，JSCore引擎，React设计模式，原生渲染 1.1、理念架构 “Learn once, write anywhere” ，代表着 Facebook对 react native 的定义：学习 react ，同时掌握 web 与 app 两种开发技能。 react native 用了 react 的设计模式，但UI渲染、动画效果、网络请求等均由原生端实现。开发者编写的js代码，通过 react native 的中间层转化为原生控件和操作，比ionic等跨平台应用，大大提高了的用户体验。 总结起来其实就是利用 JS 来调用 Native 端的组件，从而实现相应的功能。 如下图所示，react native 的跨平台是实现主要由三层构成，其中 C++ 实现的动态连结库(.so)，作为中间适配层桥接，实现了js端与原生端的双向通信交互。这里最主要是封装了 JavaScriptCore 执行js的解析，而 react native 运行在JavaScriptCore中，所以不存在浏览器兼容的问题。 其中在IOS上直接使用内置的javascriptcore， 在Android 则使用webkit.org官方开源的jsc.so。 1.2、实现原理 和前端开发不同，react native 所有的标签都不是真实控件，JS代码中所写控件的作用，类似 Map 中的 key 值。JS端通过这个 key 组合的 Dom ，最后Native端会解析这个 Dom ，得到对应的Native控件渲染，如 Android 中&lt;view&gt; 标签对应 ViewGroup 控件。 在 react native 中，JS端是运行在独立的线程中（称为JS Thread ）。JS Thread 作为单线程逻辑，不可能处理耗时的操作。那么如 fetch 、图片加载 、 数据持久化 等操作，在 Android 中实际对应的是 okhttp 、Fresco 、SharedPreferences等。而跨线程通信，也意味着 Js Thread 和原生之间交互与通讯是异步的。 可以看出，跨平台的关键在于C++层，开发人员大部分时候，只专注于JS 端的代码实现。 在原生端提供的各种 Native Module 模块（如网络请求，ViewGroup控件），和 JS 端提供的各种 JS Module（如JS EventEmiter模块），都会在C++实现的so中保存起来，双方的通讯通过C++中的保存的映射，最终实现两端的交互。通信的数据和指令，在中间层会被转为String字符串传输，双向的调用流程如下图。 1.3、打包加载 最终，JS代码会被打包成一个 bundle 文件，自动添加到 App 的资源目录下。react native 的打包脚本目录为/node_modules/react-native/local-cli，打包最后会通过 metro 模块压缩 bundle 文件。而bundle文件只会打包js代码，自然不会包含图片等静态资源，所以打包后的静态资源，其实是被拷贝到对应的平台资源文件夹中。 其中图片等存在资源的映射规则，比如放在 react native 项目根目录下的 img/pic/logo.png的资源，编译时，会被重命名后，根据大小 merged 到对应的是drawable目录下，修改名称为img_pic_logo.png。 打包Android和IOS，肯定需要相应的平台项目存在，在 react-native init 时创建的项目，就已经包含了 android 和 ios 的模版工程，打包完的工程会加载bundle文件，然后启动项目，如下图。这里就不展（tou）开（lan）了，有兴趣的可以看：React Native For Android 架构初探。 2、WEEX Alibaba 出品，JavaScript语言，JS V8引擎，Vue设计模式，原生渲染 2.1、理念架构 “Write once, run everywhere”, weex的定义就像是：写个 vue 前端，顺便帮你编译成性能还不错的 apk 和 ipa（当然，现实有时很骨感）。基于 Vue 设计模式，支持 web、android、ios 三端，原生端同样通过中间层转化，将控件和操作转化为原生逻辑来提高用户体验。 在 weex 中，主要包括三大部分：JS Bridge、Render、Dom，分别对应WXBridgeManager、WXRenderManager、WXDomManager，三部分通过WXSDKManager统一管理。其中 JS Bridge 和 Dom 都运行在独立的 HandlerThread 中，而 Render 运行在 UI 线程。 JS Bridge 主要用来和 JS 端实现进行双向通信，比如把 JS 端的 dom 结构传递给 Dom 线程。Dom 主要是用于负责 dom 的解析、映射、添加等等的操作，最后通知UI线程更新。而 Render 负责在UI线程中对 dom 实现渲染。 2.2、实现原理 和 react native一样，weex 所有的标签也不是真实控件，JS 代码中所生成存的 dom，最后都是由 Native 端解析，再得到对应的Native控件渲染，如 Android 中 &lt;text&gt; 标签对应 WXTextView控件。 weex 中文件默认为 .vue ，而 vue 文件是被无法直接运行的，所以 vue 会被编译成 .js 格式的文件，Weex SDK会负责加载渲染这个js文件。Weex可以做到跨三端的原理在于：在开发过程中，代码模式、编译过程、模板组件、数据绑定、生命周期等上层语法是一致的。不同的是在 JS Framework 层的最后，web 平台和 Native 平台，对 Virtual DOM 执行的解析方法是有区别的。 实际上，在 Native 中对 bundle 文件的加载大致经历以下阶段： weex 接收到 js 文件以后，JS Framework 根据文件为 Vue 模式，会调用weex-vue-framework 中提供的 createInstance方法创建实例。(也可能是Rax模式) createInstance 中会执行 Js Entry 代码里 new Vue() 创建一个组件，通过其 render 函数创建出 Virtual DOM 节点。 由JS V8 引擎上解析 Virtual DOM ，得到 Json 数据发送至 Dom 线，这里输出 Json 也是方便跨端的数据传输。 Dom 线程解析 Json 数据，得到对应的 WxDomObject，然后创建对应的WxComponent 提交 Render 。 Render在原生端最终处理处理渲染任务，并回调里JS方法。 得益于上层的统一性，只是通过 weex-vue-framework 判断是由Vue.js 生成真实的 Dom ，还是通过 Native Api 渲染组件，weex 一定程度上上，用JS 实现了 vue 一统天下的效果。 weex 在原生渲染 Render 时，在接收到渲染指令后，会逐步将数据渲染成原生组件。Render 通过解析渲染数据的描述，然后分发给不同的模块。 比如 控件渲染属于 dom 模块中，页面跳转属于navigator模块等。模块的渲染过程并非一个执行完，再执行另一个的流程，而是类似流式的过程。如上一个 &lt;text&gt; 的组件还没渲染好，下一个 &lt;div&gt; 的渲染又发了过来。这样当一个组件的嵌套组件很多时，或者可以看到这个大组件内的UI，一个一个渲染出来的过程。 weex 比起react native，主要是在JS V8的引擎上，多了 JS Framework 承当了重要的职责，使得上层具备统一性，可以支持跨三个平台。总的来说它主要负责是：管理Weex的生命周期；解析JS Bundle，转为Virtual DOM，再通过所在平台不同的API方法，构建页面；进行双向的数据交互和响应。 2.3、打包 weex 作为 react-native 之后出现的跨平台实现方案，自然可以站在前人的肩膀上优化问题，比如：Bundle文件过大问题。 Bundle文件的大小，很大程度上影响了框架的性能，而 weex 选择将 JS Framework 集成到 WeexSDK 中，一定程度减少了JS Bundle的体积，使得 bundle 里面只保留业务代码。 打包时，weex 是通过 webpack 打包出 bundle 文件的。bundle 文件的打包和 entry.js 文件的配置数量有关，默认情况下之后一个 entry 文件，自然也就只有一个bundle文件。 在 weex 项目的 webpack.common.conf.js 中可以看到，其实打包也是区分了 webConfig 和 weexConfig 的不同打包方式。如下图，其中weexEntry 就是 weex 打包配置的地方，可以看到本来已经有 index 和 entry.js 存在了。如果有需要，可配置上你需要的打包页面，具体这里就不详细展开了。有兴趣可看：Weex原理之带你去蹲坑 。 3、Flutter Google 出品，Dart语言，Flutter Engine引擎，响应式设计模式，原生渲染 Flutter 是谷歌2018年发布的跨平台移动UI框架。相较于本人已经在项目中使用过 react native 和 Weex，Flutter目前仅仅是简单运行过Demo，毕竟还是beta 阶段，这里更多的聊一下它的实现机制和效果。 与 react native 和 weex 的通过 Javascript 开发不同，Flutter 的编程语言是Drat，（谷歌亲儿子，据说是因为 Drat 项目组就在 Flutter 隔壁而被选上(◐‿◑) ）所以执行时并不需要 Javascript 引擎，但实际效果最终也通过原生渲染。 如上图，Flutter 主要分为 Framework 和 Engine，我们基于Framework 开发App，运行在 Engine 上。Engine 是 Flutter 的独立虚拟机，由它适配和提供跨平台支持，目前猜测 Flutter 应用程序在 Android 上，是直接运行 Engine 上 所以在是不需要Dalvik虚拟机。（这是比kotlin更彻底，抛弃JVM的纠缠？） 如下图，得益于 Engine 层，Flutter 甚至不使用移动平台的原生控件， 而是使用自己 Engine 来绘制 Widget （Flutter的显示单元），而 Dart 代码都是通过 AOT 编译为平台的原生代码，所以 Flutter 可以 直接与平台通信，不需要JS引擎的桥接。同时 Flutter 唯一要求系统提供的是 canvas，以实现UI的绘制。咦？这么想来，支持web端也没问题吧！ 在Flutter中，大多数东西都是widget，而Widget是不可变的，仅支持一帧，并且在每一帧上不会直接更新，要更新而必须使用Widget的状态。无状态和有状态 widget 的核心特性是相同的，每一帧它们都会重新构建，有一个State对象，它可以跨帧存储状态数据并恢复它。 Flutter 上 Android 自带了 Skia，Skia是一个 2D的绘图引擎库，跨平台，所以可以被嵌入到 Flutter的 iOS SDK中，也使得 Flutter Android SDK要比 iOS SDK小很多。 三、对比 这算是互相伤害的环节了吧。(///▽///) 类型 React Native Weex Flutter 平台实现 JavaScript JavaScript 无桥接，原生编码 引擎 JSCore JS V8 Flutter engine 核心语言 React Vue Dart Apk大小 (Release) 7.6M 10.6M 8.1M bundle文件大小 默认单一、较大 较小、多页面可多文件 不需要 上手难度 稍高？ 容易 一般 框架程度 较重 较轻 重 特点(不局限) 适合开发整体App 适合单页面 适合开发整体App 社区 丰富，Facebook重点维护 有点残念，托管apache 刚刚出道小鲜肉，拥护者众多 支持 Android、IOS Android、IOS、Web Android、IOS（并不止？） 1、大小 上面Apk大小是通过 react-native init、weex create 和 flutter 创建出的工程后，直接不添加任何代码，打包出来的 release 签名 apk 大小。从下图可以看出，其中大比例都是在so库。 2、社群 react native 作为 Facebook 主力开源项目之一，至今已有各类丰富的第三方库，甚至如 realm、lottie 等开源项目也有 react native 相关的版本，社群实际无需质疑。当然，因为并完全正统开发平台，第三库的健壮性和兼容性有时候总是良莠不齐。 weex 其实有种生错在国内的感觉。其实 weex 的设计和理念都很优秀，性能也不错，但是对比 react native 的第三方支持，就显得有点后妈养的。2016年开源至今，社区和各类文档都显得有点疲弱，作为跨平台开发人员，大多时候肯定不会希望，需要频繁的自己增加原生功能支持，因为这样的工作一多，反而会与跨平台开发的理念背道而驰，带来开发成本被维护难度增加。 Flutter目前还处理beta阶段，但是谷歌的号召力一直很可观，这一点无需质疑。 3、性能 理论上 flutter 的性能应该是最好的，但是目前实际体验中，却并没有感受出来太大的差距，和 react native（0.5.0之后）、weex 在性能上个人体验差异不是很大。当然，这里并没有实测渲染的毫秒时间和帧率数据。 4、其他区别 Weex的多页面实现问题 weex 在 native 端是不支持 &lt;keep-alive&gt; 的，这一点和 react-native 不同在与，如果在 native 需要实现页面跳转，使用 vue-router 将会惨不忍睹：返回后页面不做特别处理时，是会空白一片。参考官方Demo playground，native 端 的采用 weex.requireModule(&#39;navigator&#39;) 跳转 Activity 是才正确实现。 同时，weex中 navigator 跳转的设计，也导致了多页面的页面间通讯的差异。weex在多页面下的数据通讯，是通过url实现的，比如file://assets/dist/SecondPage.js?params=0，而vuex和vue-router在跨页面是无法共用的；而 react native 在跨 Actvity 使用时，因为是同一个bundle文件，只要 manager 相同，那么 router 和 store 时可以照样使用的，数据通信方式也和当个 Actvity 没区别。 项目模板 weex 和 react native 模板代码模式也不同。weex 的模板是从 cordova 模式修改过来的，根据platform需求，用命令添加固定模块，而在 .gitignore 对 platforms 文件夹是忽略跟踪。 react native 在项目创建时模版就存在了，特别是添加第三方插件原生端支持时，会直接修改模板代码，git代码中也会添加跟踪修改。 四、未来趋势 我们选择框架的时候，很多时候会关注框架的成熟度和生命力不是么(◐‿◑) 。 1、React Native “Airbnb 宣布放弃使用 React Native，回归使用原生技术” : Airbnb 作为 react native 平台上最大的支持者之一，其开源的lottie 同样是支持原生和 react native。 Airbnb 在宣布放弃的文中，也对 react native 的表示了很大量的肯定，而使得他们放弃的理由，其实主要还是集中于项目庞大之后的维护困难，第三方库的良莠不齐，兼容上需要耗费更多的精力导致放弃。 ps：（ Lottie库Airbnb出的是一个能够帮助解析AE导出的包含动画信息的json文件。这很好的解决了一个矛盾，设计师可以更专注的设计出各种炫酷的动画效果，而开发只需要将其加入支持即可。） Facebook 正在重构 React Native，将重写大量底层。在经历了开源协议风波后，可以看出 Facebook 对于 react native 还是很看重的， 这些底层重构优化的地方，主要集中于： 首先，改变线程模型。UI 更新不再需要在三个不同的线程上执行，而是可以在任意线程上同步调用 JavaScript 进行优先更新，同时将低优先级工作推出主线程，以便保持对 UI 的响应。 其次，将异步渲染功能引入 React Native 中，允许执行多个渲染并简化异步数据处理。 最后，简化桥接，让它更快、更轻量。原生和 JavaScript 之间的直接调用效率更高，并且可以更轻松地构建调试工具，如跨语言堆栈跟踪。 2、Weex 没有死！阿里公开Weex技术架构，还开源了一大波组件。 2018年初的新闻可以看出，weex 的遭遇有点类似曾经的 Duddo（Dubbo因为内部竞争被阿里一度放弃维护），这波诈尸后 weex 被托管到了Apache，而github的 weexteam 如今也还保持着更新，希望后续能有多好的发展，拭目以待吧。 3、Flutter Flutter 是 Google 跨平台移动UI框架，Dart作为谷歌的亲儿子在 Flutter 中使用，并且谷歌新操作系统 Fuchsia 支持 Dart，使用 Flutter 作为操作UI框架。这些集合到一起难免让你怀疑 Android 是否要被谷歌抛弃的想法。 或者如今先 Android 等平台上推广 Flutter 与 Dart，就是为了以后跟好的过渡到新系统上，毕竟开发者是操作系统的生命源泉之一。而 Java 与 JVM 或者可以被谷歌完全抛开。当然，目前看起来 Flutter 貌似还缺少一些语法糖，嵌套下来的代码有点不忍直视，或者到正式版之后，我们更能感受出它的美丽吧。 最后 内容有点长，其实很多点并没有细致的展开说明，但是通过本文，对于移动端跨平台的现状与未来，希望可能给你带来一点帮助。 超完整跨平台开源项目 类型 链接 react-native github.com/CarGuo/GSYG… weex github.com/CarGuo/GSYG… Flutter github.com/CarGuo/GSYG… Kotlin github.com/CarGuo/GSYG… 本文转自：掘金@恋猫de小郭]]></content>
  </entry>
  <entry>
    <title><![CDATA[提升编程水平的相关网站]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E6%8F%90%E5%8D%87%E7%BC%96%E7%A8%8B%E6%B0%B4%E5%B9%B3%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[0. Google https://google.com 这个不用多说了吧。 1.GitHub 开发者最最最重要的网站：https://github.com 这个不用多说了吧，代码托管网站，上面有很多资源，想要什么轮子，上去搜就好了。并且呢，上面有很多优秀的程序员，你可以在这里交到很多好朋友喔。 2. 掘金 帮助开发者成长的技术社区：https://juejin.im 现在国内优质的开发者交流学习社区，可以去看大佬们写的文章，也可以自己分享学习心的，与更多开发者交流。认识更多的小伙伴儿，提升个人影响力。 3. 算法学习 LintCode https://www.lintcode.com/ 算法学习网站，上去每天刷两道算法题，走遍天下都不怕。 4. 算法学习 LeetCode https://leetcode.com/ 也是算法题网站，同上。 5. 算法学习 LeetCode 中文站 https://lingkou.com/ 这个是上面算法题网站的中文站点，英文不好的可以刷这个，英文好的推荐去刷英文网站的题目，还能提升英语能力。 6. 牛客网 面经和刷面试题：https://www.nowcoder.com 各个公司的面试题和面经分享，找工作前认真刷一刷，一定会有很大收获！拿到心仪的 offer！ 7. Web 开发练习题 https://www.freecodecamp.org/ 这是国外发起的一个 Web 开发学习的网站，从简单到深入，一步一步带你学习 Web 开发。就像一本练习册，并且当你完成相应的内容后，会得到相应的资格认证。 8. 百度前端技术学院 前端开发项目库：http://ife.baidu.com 学前端的看这里，百度官方推出的前端开发学习技术学院，题目从简单到困难，如果你把里面的题都做会了，找个 BAT 的前端工作不成问题的。 9. Stack Overflow 解决 bug 的社区：https://stackoverflow.com/ 开发过程中遇到什么 bug，上去搜一下，只要搜索的方式对，百分之 99 的问题都能搜到答案。在这里能够与很多有经验的开发者交流，如果你是有经验的开发者，还可以来这儿帮助别人解决问题，提升个人影响力。 10. 程序员客栈 https://www.proginn.com/ 程序员客栈是领先的程序员自由工作平台，如果你是有经验有资质的开发者，都可以来上面注册成为开发者，业余的时候做点项目，赚点零花钱。当然，如果你想成为一名自由工作者，程序员客栈也是可以满足的。只要你有技术，不怕赚不到钱。 11. v2ex https://www.v2ex.com/ V2EX 是一个关于分享和探索的地方，上面有很多各大公司的员工，程序员。你想要的应有尽有。 12. CSDN https://www.csdn.net/ 老牌专业 IT 技术社区，有很多厉害的开发者，当然也有很多小白。在上面可以写文章，分享看法，也可以阅读学习别人分享的内容。现在广告太多，内容太说，不建议看。 想要成为一名厉害的，有影响力的程序员，一般平时要多分享自己的学习记录和感悟，让更多人认识你。同时你也多看看别人的分享，了解一下别人正在做什么，别人是怎样学习的，是怎样解决问题的，多主动与大家沟通交流，多交一些相关方向的朋友。 13.InfoQ https://www.infoq.cn/ InfoQ基本上就是日刷，可以看下同行都在做啥，不至于闭门造车。 InfoQ提供新闻、文章、视频演讲和采访等资讯服务。 InfoQ有各种语言版本，最重要的是有中文版的，内容相当有深度，非常有益于把握最新的技术动态。 14.HackerRank https://www.hackerrank.com/ HackerRank包含编程题和项目开发挑战。 有些编程题目难度非常高，不过喜欢挑战的程序员玩HackerRank会快感十足，它经常可以让你刷题爽到极点。 15.Programming by Doing http://www.programmingbydoing.com/ 网站一打开进去，“学习的最好方法就是去做。”这句话深深吸引了我。]]></content>
  </entry>
  <entry>
    <title><![CDATA[准确的检查你的javascript数据类型小工具typeCompare]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%87%86%E7%A1%AE%E7%9A%84%E6%A3%80%E6%9F%A5%E4%BD%A0%E7%9A%84javascript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B0%8F%E5%B7%A5%E5%85%B7typeCompare%2F</url>
    <content type="text"><![CDATA[更简单，准确的检查你的javascript数据类型一个简单的小工具 type-compare 1npm install type-compare --save 1234567891011121314151617181920212223242526import typeCompare from 'type-compare';// result truetypeCompare(null, 'null'); // truetypeCompare(undefined, 'undefined'); // truetypeCompare(true, 'boolean'); // truetypeCompare(123, 'number'); // truetypeCompare('123', 'string'); // truetypeCompare(Symbol(), 'symbol'); // truetypeCompare(new Array(), 'array'); // truetypeCompare(new Object(), 'object.object'); // truetypeCompare(new Number(), 'object.number'); // truetypeCompare(new String(), 'object.string'); // truetypeCompare(new Set(), 'object.set'); // truetypeCompare(new Map(), 'object.map'); // true// result falsetypeCompare(undefined, 'null'); // falsetypeCompare(null, 'undefined'); // falsetypeCompare('true', 'boolean'); // falsetypeCompare('123', 'number'); // falsetypeCompare(123, 'string'); // falsetypeCompare(new Object(), 'array'); // falsetypeCompare(new Array(), 'object'); // falsetypeCompare(new Number('123'), 'object.string'); // falsetypeCompare(new String(123), 'object.number'); // falsetypeCompare(new Set(), 'object.object'); // falsetypeCompare(new Map(), 'object.object'); // false]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS11.4.1越狱常用]]></title>
    <url>%2F2019%2F06%2F26%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FiOS11-4-1%E8%B6%8A%E7%8B%B1%E5%B8%B8%E7%94%A8%2F</url>
    <content type="text"><![CDATA[企业版软件下载地址： https://jailbreaks.fun/ https://app.ignition.fun/ https://apt.cydia.love/jbak/misc.html http://app.iosninja.io/ https://www.tweakboxapp.com/ 常用软件源： 蚂蚁源：https://apt.cydia.love kk中文源：https://apt.cydiakk.com 多米诺骨牌源：https://apt.wxhbts.com 贴吧源：http://apt.cydiaba.cn/ 嗨客源：http://repo.qqtlr.com/ 蜜蜂源：https://apt.cydiami.com 雷锋源：https://apt.abcydia.com ibreak源，微信助手：http://ibreak.yourepo.com WeChat++源：https://ihook.yourepo.com/ 平刷工具：雷锋源的有效，其他源的闪退 Unc0ver 汉化 我用的越狱软件 AnyWhere虚拟定位 4.6.1-1 雷锋源 AppSync Unified 关闭签名 40.0 蚂蚁源 AudioRecurder 2通话录音 1.6-93 蚂蚁源 BadgeColor 多彩角标 1.0-2 kk中文源 FakeStep 修改步数 1.0.1-1 蚂蚁源 Filza File 文件管理 3.6.2k kk源 GoodWiFi 无线增强 0.0-b5 蜜蜂源 iCleaner 官方版本 降频开关 0.5 蚂蚁源 Liberty Lite 屏蔽越狱 0.2.12 kk源 LowBattertBanner低电量通知 1.0.2 蚂蚁源 NewTerm2 命令终端 2.0-b3 蚂蚁源 NFCWriter XS 官方源 Pascal 优雅音量条 1.0 蚂蚁源 SilentRecorder 安静录屏 1.4.1 蚂蚁源 VideoDownloadCN 视频下载 1.1.1 嗨客源 WeChat Helper-微信助手 2.1.1 kk源 XB-Hide 应用隐藏 1.4 蚂蚁源 长图拼接破解0.1.1 多米诺源 支付宝蚂蚁森林一键收取 0.1-3 贴吧源]]></content>
  </entry>
  <entry>
    <title><![CDATA[npm修改源]]></title>
    <url>%2F2019%2F06%2F19%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fnpm%E4%BF%AE%E6%94%B9%E6%BA%90%2F</url>
    <content type="text"><![CDATA[1.得到原本的镜像地址 npm get registry https://registry.npmjs.org/ 设成淘宝的 npm config set registry http://registry.npm.taobao.org/ yarn config set registry http://registry.npm.taobao.org/ 2.换成原来的 npm config set registry https://registry.npmjs.org/]]></content>
  </entry>
  <entry>
    <title><![CDATA[dart-03]]></title>
    <url>%2F2019%2F06%2F17%2Fdart%E8%AE%B0%E5%BD%95%2Fdart-03%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[dart-02]]></title>
    <url>%2F2019%2F06%2F17%2Fdart%E8%AE%B0%E5%BD%95%2Fdart-02%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[dart-01]]></title>
    <url>%2F2019%2F06%2F17%2Fdart%E8%AE%B0%E5%BD%95%2Fdart-01%2F</url>
    <content type="text"><![CDATA[dart安装]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter环境搭建(Mac)]]></title>
    <url>%2F2019%2F06%2F15%2FFlutter%E8%AE%B0%E5%BD%95%2FFlutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[下载Flutter SDK包这里推荐去官网下载就好，我挂了梯子，速度并不慢。 网址：https://flutter.io/setup-macos/ 配置环境变量压缩包下载好以后，找个位置进行解压。这个位置很重要，因为下面配置环境变量的时候要用到。比如你配置到了根目录下的app文件夹。 1.打开终端工具（这个我就不用写了吧），使用vim进行配置环境变量，命令如下： 1vim ~/.bash_profile 在打开的文件里增加一行代码，意思是配置flutter命令在任何地方都可以使用。 1export PATH=/app/flutter/bin:$PATH 提示：这行命令你要根据你把压缩包解压的位置来进行编写，写的是你的路径，很有可能不跟文章一样。 配置完成后，需要用source命令重新加载一下 ，具体命令如下： 1source ~/.bash_profile 完成这部以后，就算我们flutter的安装工作完成了，但是这还不能进行开发。可以使用命令来检测一下，是否安装完成了。 1flutter -h 出现下面的结果，说明到目前为止，我们安装一切顺利。 检查开发环境到上边为止，我们安装好了Flutter，但是还不具备开发环境。开发还需要很多软件和插件的支持，那到底需要哪些插件和软件那？我们可以使用Flutter为我们提供的命令来进行检查： 1flutter doctor 如果你英文很好，你应该可以很容易读出上面的检测结果，有很多条目都没有通过。需要我们安装检测结果一条条进行安装，直到满足开发环境。（如果有[!]x标志，表示本行检测没有通过，就需要我们设置或者安装相应的软件了。） 有可能你的Android studio也没有安装，那么你要先安装这个编辑器，安装好后，可以顺便下载Android SDK。 Android Studio下载地址：http://www.android-studio.org/ 下载Android SDK的时候，记得搭上梯子，否则你会等到天荒地老（祝君一切顺利）。 如果你有安装，那么第一步要作的是允许协议（android-licenses）。允许方法就是在终端运行如下命令： 1flutter doctor --android-licenses 然后让你输入Y/N的时候，一路Y就可以了（至于啥意思，我也没仔细看，大概就和安装软件的下一步下一步是一样的，你按N是不能成功的）。 这不完成后，我们再使用flutter doctor进行检测后，会看到还是有很多x。大概如下： 123456789101112 To install, run: brew install --HEAD libimobiledevice brew install ideviceinstaller✗ ios-deploy not installed. To install: brew install ios-deploy✗ CocoaPods not installed. CocoaPods is used to retrieve the iOS platform side&apos;s plugin code that responds to your plugin usage on the Dart side. Without resolving iOS dependencies with CocoaPods, plugins will not work on iOS. For more info, see https://flutter.io/platform-plugins To install: brew install cocoapods pod setup 其实大概意思就是我们需要这些软件，Flutter推荐你用brew命令进行安装。 我们可以直接在终端里输入下列命令（每输完一个都要等一会，等待软件包安装完成） 12345brew install --HEAD libimobiledevicebrew install ideviceinstallerbrew install ios-deploybrew install cocoapodspod setup 安装完这些，我大概花了1个半小时左右，我这是百兆光纤还加了梯子。 这个大问题解决以后，我们还需要为Android Studio安装一下Flutter插件（这个有可能你安装过，如果出现下面的提示，说明你还没有安装） 12✗ Flutter plugin not installed; this adds Flutter specific functionality.✗ Dart plugin not installed; this adds Dart specific functionality. 打开Android Stuido 软件，然后找到Plugin的配置，搜索Flutter插件。 安装完成后，你需要重新启动一下Android Studio软件。 我做到这里环境就全部OK了，只有一个没有找到调试设备了，因为我没有调试的手机硬件，所以出现这个提示,不用管它。 12[!] Connected devices ! No devices available #Pub源的配置如果你没有梯子，一个人人都知道的原因，你还需要在环境变量里配置一下Pub源，不然你是无法进行使用的。 运行： 1vim ~/.bash_profile 增加两行配置 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 重新加载环境变量 1source ~/.bash_profile 希望大家都能安装成功，这只是我的安装过程，不敢保证全部正确，但是我尽量详细的描述了我Mac的搭建过程，希望可以帮助到Flutter的爱好者。 环境安装完成 检测结果如下图： 手机模拟器可打开Xcode的模拟器或者安卓的AVD虚拟机(超级卡，卡到你怀疑人生)]]></content>
  </entry>
  <entry>
    <title><![CDATA[认识一下Flutter]]></title>
    <url>%2F2019%2F06%2F15%2FFlutter%E8%AE%B0%E5%BD%95%2F%E8%AE%A4%E8%AF%86%E4%B8%80%E4%B8%8BFlutter%2F</url>
    <content type="text"><![CDATA[Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 我觉的这句话的重点有三个： 跨平台：现在Flutter至少可以跨4种平台，甚至支持嵌入式开发。我们常用的有Linux、Android、IOS，甚至可以在谷歌最新的操作系统上Fuchsia进行运行,经过第三方扩展，甚至可以跑在MacOS和Windows上，到目前为止，Flutter算是支持平台最多的框架了，良好的跨平台性，直接带来的好处就是减少开发成本。 原生用户界面： 它是原生的，让我们的体验更好，性能更好。用官方的话讲就是平滑而自然的滑动效果和平台感知，为您的用户带来全新的体验。（可以看一下图片，这是Flutter的表现） 开源免费：这个不用多说，我们只要学会并使用，这些都是免费的。这对于大公司是非常必要的，有人说你可以用破解版什么的….说明你还是小公司，我们公司的软件全部是正版，就更不用说操作系统和生产环境了，否则各种公司的侵权官司你都解决不了。 主流框架的对比其实说这一块是带有主观性的，很容易遭到攻击，我也不敢保证我说的就完全正确，但是我还是给大家简单介绍一下。 Cordova：个人认为Flutter可以完胜了，因为Cordova还是基于网页技术进行包装，利用插件的形式开发移动应用的，就这一点。无论是性能还是体验，Flutter都可以完胜了。 RN（React Native）：RN的效率由于是将View编译成了原生View,所以效率上要比基于Cordova的HTML5高很多,但是它也有效率问题,RN的渲染机制是基于前端框架的考虑,复杂的UI渲染是需要依赖多个view叠加.比如我们渲染一个复杂的ListView,每一个小的控件,都是一个native的view,然后相互组合叠加.想想此时如果我们的list再需要滑动刷新,会有多少个对象需要渲染.所以也就有了前面所说的RN的列表方案不友好。 Flutter：吸收了前两者的教训之后,在渲染技术上,选择了自己实现(GDI),由于有更好的可控性,使用了新的语言Dart,避免了RN的那种通过桥接器与Javascript通讯导致效率低下的问题,所以在性能方面比RN更高一筹;有经验的开发者可以打开Android手机开发者选项里面的显示边界布局,发现Flutter的布局是一个整体.说明Flutter的渲染没用使用原生控件进行渲染。 120fps超高性能Flutter采用GPU渲染技术，所以性能极高。 Flutter编写的应用是可以达到120fps(每秒传输帧数),这也就是说，它完全可以胜任游戏的制作。而我们常说的RN的性能只能达到60fps，这也算是Flutter的一个超高竞争力吧。官方宣称Flutter甚至会超过原生性能。 如果你想迈入移动游戏领域，学习Flutter也是一个非常好的选择。 #Flutter生态情况由于有google这样的超级公司支持和推广，Flutter虽然刚出来没有多久，但是生态还是非常好的，中国也有了大量的Flutter爱好者，那技术胖也是其中之一。 我们先来看一下Flutter的插件情况。由法国人总结了一个Flutter的插件列表，我们可以打开看一下，里边的插件非常丰富。所以小伙伴们完全没有必要为Flutter的生态环境而担忧。 github地址：https://github.com/Solido/awesome-flutter 目前阿里集团已经开始使用Flutter来进行开发了，比如我们经常使用的闲鱼，主要模块就是Flutter进行开发的。再给大家一个图片，这些效果都是Flutter进行开发的。 Flutter 的官方网站为我们提供了一个showcase,有兴趣的小伙伴可以点击下方链接进行查看。 Showcase地址：https://github.com/Solido/awesome-flutter 小伙伴们，快点上车吧，一起来掌握这门新技能。]]></content>
  </entry>
  <entry>
    <title><![CDATA[如何写出无法维护的代码]]></title>
    <url>%2F2019%2F06%2F13%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E6%97%A0%E6%B3%95%E7%BB%B4%E6%8A%A4%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如何写出无法维护的代码 这篇文章的原文在这里（mindprod.com/jgloss/unma… 看完我想说—— 什么叫“创造力”，创造力就是——就算是要干一件烂事都能干得那么漂亮那么有创意的能力。 什么叫“抓狂”，抓狂就是——以一种沉着老练的不屈不挠的一本正经的精神一点一点把你推向崩溃的边缘。 另外，维护程序的朋友们，你们死定了！！ 如果建筑师盖房子就像程序员写程序一样，那么，第一只到来的啄木鸟就能毁掉我们的文明 程序命名 容易输入的名字。比如：Fred，asdf 单字母的变量名。比如：a,b,c, x,y,z（如果不够用，可以考虑a1,a2,a3,a4,….） 有创意地拼写错误。比如：SetPintleOpening， SetPintalClosing。这样可以让人很难搜索代码。 抽象。比如：ProcessData, DoIt, GetData… 抽象到就跟什么都没说一样。 缩写。比如：WTF，RTFSC …… （使用拼音缩写也同样给力，比如： BT，TMD，TJJTDS） 随机大写字母。比如：gEtnuMbER.. 重用命名。在内嵌的语句块中使用相同的变量名有奇效。 使用重音字母。比如：int ínt（第二个 ínt不是int） 使用下划线。比如：, _, ___。 使用不同的语言。比如混用英语，德语，或是中文拼音。 使用字符命名。比如：slash, asterix, comma… 使用无关的单词。比如：god, superman, iloveu…. 混淆l和1。字母l和数字1有时候是看不出来的。 伪装欺诈 把注释和代码交织在一起。 123456789101112for(j=0; j&lt;array_len; j+ =8)&#123; total += array[j+0 ]; total += array[j+1 ]; total += array[j+2 ]; /* Main body of total += array[j+3]; * loop is unrolled total += array[j+4]; * for greater speed. total += array[j+5]; */ total += array[j+6 ]; total += array[j+7 ];&#125;复制代码 代码和显示不一致。比如，你的界面显示叫postal code，但是代码里确叫 zipcode. 隐藏全局变量。把使用全局变量以函数参数的方式传递给函数，这样可以让人觉得那个变量不是全局变量。 使用相似的变量名。如：单词相似，swimmer 和 swimner，字母相似：ilI1| 或 oO08。parselnt 和 parseInt， D0Calc 和 DOCalc。还有这一组：xy_Z, xy__z, _xy_z, _xyz, XY_Z, xY_z, Xy_z。 重载函数。使用相同的函数名，但是其功能和具体实现完全没有关系。 操作符重载。重载操作符可以让你的代码变得诡异，感谢CCTV，感谢C++。这个东西是可以把混乱代码提高到一种艺术的形式。比如：重载一个类的 ! 操作符，但实际功能并不是取反，让其返回一个整数。于是，如果你使用 ! ! 操作符，那么，有意思的事就发生了—— 先是调用类的重载 ! 操作符，然后把其返回的整数给 ! 成了 布尔变量，如果是 !!! 呢？呵呵。 文档和注释 在注释中撒谎。你不用真的去撒谎，只需在改代码的时候不要更新注释就可以了。 注释里面写废话。比如：/* add 1 to i */ 只注释是什么，而不是为什么。 不要注释秘密。如果你开发一个航班系统，请你一定要保证每有一个新的航班被加入，就得要修改25个以上的位置的程序。千万别把这个事写在文档中。 注重细节。当你设计一个很复杂的算法的时候，你一定要把所有的详细细设计都写下来，没有100页不能罢休，段落要有5级以上，段落编号要有500个以上，例如：1.2.4.6.3.13 – Display all impacts for activity where selected mitigations can apply (short pseudocode omitted). 这样，当你写代码的时候，你就可以让你的代码和文档一致，如：Act1_2_4_6_3_13() 千万不要注释度衡单位。比如时间用的是秒还是毫秒，尺寸用的是像素还是英寸，大小是MB还是KB。等等。另外，在你的代码里，你可以混用不同的度衡单位，但也不要注释。 Gotchas。陷阱，千万不要注释代码中的陷阱。 在注释和文档中发泄不满。 程序设计 Java Casts。Java的类型转型是天赐之物。每一次当你从Collection里取到一个object的时候，你都需要把其转回原来的类型。因些，这些转型操作会出现在N多的地方。如果你改变了类型，那么你不一定能改变所有的地方。而编译器可能能检查到，也可能检查不到。 利用Java的冗余。比如：Bubblegum b = new Bubblegom(); 和 swimmer = swimner + 1; 注意变量间的细微差别。 从不验证。从不验证输入的数据，从不验证函数的返回值。这样做可以向大家展示你是多么的信任公司的设备和其它程序员 不要封装。调用者需要知道被调用的所有的细节。 克隆和拷贝。为了效率，你要学会使用copy + paste。你几乎都不用理解别人的代码，你就可以高效地编程了。 巨大的listener。写一个listener，然后让你的所有的button类都使用这个listener，这样你可以在这个listener中整出一大堆if…else…语句，相当的刺激。 使用三维数组。如果你觉得三维还不足够，你可以试试四维。 混用。同时使用类的get/set方法和直接访问那个public变量。这样做的好处是可以极大的挫败维护人员。 包装，包装，包装。把你所有的API都包装上6到8遍，包装深度多达4层以上。然后包装出相似的功能。 没有秘密。把所有的成员都声明成public的。这样，你以后就很难限制其被人使用，而且这样可以和别的代码造成更多的耦合度，可以让你的代码存活得更久。 排列和阻碍。把drawRectangle(height, width) 改成 drawRectangle(width, height)，等release了几个版本后，再把其改回去。这样维护程序的程序员们很快就不明白哪一个是对的。 把变量改在名字上。例如，把setAlignment(int alignment)改成，setLeftAlignment, setRightAlignment, setCenterAlignment。 Packratting。保留你所有的没有使用的和陈旧的变量，方法和代码。 That’s Final。Final你所有的子结点的类，这样，当你做完这个项目后，没有人可以通过继承来扩展你的类。java.lang.String不也是这样吗？ 避免使用layout。这样就使得我们只能使用绝对坐标。如果你的老大强制你使用layout，你可以考虑使用GridBagLayout，然后把grid坐标hard code. 环境变量。如果你的代码需要使用环境变量。那么，你应该把你的类的成员的初始化使用环境变量，而不是构造函数。 使用全局变量。1）把全局变量的初始化放在不同的函数中，就算这个函数和这个变量没有任何关系，这样能够让我们的维护人员就像做侦探工作一样。2）使用全局变量可以让你的函数的参数变得少一些。 配置文件。配置文件主要用于一些参数的初始化。在编程中，我们可以让配置文件中的参数名和实际程序中的名字不一样。 膨胀你的类。让你的类尽可能地拥有各种臃肿和晦涩的方法。比如，你的类只实现一种可能性，但是你要提供所有可能性的方法。不要定义其它的类，把所有的功能都放在一个类中。 使用子类。面向对象是写出无法维护代码的天赐之物。如果你有一个类有十个成为（变量和方法）你可以考虑写10个层次的继承，然后把这十个属性分别放在这十个层次中。如果可能的话，把这十个类分别放在十个不同的文件中。 混乱你的代码 使用XML。XML的强大是无人能及的。使用XML你可以把本来只要10行的代码变成100行。而且，还要逼着别人也有XML。（参看，信XML得永生，信XML得自信） 分解条件表达式。如：把 a==100分解成，a&gt;99 &amp;&amp; a&lt;101 学会利用分号。如：if ( a );else;{ int d; d = c;} 间接转型。如：把double转string，写成new Double(d).toString() 而不是 Double.toString(d) 大量使用嵌套。一个NB的程序员可以在一行代码上使用超过10层的小括号（），或是在一个函数里使用超过20层的语句嵌套{}，把嵌套的if else 转成 [? :] 也是一件很NB的事。 长代码行。一行的代码越长越好。这样别人阅读时就需要来来回回的 不要过早的return。不要使用break，这样，你就需要至少5层以上的if-else来处理错误。 不要使用{}。不要在if else使用{}，尤其是在你重量地使用if-else嵌套时，你甚至可以在其中乱缩进代码，这样一来，就算是最有经验的程序员也会踩上陷阱。 琐碎的封装。比较封装一个bool类，类里面什么都做，就是一个bool. 循环。千万不可用for(int i=0; i&lt;n; i++)使用while代替for，交换n和i，把&lt;改成&lt;=，使用 i–调整步伐 。 测试 从不测试。千万不要测试任何的出错处理，从来也不检测系统调用的返回值。 永远不做性能测试。如果不够快就告诉用户换一个更快的机器。如果你一做测试，那么就可能会要改你的算法，甚至重设计，重新架构。 不要写测试案例。不要做什么代码覆盖率测试，自动化测试。 测试是懦夫行为。一个勇敢的程序员是根本不需要这一步的。太多的程序太害怕他们的老板，害怕失去工作，害怕用户抱怨，甚至被起诉。这种担心害怕直接影响了生产力。如果你对你的代码有强大的信心，那还要什么测试呢？真正的程序员是不需要测试自己的代码的。 其它 你的老板什么都知道。无论你的老板有多SB，你都要严格地遵照他的旨意办事，这样一来，你会学到更多的知识以及如何写出更加无法维护的代码。 颠覆Help Desk。你要确保你那满是bug的程序永远不要被维护团队知道。当用户打电话和写邮件给你的时候，你就不要理会，就算要理会，让用户重做系统或是告诉用户其帐号有问题，是标准的回答。 闭嘴。对于一些像y2k这样的大bug，你要学会守口如瓶，不要告诉任何人，包括你的亲人好友以及公司的同事和管理层，这样当到那一天的时候，你就可以用这个bug挣钱了。 忽悠。你会学会忽悠，就算你的代码写得很烂，你也要为其挂上GoF设计模式的标签，就算你的项目做得再烂，你也要为其挂上敏捷的标签，让整个团队和公司，甚至整个业界都开始躁动，这样才能真正为难维护的代码铺平道路。 这个文档中还有很多很多，实在是太TMD强大了，大家自己去看看吧。有精力有能力的朋友不妨把其翻译成中文。 总之，我们的口号是—— Write Everywhere, Read Nowhere （全文完）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker安装MongoDB]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FDocker%E5%AE%89%E8%A3%85MongoDB%2F</url>
    <content type="text"><![CDATA[MongoDB 是一款较为常用的NOSQL 数据库，结合 Docker 使用，能实现轻松配置部署、迁移，本文以下为简要介绍如何在 Docker 中部署并使用 MongoDB。下文主要分为几个部分，内容如下： MongoDB 镜像安装 MongoDB 容器创建 MongoDB 容器数据目录挂载 MongoDB 数据迁移 MongoDB 常用 Docker 命令 MongoDB Docker 镜像安装MongoDB 提供官方镜像，下载安装镜像方法如下： 1docker pull mongo 以上命令为安装 MongoDB 最新版本的镜像。 MongoDB Docker 容器创建MongoDB Docker 容器创建有以下几个问题： 1- MongoDB 容器基本创建方法和数据目录挂载 2- MongoDB 容器的数据迁移 3- MongoDB 设置登录权限问题 MongoDB 容器基本创建方法和数据目录挂载MongoDB 容器基本创建命令如下： 1docker run -p 27017:27017 -v &lt;LocalDirectoryPath&gt;:/data/db --name docker_mongodb -d mongo 在上面的命令中，几个命令参数的详细解释如下： -p 指定容器的端口映射，mongodb 默认端口为 27017 -v 为设置容器的挂载目录，这里是将即本机中的目录挂载到容器中的/data/db中，作为 mongodb 的存储目录 --name 为设置该容器的名称 -d 设置容器以守护进程方式运行 mongodb container.jpeg 以上是 MongoDB 容器创建后的信息。 接下来，我们使用 Robo 3T 图形界面软件尝试打开数据库。 打开 RoBo 3T，选择新建连接，按照下图填入相关数据库信息，保存。 robo3t demo.jpeg 然后点击连接，数据库连接成功，界面如下图显示 robo3t connected.jpeg 这里我们可以看到，这是一个空的数据库。随后我们创建一个 1test_database 的数据库，然后在创建一个 1test_collection 的集合，再在这个集合中添加一个文档，文档内容为： 1&#123;&apos;info&apos;: &apos;create success!&apos;&#125; 我们可以通过 RoBo 3T来查看目前数据库中数据的情况 robo3t data demo.jpeg 容器数据迁移接下来，我们先停止刚才创建的 docker_mongodb 容器，命令如下： 1docker stop docker_mongodb 然后我们再创建一个新的 MongoDB 容器，挂载刚才刚刚的数据目录，命令如下： 1docker run -p 27017:27017 -v &lt;LocalDirectoryPath&gt;:/data/db --name docker_mongodb_migration -d mongo 我们可以容器查询命令，查看当前 Docker 的容器状态，命令如下： 1docker container ls -a 这里的 -a 参数是查看所有的容器，包括已经停止的容器。 mongodb migration.jpeg 我们可以从输出结果看到，这时 1docker_mongodb 的状态是 Exited，表示已经退出，而新创建的 1docker_mongodb_migration 的状态显示为 Up，表明数据库正在运行。 然后我们再打开 RoBo 3T，连接数据库，可以看到我们看到我们再 docker_mongodb 中创建的数据，这里表明我们新创建的 docker_mongodb_migration 挂载的数据目录和 docker_mongodb 相同，利用这一方法，我们可以实现简单的数据迁移。 robo3t mongodb imgration.jpeg MongoDB 的 Docker 常用命令使用 Docker MongoDB 会使用到以下几个常用的命令。 查看当前运行的容器 1234# 查看正在运行的容器docker container ls# 查看所有容器docker container ls -a 停止容器 1234# 指定 CONTAINER ID 停止容器docker stop &lt;CONTAINER ID&gt;# 指定容器名称停止容器docker stop &lt;CONTAINER NAME&gt; 启动已经停止的容器 1234# 指定容器 CONTAINER ID 启动容器docker start &lt;CONTAINER ID&gt;# 指定容器名称启动容器docker start &lt;CONTAINER NAME&gt; 重启已经运行的容器 1234# 指定容器 CONTAINER ID 重启容器docker restart &lt;CONTAINER ID&gt;# 指定容器名称重启容器docker restart &lt;CONTAINER NAME&gt; 进入 mongo 交互模式 123456789docker exec -it &lt;CONTAINER NAME&gt; mongo admin#docker终端docker run -it /bin/bash#更新源apt-get update# 安装 vimapt-get install vim# 修改 mongo 配置文件vim /etc/mongod.conf.orig]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mongodb备份脚本centos]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FMongodb%E5%A4%87%E4%BB%BD%E8%84%9A%E6%9C%ACcentos%2F</url>
    <content type="text"><![CDATA[创建Mongodb数据库备份目录123mkdir -p /home/backup/mongod_bak/mongod_bak_nowmkdir -p /home/backup/mongod_bak/mongod_bak_list 新建Mongodb数据库备份脚本1234567891011121314151617181920212223242526272829#!/bin/shDUMP=/www/server/mongodb/bin/mongodump #mongodump备份文件执行路径OUT_DIR=/home/backup/mongod_bak/mongod_bak_now #临时备份目录TAR_DIR=/home/backup/mongod_bak/mongod_bak_list #备份存放路径DATE=`date +%Y_%m_%d` #获取当前系统时间DB_USER=username #数据库账号DB_PASS=password #数据库密码DAYS=7 #DAYS=7代表删除7天前的备份，即只保留最近7天的备份TAR_BAK=&quot;mongod_bak_$DATE.tar.gz&quot; #最终保存的数据库备份文件名cd $OUT_DIRrm -rf $OUT_DIR/*mkdir -p $OUT_DIR/$DATE$DUMP -u $DB_USER -p $DB_PASS -o $OUT_DIR/$DATE #备份全部数据库tar -zcvf $TAR_DIR/$TAR_BAK $OUT_DIR/$DATE #压缩为.tar.gz格式find $TAR_DIR/ -mtime +$DAYS -delete #删除7天前的备份文件 Mongodb数据库恢复–drop参数：恢复数据之前删除原来的数据，避免数据重复 –noIndexRestore参数：恢复数据时不创建索引 –dir参数：数据库备份目录 -d参数：后面跟要恢复的数据库名称 12345#恢复全部数据库：mongorestore -u $DB_USER -p $DB_PASS --authenticationDatabase &quot;admin&quot; --noIndexRestore --dir /home/backup/mongod_bak/mongod_bak_now/2019_04_09/#恢复单个数据库mongorestore -u $DB_USER -p $DB_PASS --authenticationDatabase &quot;admin&quot; --noIndexRestore -d dbname --dir /home/backup/mongod_bak/mongod_bak_now/2019_04_09/]]></content>
  </entry>
  <entry>
    <title><![CDATA[你想知道的关于JavaScript作用域的一切]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BD%A0%E6%83%B3%E7%9F%A5%E9%81%93%E7%9A%84%E5%85%B3%E4%BA%8EJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[你想知道的关于JavaScript作用域的一切(译)JavaScript中有许多章节是关于scope的,但是对于初学者来说(甚至是一些有经验的JavaScript开发者),这些有关作用域的章节既不直接也不容易理解.这篇文章的目的就是为了帮助那些想更深一步学习了解JavaScript作用域的开发者,尤其是当他们听到一些关于作用域的单词的时候,好比:作用域(scope),闭包(closure),this,命名空间(namespace),函数作用域(function scope),全局作用域(global scope),词法作用域(lexical),公有变量(public scope),私有变量(private scope).希望通过这篇文章你可以知道下面这些问题的答案: 什么是作用域? 什么是全局(局部)作用域? 什么是命名空间,它和作用域有什么不同? this关键字是什么,作用于又是怎么影响它的? 什么是函数/词法作用域? 什么是闭包? 什么是共有/私有作用域? 我怎么样才能够理解/创建/实践上面所有的情况 什么是作用域?在JavaScript中,作用域指的是你代码的当前上下文环境.作用域可以被全局或者局部地定义.理解JavaScript的作用域是让你写出稳健的代码并且成为一个更好的开发者的关键.你将会理解那些变量或者函数是可以访问的,并且有能力去改变你代码的作用域进而有能力去写出运行速度更快,更容易维护,当然调试也非常容易的代码.别把作用域想的太复杂,那么我们现在是在A作用域还是B作用域? 什么是全局作用域当你在开始书写JavaScript代码的时候,你所处的作用域就是我们所说的全局作用域.如果我们定义了一个变量,那么它就是被全局定义的: 12// global scopevar name = 'Todd'; 全局作用域是你最好的朋友也是你最坏的噩梦;学会去掌控你的作用域是容易的,如果你那样做了,你将不会遇到一些关于全局作用域的问题(通常是关于命名空间的冲突).你也许会经常听到有人在说全局作用域是不好的,但是你从来没有考虑过他们那样说的真正原因.全局作用域当然没有他们说的那样,相反全局作用域是很好的,你需要使用它去创建能够在别的作用域访问的模块还有接口(APIs),你要在使用它的优点的同时确保不产生新的问题. 很多人以前都使用过jQuery,当你写下下面的代码的时候… 1jQuery('.myClass'); 我们这时就是通过全局作用域来使用jQuery的,我们可以把这种使用叫做命名空间.有时命名空间就是一个可以用不同单词来替代的作用域,但是通常指的是最高一级的作用域.在这个例子中,jQuery是在全局作用域中,所以也是我们的命名空间.这个jQuery的命名空间是定义在全局作用域上的,它作为这个jQuery库的命名空间,所有在jQuery库内的东西都是这个命名空间的派生物. 什么是局部作用域局部作用域指的是那些从全局作用域中定义的许多作用域.JavaScript只有一个全局作用域,每一个定义的函数都有自己的局部(嵌套)作用域.那些定义在别的函数中的函数有一个局部的作用域,并且这个作用域是指向外部的函数. 如果我定义了一个函数,并且在里面创建了一些变量,这些变量的作用域就是局部的. 把下面的当做一个例子: 1234// Scope A: Global scope out herevar myFunction = function () &#123; // Scope B: Local scope in here&#125;; 任何局部的东西在全局是不可见的,除非这些东西被导出;这句话的意思是这样的,如果我在一个新的作用域里定义了一些函数或者变量的话,这些变量或者函数在当前的作用域之外是不可以访问的.下面的代码是关于上面所说的那些的一个小例子: 123456var myFunction = function () &#123; var name = 'Todd'; console.log(name); // Todd&#125;;// Uncaught ReferenceError: name is not definedconsole.log(name); 变量name是局部的变量,它并没有暴露在父作用域上,因此它是没有被定义的. 函数作用域JavaScript中所有的作用域在创建的时候都只伴随着函数作用域,循环语句像for或者while,条件语句像if或者switch都不能够产生新的作用域.新的函数 = 新的作用域这就是规则.下面一个简单的例子用来解释作用域的创建: 1234567// Scope Avar myFunction = function () &#123; // Scope B var myOtherFunction = function () &#123; // Scope C &#125;;&#125;; 所以说很容易创建新的作用域和局部的变量/函数/对象. 词法作用域每当你看到一个函数里面存在着另一个函数,那么内部的函数能够访问外部函数的作用域,这就叫做词法作用域或者闭包;也被认为是静态作用域,下面的代码是最简单的方法再一次去解释我们所说的内容: 12345678// Scope Avar myFunction = function () &#123; // Scope B var name = 'Todd'; // defined in Scope B var myOtherFunction = function () &#123; // Scope C: `name` is accessible here! &#125;;&#125;; 你也许注意到myOtherFunction没有在这里被调用,它只是简单地被定义.当然它的调用顺序也会影响到作用域里面变量的表现,在这里我定义了myOtherFunction并且在console语句之后调用了它: 123456789101112var myFunction = function () &#123; var name = 'Todd'; var myOtherFunction = function () &#123; console.log('My name is ' + name); &#125;; console.log(name); myOtherFunction(); // call function&#125;;// Will then log out:// `Todd`// `My name is Todd` 很容易理解和使用词法作用域,任何被定义在它的父作用域上的变量/对象/函数,在作用域链上都是可以访问到的.例如: 12345678910var name = 'Todd';var scope1 = function () &#123; // name is available here var scope2 = function () &#123; // name is available here too var scope3 = function () &#123; // name is also available here! &#125;; &#125;;&#125;; 需要记住的一个重要地方是,词法作用域是不可逆的,我们可以从下面的例子中看到结果: 12345678910// name = undefinedvar scope1 = function () &#123; // name = undefined var scope2 = function () &#123; // name = undefined var scope3 = function () &#123; var name = 'Todd'; // locally scoped &#125;; &#125;;&#125;; 当然我们可以返回一个指向name的引用,但是永远不会是name变量本身. 作用域链作用域链为一个给定的函数建立了作用域.就像我们知道的那样,每一个被定义的函数都有它自己嵌套的作用域,并且任何定义在别的函数中的函数都有一个连接外部函数的局部作用域,这个连接就是我们所说的作用域链中的链.它常常是在代码中那些能够定义作用域的位置,当我们访问一个变量的时候,JavaScript从最里面的作用域沿着作用域链向外部开始查找,直到找到我们想要的那个变量/对象/函数. 闭包闭包和词法作用域是紧密联系在一起的,关于闭包是如何工作的一个好例子就是当我们返回一个函数的引用的时候,这是一个更实际的用法.在我们的作用域里,我们可以返回一些东西以便这些东西能够在父作用域里被访问和使用: 123456var sayHello = function (name) &#123; var text = 'Hello, ' + name; return function () &#123; console.log(text); &#125;;&#125;; 我们这里使用的闭包概念使我们在sayHello的作用域不能够被外部(公共的)作用域访问.单独运行这个函数不会有什么结果因为它只是返回了一个函数: 1sayHello('Todd'); // nothing happens, no errors, just silence... 这个函数返回了一个函数,那就意味着我们需要对它进行赋值,然后对它进行调用: 12var helloTodd = sayHello('Todd');helloTodd(); // will call the closure and log 'Hello, Todd' 好吧,我撒谎了,你也可以直接调用它,你也许之前已经见到过像这样的函数,这种方式也是可以运行你的闭包: 1sayHello('Bob')(); // calls the returned function without assignment AngularJS的$compile方法使用了上面的技术,你可以将当前作用的引用域传递给这个闭包: 1$compile(template)(scope); 我们可以猜测他们关于这个方法的(简化)代码大概是下面这个样子: 1234567var $compile = function (template) &#123; // some magic stuff here // scope is out of scope, though... return function (scope) &#123; // access to `template` and `scope` to do magic with too &#125;;&#125;; 当然一个函数不必有返回值也能够被称为一个闭包.只要能够访问外部变量的一个即时的词法作用域就创建了一个闭包. 作用域和this每一个作用域都绑定了一个不同值的this,这取决于这个函数是如何调用的.我们都使用过this关键词,但是并不是所有的人都理解它,还有当它被调用的时候是如何的不同.默认情况下,this指向的是最外层的全局对象window.我们可以很容易的展示关于不同的调用方式我们绑定的this的值也是不同的: 123456789101112131415var myFunction = function () &#123; console.log(this); // this = global, [object Window]&#125;;myFunction();var myObject = &#123;&#125;;myObject.myMethod = function () &#123; console.log(this); // this = Object &#123; myObject &#125;&#125;;var nav = document.querySelector('.nav'); // &lt;nav class="nav"&gt;var toggleNav = function () &#123; console.log(this); // this = &lt;nav&gt; element&#125;;nav.addEventListener('click', toggleNav, false); 当我们处理this的值的时候我们又遇到了一些问题,举个例子如果我添加一些代码在上面的例子中.就算是在同一个函数内部,作用域和this都是会发生改变的: 12345678var nav = document.querySelector('.nav'); // &lt;nav class="nav"&gt;var toggleNav = function () &#123; console.log(this); // &lt;nav&gt; element setTimeout(function () &#123; console.log(this); // [object Window] &#125;, 1000);&#125;;nav.addEventListener('click', toggleNav, false); 所以这里发生了什么?我们创建了一个新的作用域,这个作用域没有被我们的事件处理程序调用,所以默认情况下,这里的this指向的是window对象.当然我们可以做一些事情不让这个新的作用域影响我们,以便我们能够访问到这个正确的this值.你也许已经见到过我们这样做的方法了,我们可以使用that变量缓存当前的this值,然后在新的作用域中使用它. 123456789var nav = document.querySelector('.nav'); // &lt;nav class="nav"&gt;var toggleNav = function () &#123; var that = this; console.log(that); // &lt;nav&gt; element setTimeout(function () &#123; console.log(that); // &lt;nav&gt; element &#125;, 1000);&#125;;nav.addEventListener('click', toggleNav, false); 这是一个小技巧,让我们能够使用到正确的this值,并且在新的作用域解决一些问题. 使用.call(),.apply()或者.bind()改变作用域有时,你需要根据你所处理的情况来处理JavaScript的作用域.一个简单的例子展示如何在循环的时候改变作用域: 1234var links = document.querySelectorAll('nav li');for (var i = 0; i &lt; links.length; i++) &#123; console.log(this); // [object Window]&#125; 这里的this没有指向我们需要的元素,我们不能够在这里使用this调用我们需要的元素,或者改变循环里面的作用域.让我们来思考一下如何能够改变我们的作用域(好吧,看起来好像是我们改变了作用域,但是实际上我们真正做的事情是去改变我们那个函数的运行上下文). .call()和.apply().call()和.apply()函数是非常实用的,它们允许你传递一个作用域到一个函数里面,这个作用与绑定了正确的this值.让我们来处理上面的那些代码吧,让循环里面的this指向正确的元素值: 123456var links = document.querySelectorAll('nav li');for (var i = 0; i &lt; links.length; i++) &#123; (function () &#123; console.log(this); &#125;).call(links[i]);&#125; 你可以看到我是如何做的,首先我们创建了一个立即执行的函数(新的函数就表明创建了新的作用域),然后我们调用了.call()方法,将数组里面的循环元素link[i]当做参数传递给了.call()方法,然后我们就改变了哪个立即执行的函数的作用域.我们可以使用.call()或者.apply()方法,但是它们的不同之处是参数的传递形式,.call()方法的参数的传递形式是这样的.call(scope, arg1, arg2, arg3),.apply()的参数的传递形式是这样的.apply(scope, [arg1, arg2]). 所以当你需要改变你的函数的作用域的时候,不要使用下面的方法: 1myFunction(); // invoke myFunction 而应该是这样,使用.call()去调用我们的方法 1myFunction.call(scope); // invoke myFunction using .call() .bind()不像上面的方法,使用.bind()方法不会调用一个函数,它仅仅在函数调用之前,绑定我们需要的值.就像我们知道的那样,我们不能够给函数的引用传递参数.就像下面这样: 12345// worksnav.addEventListener('click', toggleNav, false);// will invoke the function immediatelynav.addEventListener('click', toggleNav(arg1, arg2), false); 我们可以解决这个问题,通过在它里面创建一个新的函数: 123nav.addEventListener('click', function () &#123; toggleNav(arg1, arg2);&#125;, false); 但是这样就改变了作用域,我们又一次创建了一个不需要的函数,这样做需要花费很多,当我们在一个循环中绑定事件监听的时候.这时候就需要.bind()闪亮登场了,因为我们可以使用他来进行绑定作用域,传递参数,并且函数还不会立即执行: 1nav.addEventListener('click', toggleNav.bind(scope, arg1, arg2), false); 上面的函数没有被立即调用,并且作用域在需要的情况下也会改变,而且函数的参数也是可以通过这个方法传入的. 私有/共有的作用域在许多编程语言中,你应该听到过私有作用域或者共有作用域,在JavaScript中,是没有这些概念的.当然我们也可以通过一些手段比如闭包来模拟公共作用域或者是私有作用域. 通过使用JavaScript的设计模式,比如模块模式,我们可以创造公共作用域和私有作用域.一个简单的方法创建私有作用域就是使用一个函数去包裹我们自己定义的函数.就像上面所说的那样,函数创建了一个与全局作用域隔离的一个作用域: 123(function () &#123; // private scope inside here&#125;)(); 我们可能需要为我们的应用添加一些函数: 12345(function () &#123; var myFunction = function () &#123; // do some stuff here &#125;;&#125;)(); 但是当我们去调用位于函数内部的函数的时候,这些函数在外部的作用域是不可得到的: 1234567(function () &#123; var myFunction = function () &#123; // do some stuff here &#125;;&#125;)();myFunction(); // Uncaught ReferenceError: myFunction is not defined 成功了,我们创建了私有的作用域.但是问题又来了,我如何在公共作用域内使用我们之前定义好的函数?不要担心,我们的模块设计模式或者说是提示模块模式,允许我们将我们的函数在公共作用域内发挥作用,它们使用了公共作用域和私有作用域以及对象.在下面我定义了我的全局命名空间,叫做Module,这个命名空间里包含了与那个模块相关的所有代码: 1234567891011// define modulevar Module = (function () &#123; return &#123; myMethod: function () &#123; console.log('myMethod has been called.'); &#125; &#125;;&#125;)();// call module + methodsModule.myMethod(); 上面的return声明表明了我们返回了我们的public方法,这些方法是可以在全局作用域里使用的,不过需要通过命名空间来调用.这就表明了我们的那个模块只是存在于哪个命名空间中,它可以包含我们想要的任意多的方法或者变量.我们也可以按照我们的意愿来扩展这个模块: 123456789101112131415// define modulevar Module = (function () &#123; return &#123; myMethod: function () &#123; &#125;, someOtherMethod: function () &#123; &#125; &#125;;&#125;)();// call module + methodsModule.myMethod();Module.someOtherMethod(); 那么我们的私有方法该如何使用以及定义呢?总是有许多的开发者随意的堆砌他们的方法在那个模块里面,这样的做法污染了全局的命名空间.那些帮助我们的代码运行并且是不必要出现在全局作用域的方法,就不要导出在全局作用域中,我们只导出那些需要在全局作用域内被调用的函数.我们可以定义私有的方法,只要不返回它们就行: 12345678910var Module = (function () &#123; var privateMethod = function () &#123; &#125;; return &#123; publicMethod: function () &#123; &#125; &#125;;&#125;)(); 上面的代码意味着,publicMethod是可以在全局的命名空间里调用的,但是privateMethod是不可以的,因为它是在私有的作用域中被定义的.这些私有的函数方法一般都是一些帮助性的函数,比如addClass,removeClass,Ajax/XHR calls,Arrays,Objects等等. 这里有一些概念需要我们知道,就是同一个作用域中的函数变量可以访问在同一个作用域中的函数或者变量,甚至是这些函数已经被作为结果返回.这意味着,我们的公共函数可以访问我们的私有函数,所以这些私有的函数是仍然可以运行的,只不过他们不可以在公共的作用域里被访问而已. 1234567891011var Module = (function () &#123; var privateMethod = function () &#123; &#125;; return &#123; publicMethod: function () &#123; // has access to `privateMethod`, we can call it: // privateMethod(); &#125; &#125;;&#125;)(); 这允许一个非常强大级别的交互,以及代码的安全;JavaScript非常重要的一个部分就是确保安全.这就是为什么我们不能够把所有的函数都放在公共的作用域内,因为一旦那样做了就会暴漏我们系统的漏洞,让一些心怀恶意的人能够对这些漏洞进行攻击. 下面的例子就是返回了一个对象,然后在这个对象上面调用一些公有的方法的例子: 12345678910111213141516var Module = (function () &#123; var myModule = &#123;&#125;; var privateMethod = function () &#123; &#125;; myModule.publicMethod = function () &#123; &#125;; myModule.anotherPublicMethod = function () &#123; &#125;; return myModule; // returns the Object with public methods&#125;)();// usageModule.publicMethod(); 一个比较规范的命名私有方法的约定是,在私有方法的名字前面加上一个下划线,这可以快速的帮助你区分公有方法或者私有方法: 12345678var Module = (function () &#123; var _privateMethod = function () &#123; &#125;; var publicMethod = function () &#123; &#125;;&#125;)(); 这个约定帮助我们可以简单地给我们的函数索引赋值,当我们返回一个匿名对象的时候: 123456789101112var Module = (function () &#123; var _privateMethod = function () &#123; &#125;; var publicMethod = function () &#123; &#125;; return &#123; publicMethod: publicMethod, anotherPublicMethod: anotherPublicMethod &#125;&#125;)(); 原文链接: Everything you wanted to know about JavaScript scope 原文作者: Todd Motto]]></content>
      <categories>
        <category>作用域</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[五句话搞定JavaScript作用域]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BA%94%E5%8F%A5%E8%AF%9D%E6%90%9E%E5%AE%9AJavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[提示：此文针对ES5，不涉及ES2015（又称ES6） JavaScript的作用域一直以来是前端开发中比较难以理解的知识点，对于JavaScript的作用域主要记住几句话，走遍天下都不怕。 一、“JavaScript中无块级作用域” 在Java或C#中存在块级作用域，即：大括号也是一个作用域。 123456789101112131415public static void main ()&#123; if(1==1)&#123; String name = "seven"; &#125; System.out.println(name);&#125;// 报错public static void Main()&#123; if(1==1)&#123; string name = "seven"; &#125; Console.WriteLine(name);&#125;// 报错 在JavaScript语言中无块级作用域 1234567function Main()&#123; if(1==1)&#123; var name = 'seven'; &#125; console.log(name);&#125;// 输出： seven 补充：标题之所以添加双引号是因为JavaScript6中新引入了 let 关键字，用于指定变量属于块级作用域。 二、JavaScript采用函数作用域在JavaScript中每个函数作为一个作用域，在外部无法访问内部作用域中的变量。 123456789function Main()&#123; var innerValue = 'seven';&#125; Main(); console.log(innerValue); // 报错：Uncaught ReferenceError: innerValue is not defined 三、JavaScript的作用域链由于JavaScript中的每个函数作为一个作用域，如果出现函数嵌套函数，则就会出现作用域链。 123456789101112xo = 'alex'; function Func()&#123; var xo = "seven"; function inner()&#123; var xo = 'alvin'; console.log(xo); &#125; inner();&#125;Func();// 输出结果 alvin 如上述代码则出现三个作用域组成的作用域链，如果出现作用域链后，那么寻找变量时候就会出现顺序，对于上述实例： 当执行console.log(xo)时，其寻找顺序为根据作用域链从内到外的优先级寻找，如果内层没有就逐步向上找，直到没找到抛出异常。 四、JavaScript的作用域链执行前已创建JavaScript的作用域在被执行之前已经创建，日后再去执行时只需要按照作用域链去寻找即可。 示例一： 12345678910111213xo = 'alex'; function Func()&#123; var xo = "seven"; function inner()&#123; console.log(xo); &#125; return inner;&#125; var ret = Func();ret();// 输出结果： seven 上述代码，在函数被调用之前作用域链已经存在： 全局作用域 -&gt; Func函数作用域 -&gt; inner函数作用域 当执行 ret() 时，由于其代指的是inner函数，此函数的作用域链在执行之前已经被定义为：全局作用域 -&gt; Func函数作用域 -&gt; inner函数作用域，所以，在执行 ret() 时，会根据已经存在的作用域链去寻找变量。 示例二： 1234567891011121314xo = 'alex'; function Func()&#123; var xo = "eirc"; function inner()&#123; console.log(xo); &#125; xo = 'seven'; return inner;&#125; var ret = Func();ret();// 输出结果： seven 上述代码和示例一的目的相同，也是强调在函数被调用之前作用域链已经存在： 全局作用域 -&gt; Func函数作用域 -&gt; inner函数作用域 不同的时，在执行【var ret = Func();】时，Func作用域中的xo变量的值已经由 “eric” 被重置为 “seven”，所以之后再执行【ret();】时，就只能找到“seven”。 示例三： 1234567891011121314xo = 'alex';function Bar()&#123; console.log(xo);&#125;function Func()&#123; var xo = "seven"; return Bar;&#125; var ret = Func();ret();// 输出结果： alex 上述代码，在函数被执行之前已经创建了两条作用域链： 全局作用域 -&gt; Bar函数作用域全局作用域 -&gt; Func函数作用域 当执行 ret() 时，ret代指的Bar函数，而Bar函数的作用域链已经存在：全局作用域 -&gt; Bar函数作用域，所以，执行时会根据已经存在的作用域链去寻找。 五、声明提前在JavaScript中如果不创建变量，直接去使用，则报错： 12console.log(xxoo);// 报错：Uncaught ReferenceError: xxoo is not defined JavaScript中如果创建值而不赋值，则该值为 undefined，如： 123var xxoo;console.log(xxoo);// 输出：undefined 在函数内如果这么写： 1234567function Foo()&#123; console.log(xo); var xo = 'seven';&#125; Foo();// 输出：undefined 上述代码，不报错而是输出 undefined，其原因是：JavaScript的函数在被执行之前，会将其中的变量全部声明，而不赋值。所以，相当于上述实例中，函数在“预编译”时，已经执行了var xo；所以上述代码中输出的是undefined。 原文链接： 五句话搞定JavaScript作用域]]></content>
      <categories>
        <category>作用域</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解Javascript上下文与作用域]]></title>
    <url>%2F2019%2F04%2F03%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%9B%BE%E8%A7%A3Javascript%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[本文尝试阐述Javascript中的上下文与作用域背后的机制，主要涉及到执行上下文（execution context）、作用域链（scope chain）、闭包（closure）、this等概念。 Execution context执行上下文（简称上下文）决定了Js执行过程中可以获取哪些变量、函数、数据，一段程序可能被分割成许多不同的上下文，每一个上下文都会绑定一个变量对象（variable object），它就像一个容器，用来存储当前上下文中所有已定义或可获取的变量、函数等。位于最顶端或最外层的上下文称为全局上下文（global context），全局上下文取决于执行环境，如Node中的global和Browser中的window： 需要注意的是，上下文与作用域（scope）是不同的概念。Js本身是单线程的，每当有function被执行时，就会产生一个新的上下文，这一上下文会被压入Js的上下文堆栈（context stack）中，function执行结束后则被弹出，因此Js解释器总是在栈顶上下文中执行。在生成新的上下文时，首先会绑定该上下文的变量对象，其中包括arguments和该函数中定义的变量；之后会创建属于该上下文的作用域链（scope chain），最后将this赋予这一function所属的Object，这一过程可以通过下图表示： this上文提到this被赋予function所属的Object，具体来说，当function是定义在global对中时，this指向global；当function作为Object的方法时，this指向该Object： 123456789101112131415var x = 1;var f = function()&#123; console.log(this.x);&#125;f(); // -&gt; 1var ff = function()&#123; this.x = 2; console.log(this.x);&#125;ff(); // -&gt; 2x // -&gt; 2var o = &#123;x: &quot;o&apos;s x&quot;, f: f&#125;;o.f(); // &quot;o&apos;s x&quot; Scope chain上文提到，在function被执行时生成新的上下文时会先绑定当前上下文的变量对象，再创建作用域链。我们知道function的定义是可以嵌套在其他function所创建的上下文中，也可以并列地定义在同一个上下文中（如global）。作用域链实际上就是自下而上地将所有嵌套定义的上下文所绑定的变量对象串接到一起，使嵌套的function可以“继承”上层上下文的变量，而并列的function之间互不干扰： 1234567891011121314151617181920var x = &apos;global&apos;;function a()&#123; var x = &quot;a&apos;s x&quot;; function b()&#123; var y = &quot;b&apos;s y&quot;; console.log(x); &#125;; b();&#125;function c()&#123; var x = &quot;c&apos;s x&quot;; function d()&#123; console.log(y); &#125;; d();&#125;a(); // -&gt; &quot;a&apos;s x&quot;c(); // -&gt; ReferenceError: y is not definedx // -&gt; &quot;global&quot;y // -&gt; ReferenceError: y is not defined Closure如果理解了上文中提到的上下文与作用域链的机制，再来看闭包的概念就很清楚了。每个function在调用时会创建新的上下文及作用域链，而作用域链就是将外层（上层）上下文所绑定的变量对象逐一串连起来，使当前function可以获取外层上下文的变量、数据等。如果我们在function中定义新的function，同时将内层function作为值返回，那么内层function所包含的作用域链将会一起返回，即使内层function在其他上下文中执行，其内部的作用域链仍然保持着原有的数据，而当前的上下文可能无法获取原先外层function中的数据，使得function内部的作用域链被保护起来，从而形成“闭包”。看下面的例子： 1234567891011121314151617var x = 100;var inc = function()&#123; var x = 0; return function()&#123; console.log(x++); &#125;;&#125;;var inc1 = inc();var inc2 = inc();inc1(); // -&gt; 0inc1(); // -&gt; 1inc2(); // -&gt; 0inc1(); // -&gt; 2inc2(); // -&gt; 1x; // -&gt; 100 执行过程如下图所示，inc内部返回的匿名function在创建时生成的作用域链包括了inc中的x，即使后来赋值给inc1和inc2之后，直接在global context下调用，它们的作用域链仍然是由定义中所处的上下文环境决定，而且由于x是在function inc中定义的，无法被外层的global context所改变，从而实现了闭包的效果： this in closure我们已经反复提到执行上下文和作用域实际上是通过function创建、分割的，而function中的this与作用域链不同，它是由执行该function时当前所处的Object环境所决定的，这也是this最容易被混淆用错的一点。一般情况下的例子如下： 12345678var name = &quot;global&quot;;var o = &#123; name: &quot;o&quot;, getName: function()&#123; return this.name &#125;&#125;;o.getName(); // -&gt; &quot;o&quot; 由于执行o.getName()时getName所绑定的this是调用它的o，所以此时this == o；更容易搞混的是在closure条件下： 12345678910var name = &quot;global&quot;;var oo = &#123; name: &quot;oo&quot;, getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;oo.getNameFunc()(); // -&gt; &quot;global&quot; 此时闭包函数被return后调用相当于： 12getName = oo.getNameFunc();getName(); // -&gt; &quot;global&quot; 换一个更明显的例子： 12345var ooo = &#123; name: &quot;ooo&quot;, getName: oo.getNameFunc() // 此时闭包函数的this被绑定到新的Object&#125;;ooo.getName(); // -&gt; &quot;ooo&quot; 当然，有时候为了避免闭包中的this在执行时被替换，可以采取下面的方法： 1234567891011var name = &quot;global&quot;;var oooo = &#123; name: &quot;ox4&quot;, getNameFunc: function()&#123; var self = this; return function()&#123; return self.name; &#125;; &#125;&#125;;oooo.getNameFunc()(); // -&gt; &quot;ox4&quot; 或者是在调用时强行定义执行的Object： 1234567891011var name = &quot;global&quot;;var oo = &#123; name: &quot;oo&quot;, getNameFunc: function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;oo.getNameFunc()(); // -&gt; &quot;global&quot;oo.getNameFunc().bind(oo)(); // -&gt; &quot;oo&quot; 总结Js是一门很有趣的语言，由于它的很多特性是针对HTML中DOM的操作，因而显得随意而略失严谨，但随着前端的不断繁荣发展和Node的兴起，Js已经不再是”toy language”或是jQuery时代的”CSS扩展”，本文提到的这些概念无论是对新手还是从传统Web开发中过度过来的Js开发人员来说，都很容易被混淆或误解，希望本文可以有所帮助。 转自：http://blog.rainy.im]]></content>
      <categories>
        <category>作用域</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[详解JavaScript变量提升]]></title>
    <url>%2F2019%2F04%2F02%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E8%AF%A6%E8%A7%A3JavaScript%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[变量在程序中随处可见。它们是一些始终在相互影响，相互作用的的数据和逻辑。正是这些互动使应用程序活了起来。 在JavaScript中使用变量很重要的一方面就是变量的提升 —— 它决定了一个变量何时可以被你的代码使用。如果你在寻找关于这方面的详细介绍，那你算是来对地方了。让我们一起看看吧。 1. 简介提升是一种将变量和函数的声明移到函数作用域(如果不在任何函数内的话就是全局作用域)最顶部的机制。 提升影响了变量的生命周期，一个变量的生命周期包含3个阶段： 声明 - 创建一个新变量，例如var myValue 初始化 - 用一个值初始化变量 例如myValue = 150 使用 - 使用变量的值 例如alert(myValue) 这个过程通常是像这样执行的：首先声明一个变量，然后用一个值给它初始化，最后就是使用它。让我们看一个例子： 123456// 声明var strNumber;// 初始化strNumber = '16';// 使用parseInt(strNumber); // =&gt; 16 在程序中一个函数可以先声明，后使用。初始化被忽略掉了。例如： 1234567// 声明function sum(a, b) &#123; return a + b;&#125;// 使用sum(5, 6);// =&gt; 11 当这三个步骤按顺序执行的时候，一切看起来都很简单，自然。如果可以话，在使用JavaScript编程的时候你应该遵循这种模式。 JavaScript并没有严格遵循这个顺序，因此提供了更多的灵活性。比如，函数的使用可以在声明之前。下边的例子先调用了函数double(5)，然后才声明该函数function double(num) {...}： 123456// 使用double(5); // =&gt; 1// 声明function double(num) &#123; return num * 2;&#125; 这是因为JavaScript中的函数声明会被提升到作用域顶部。 变量提升在不同方面的影响也不同： 变量声明: 使用var, let或const关键字 函数声明: 使用function () {...}语法 类声明: 使用class关键字 接下来让我们详细看看这些区别。 2. 函数作用域变量: var变量声明在函数作用域内创建并初始化一个变量，例如var myVar, myVar2 = &#39;Init&#39;。默认情况下，声明但是未初始化的变量的值是undefined。 自从JavaScript的第一版本开始，开发者就在使用这种方式声明变量。 123456// 声明变量numvar num;console.log(num); // =&gt; undefined// 声明并初始化变量strvar str = 'Hello World!';console.log(str); // =&gt; 'Hello World!' 提升与var使用var声明的变量会被提升到所在函数作用域的顶部。如果在声明之前访问该变量，它的值会是undefined。 假定myVariable在被var声明前被访问到。在这种情况下，声明操作会被移至double()函数的顶部同时该变量会被赋值undefined： 1234567function double(num) &#123; console.log(myVariable); // =&gt; undefined var myVariable; return num * 2;&#125;double(3); // =&gt; 6 JavaScript在执行代码时相当于把var myVariable移动到了double()的顶部，就像下面这样： 1234567function double(num) &#123; var myVariable; // 被移动到顶部 console.log(myVariable); // =&gt; undefined return num * 2;&#125;double(3); // =&gt; 6 var语法不仅可以声明变量，还可以在声明的同时赋给变量一个初始值：var str = &#39;initial value&#39;。当变量被提升时，声明会被移动到作用域顶部，但是初始值的赋值却会留在原地： 12345678function sum(a, b) &#123; console.log(myString); // =&gt; undefined var myString = 'Hello World'; console.log(myString); // =&gt; 'Hello World' return a + b;&#125;sum(16, 10); // =&gt; 26 var myString被提升到作用域的顶部，然而初始值的赋值操作myString = &#39;Hello World&#39;不会受到影响。上边的代码等价于下边的形式： 123456789function sum(a, b) &#123; var myString; // 提升到顶部 console.log(myString); // =&gt; undefined myString = 'Hello World'; // 赋值不受影响 console.log(myString); // =&gt; 'Hello World' return a + b;&#125;sum(16, 10); // =&gt; 26 3. 块级作用域变量: letlet声明在块级作用域内创建并初始化一个变量：let myVar, myVar2 = &#39;Init&#39;。默认情况下，声明但是未初始化的变量的值是undefined。 let是ECMAScript 6引入的一个巨大改进，它允许代码在代码块的级别上保持模块性和封装性： 12345678910if (true) &#123; // 声明块级变量 let month; console.log(month); // =&gt; undefined // 声明并初始化块级变量 let year = 1994; console.log(year); // =&gt; 1994&#125;// 在代码块外部不能访问month和year变量console.log(year); // ReferenceError: year is not defined 提升与let使用let定义的变量会被提升到代码块的顶部。但是如果在声明前访问该变量，JavaScript会抛出异常ReferenceError: is not defined。 在声明语句一直到代码库的顶部，变量都好像在一个临时死亡区间中一样，不能被访问。 让我们看看以下的例子： 1234567891011121314151617function isTruthy(value) &#123; var myVariable = 'Value 1'; if (value) &#123; /** * myVariable的临时死亡区间 */ // Throws ReferenceError: myVariable is not defined console.log(myVariable); let myVariable = 'Value 2'; // myVariable的临时死亡区间至此结束 console.log(myVariable); // =&gt; 'Value 2 return true; &#125; return false;&#125;isTruthy(1); // =&gt; true 从let myVariable一行一直到代码块开始的if (valaue) {...}都是myVariable变量的临时死亡区间。如果在此区间内访问该变量，JavaScript会抛出ReferenceError异常。 一个有趣的问题出现了：myVariable真的被提升到代码块顶部了吗？还是在临时死亡区间内未定义呢？当一个变量未被定义时，JavaScript也会抛出ReferenceError。 如果你观察一下该函数的开始部分就会发现，var myVariable = &#39;Value 1&#39;在整个函数作用域内定义了一个名为myVariable的变量。在if (value) {...}块内，如果let定义的变量没有被提升，那么在临时死亡区间内myVariable的值就会是&#39;Value1&#39;了。由此我们可以确认块级变量确实被提升了。 `` let在块级作用域内的提升保护了变量不受外层作用域影响。在临时死亡区间内访问let定义的变量时抛出异常会促使开发者遵循更好的编码实践：先声明，后使用。 这两个限制是促使在封装性和代码流程方面编写更好的JavaScript的有效途径。这是基于var用法教训的结果 —— 允许在声明之前访问变量很容易造成误解。 4. 常量: const常量声明在块级作用域内创建并初始化一个常量：const MY_CONST = &#39;Value&#39;, MY_CONST2 = &#39;Value 2&#39;。看看下边的示例： 12345const COLOR = 'red';console.log(COLOR); // =&gt; 'red'const ONE = 1, HALF = 0.5;console.log(ONE); // =&gt; 1console.log(HALF); // =&gt; 0.5 当声明一个变量时，必须在同一条语句中对该变量进行初始化。在声明与初始化之后，变量的值不能被修改。 123const PI = 3.14;console.log(PI); // =&gt; 3.14PI = 2.14; // TypeError: Assignment to constant variable 提升与const使用const定义的常量会被提升到代码块的顶部。 由于存在临时死亡区间，常量在声明之前不能被访问。如果在声明之前访问常量，JavaScript会抛出异常：ReferenceError: is not defined。 const声明常量的提升的效果与使用let声明变量的提升效果相同。 让我们在double()函数内声明一个常量: 12345678function double(number) &#123; // 常量TWO的临时死亡区间 console.log(TWO); // ReferenceError: TWO is not defined const TWO = 2; // 常量TWO的临时死亡区间至此结束 return number * TWO;&#125;double(5); // =&gt; 10 由于在声明之前使用常量会导致JavaScript抛出异常。因此使用常量时应该始终先声明，初始化，然后再使用。 5. 函数声明函数声明使用提供的名称和参数创建一个函数。 一个函数声明的例子： 1234function isOdd(number) &#123; return number % 2 === 1;&#125;isOdd(5); // =&gt; true function isOdd(number) {...}就是一段定义函数的声明。isOdd()用来验证一个数字是否是奇数。 提升与函数声明函数声明的提升允许你在所属作用域内任何地方使用该函数，即使是在声明之前也可以。换句话说，函数可以在当前作用域或子作用域内的任何地方访问(不会是undefined值，没有临时死亡区间，不会抛出异常)。 这种提升的行为非常灵活。不管是先使用，后声明，还是先声明，后使用都可以如你所愿。 下边的例子在开始的地方调用了一个函数，然后才定义它： 123456// 调用被提升的函数equal(1, '1'); // =&gt; false// 函数声明function equal(value1, value2) &#123; return value1 === value2;&#125; 这段代码可以正常执行是因为equal()被提升到了作用域顶部。 需要注意的函数声明function () {...}和函数表达式 var = function() {...}之间的区别。两者都用于创建函数，但是却有着不同的提升机制。 下边的例子演示了该区别： 123456789101112// 调用被提升的函数addition(4, 7); // =&gt; 11// 变量被提升了，但值是undefinedsubstraction(10, 7); // TypeError: substraction is not a function// 函数声明function addition(num1, num2) &#123; return num1 + num2;&#125;// 函数表达式var substraction = function (num1, num2) &#123; return num1 - num2;&#125;; addition被彻底的提升并且可以在声明之前被调用。 然而substraction是使用变量声明语句声明的，虽然也被提升了，但被调用时值是undefined。因此会抛出异常TypeError: substraction is not a function。 6. 类声明类声明使用提供的名称和参数创建一个构造函数。类是ECMAScript 6中引入的一项巨大改进。 类建立在JavaScript的原型继承之上并提供了诸如super(访问父类)，static(定义静态方法)，extends(定义子类)之类的额外功能。 一起看看如何声明一个类并创建一个实例： 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; move(dX, dY) &#123; this.x += dX; this.y += dY; &#125;&#125;// 创建实例var origin = new Point(0, 0);// 调用实例的方法origin.move(50, 100); 提升与class类声明会被提升到块级作用域的顶部。但是如果你在声明前使用类，JavaScript会抛出异常ReferenceError: is not defined。所以正确的方法是先声明类，然后再使用它创建实例。 类声明的提升与let定义变量的提升效果类似。 让我们看看在声明之前创建类实例会怎样： 1234567891011// 使用Company类// 抛出ReferenceError: Company is not definedvar apple = new Company('Apple');// 类声明class Company &#123; constructor(name) &#123; this.name = name; &#125;&#125;// 在声明之后使用Company类var microsoft = new Company('Microsoft'); 和预期的一样，在类定义之前执行new Company(&#39;Apple&#39;)会抛出ReferenceError异常。这很不错，因为JavaScript鼓励先声明后使用的方式。 还可以用使用了变量声明语句(var，let和const)的类表达式创建类。让我们看看下面的场景： 12345678910111213141516// 使用Sqaure类console.log(typeof Square); // =&gt; 'undefined'//Throws TypeError: Square is not a constructorvar mySquare = new Square(10);// 使用变量声明语句声明类var Square = class &#123; constructor(sideLength) &#123; this.sideLength = sideLength; &#125; getArea() &#123; return Math.pow(this.sideLength, 2); &#125;&#125;;// 在声明之后使用Square类var otherSquare = new Square(5); 这个类使用变量声明语句var Square = class {...}定义。Square变量被提升到了作用域的顶部，但是直到声明该变量的这行代码之前其值都是undefined。因此var mySquare = new Square(10)语句相当于把undefined当作构造函数使用，这导致JavaScript抛出TypeError: Square is not a constructor异常。 7. 最后的想法像在本文阐述的那样，JavaScript中的提升有多种形式。即使你知道它的工作方式，一般还是建议按照声明 &gt; 初始化 &gt; 使用的顺序使用变量。通过let，const和class提升的方式可以看出ECMAScript 6强烈支持这种使用方式。这将使你免于遇见不期望的变量，undefined以及ReferenceError的困扰。 有一种函数可以在定义之前执行的例外情况。这就是当开发者需要快速了解函数如何被调用的时候，因为这样就不必再滚动到底部阅读函数的具体实现方式了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[论程序员的赌博式编程]]></title>
    <url>%2F2019%2F03%2F30%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E8%AE%BA%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%B5%8C%E5%8D%9A%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[定义：所谓“赌博式编程”，“撞大运编程”就是指程序员在敲代码的时候，不知道自己的代码是不是最终work，既不知其然也不知所以然，反正不管三七二七一先提交再说，这就如同赌博一般。与之相反的，就是通常的“最佳实践” 赌博式编程和最佳实践，究竟应该怎么做呢？我都亲身试过 赌博式编程中，虽然代码写得烂，但是CI/CD的频次高，并且自己态度积极耐心，很容易得到周围人的好评。因为大家遇到什么问题都指望着你。最后代码必然成一团乱码，自己也必然搞不懂，但是因为在生产环境得到广泛使用，公司即使再“优化”也动不到自己头上。 之前我被指派去写一个复杂4层嵌套SQL，我就凭感觉写，写完我心里根本没底，测试和业务组不断报错，他们每次报错我就改。前后改了30次，直到测不出问题。后来因为我提交次数多，更改不厌其烦，反而得了好评。 反过来：只要真的走心了，反而会遭到同事或领导差评。why？主观用心了，就必然会影响时间进度。这对于尤其是外行项目经理或者是老板，时间才是致命（和碧桂园要钱不要命的“高周转”类似）。+1s已经是不可能的，你这得加多少秒啊…… 当时，我走心地写了一个项目，虽然时间在可控期内，我却犯了另一个错误，潜意识里对周围同事不耐烦，有时候会说“这个东西我已经明明白白写在文档里了啊……”然后我一边继续精进，却忽略到那个同事心里暗骂我的表情。最终，代码无bug上线了，所有人都能动清晰模块化的结构，离自己被公司“优化”也就不远了。 越是大的公司，越是不懂行的领导或同事，就越应该采取这种“赌博式发布”的策略。 无独有偶，软件公司如此，连投资上百亿的芯片公司也如此。你们知道芯片吧，如果是做CPU或者是ASIC挖矿的，一次流片tapeout（相当于软件公司的publish / release）的成本是千万级，即使这样，一家国内的币圈知名的芯片公司都被人诟病：“赌博式流片”。所谓的赌博式流片，就是说发布之前既没有经过系统的正向推导，也没有经过彻底的测试，就直接流片，万一有bug，就要重新流，之前烧的几千万就打水漂了。“我欲将心向明月，奈何明月照沟渠”。这就是现实版的 欧·亨利 的𝑻𝒉𝒆 𝑪𝒐𝒑 𝒂𝒏𝒅 𝒕𝒉𝒆 𝑨𝒏𝒕𝒉𝒆𝒎。 一个人的职场命运啊，当然要靠自我奋斗，但是也要考虑 人生的经验。 转自 ：掘金]]></content>
  </entry>
  <entry>
    <title><![CDATA[搞笑图组：程序员的项目周期]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E6%90%9E%E7%AC%91%E5%9B%BE%E7%BB%84%EF%BC%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[搞笑图组：程序员的项目周期一，需求审评会议进行中。 二.开发阶段进行中…. 三，代码复查阶段 四，测试阶段…. 五，需求突然要改…. 六，项目上线]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用react-transition-group实现动画效果]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BD%BF%E7%94%A8react-transition-group%E5%AE%9E%E7%8E%B0%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[React性能优化]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FReact%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[1.父组件render执行 子组件的render也被执行 通过shouldComponentUpdate(nextProps,nextState)2.绑定事件 修改作用域放在 constructor3]]></content>
  </entry>
  <entry>
    <title><![CDATA[深入了解React中虚拟DOM]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3React%E4%B8%AD%E8%99%9A%E6%8B%9FDOM%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[使用nvm管理不同版本的 node与npm]]></title>
    <url>%2F2019%2F03%2F20%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BD%BF%E7%94%A8nvm%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84node%E4%B8%8Enpm%2F</url>
    <content type="text"><![CDATA[在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 NodeJS 运行环境。如果没有一个合适的工具，这个问题将非常棘手。 nvm 应运而生，nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。 nvm 与 n 的区别node 版本管理工具还有一个是 TJ大神的 n 命令，n 命令是作为一个 node 的模块而存在，而 nvm 是一个独立于 node/npm 的外部 shell 脚本，因此 n 命令相比 nvm 更加局限。 由于 npm 安装的模块路径均为 /usr/local/lib/node_modules，当使用 n 切换不同的 node 版本时，实际上会共用全局的 node/npm 目录。 因此不能很好的满足『按不同 node 版本使用不同全局 node 模块』的需求。 卸载全局安装的 node/npm在官网下载的 node 安装包，运行后会自动安装在全局目录，使用过程中经常会遇到一些权限问题，所以推荐按照以下方法卸载全局安装的 node/npm。 首先，打开你 Finder，按 shift+command+G，打开前往文件夹的窗口，分别输入下列目录进去之后删除 node 和 node_modules 相关的文件和文件夹: 打开 /usr/local/lib，删除 node 和 node_modules 相关的文件和文件夹 打开 /usr/local/include，删除 node 和 node_modules 相关的文件和文件夹 如果你是使用的 brew install node 安装的 NodeJS，那么你还需要在终端中执行 brew uninstall node 命令来卸载 检查你的个人主文件夹下面的所有的 local、lib 以及 include 文件夹，并且删除所有与 node 和 node_modules 相关的文件以及文件夹 打开 /usr/local/bin 并删除 node 可执行文件 你可能还需要在你的终端中输入一些额外的指令： 12345678sudo rm /usr/local/bin/npmsudo rm /usr/local/share/man/man1/node.1sudo rm /usr/local/lib/dtrace/node.dsudo rm -rf ~/.npmsudo rm -rf ~/.node-gypsudo rm /opt/local/bin/nodesudo rm /opt/local/include/nodesudo rm -rf /opt/local/lib/node_modules Windows 安装首先最重要的是：一定要卸载已安装的 NodeJS，否则会发生冲突。然后下载 nvm-windows 最新安装包，直接安装即可。 OS X/Linux 安装与 Windows 不同，我们并不一定要先卸载原有的 NodeJS。当然我们推荐还是先卸载掉比较好。另外，你还需要 C++ 编译器，Linux 发行版一般不用担心，像 Ubuntu 都可以直接用 build-essential 套件，OS X 的话，可以用 X-Code 的命令行工具。运行这个命令即可： 1xcode-select --install 在 Linux 中：（如果是 Debian 发行版） 1sudo apt-get install build-essential 然后我们可以使用 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 或者 1wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 从远程下载 install.sh 脚本并执行。注意这个版本年数字 v0.33.0 会随着项目开发而变化。随时通过官方最新安装命令来检查最新安装版本是有好处的。 配置mac环境变量 启动终端Terminal 进入当前用户的home目录 1输入cd ~ 创建.bash_profile 1输入touch .bash_profile 编辑.bash_profile文件 1输入open -e .bash_profile 保存文件，关闭.bash_profile 更新刚配置的环境变量 1输入source .bash_profile 在项目中使用不同版本的 Node我们可以通过创建项目目录中的 .nvmrc 文件来指定要使用的 Node 版本。之后在项目目录中执行 nvm use 即可。.nvmrc 文件内容只需要遵守上文提到的语义化版本规则即可。另外还有个工具叫做 avn，可以自动化这个过程。 在多环境中，npm该如何使用呢？每个版本的 Node 都会自带一个不同版本的 npm，可以用 npm -v 来查看 npm 的版本。全局安装的 npm 包并不会在不同的 Node 环境中共享，因为这会引起兼容问题。它们被放在了不同版本的目录下，例如 ~/.nvm/versions/node//lib/node_modules 这样的目录。这刚好也省去我们在 Linux 中使用 sudo 的功夫了。因为这是用户的主文件夹，并不会引起权限问题。 但问题来了，我们安装过的 npm 包，都要重新再装一次？幸运的是，我们有个办法来解决我们的问题，运行下面这个命令，可以从特定版本导入到我们将要安装的新版本 Node： 1nvm install v5.0.0 --reinstall-packages-from=4.2 其他命令12345678910111213141516171819nvm install &lt;version&gt; ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4nvm uninstall &lt;version&gt; ## 删除已安装的指定版本，语法与install类似nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm which &lt;version&gt; ## 确认某个版本Node的路径nvm ls ## 列出所有安装的版本nvm ls-remote ## 列出所以远程服务器的版本（官方node version list）nvm current ## 显示当前的版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名nvm reinstall-packages &lt;version&gt; ## 在当前版本node环境下，重新全局安装指定版本号的npm包 快捷命令： nvm install node 安装最新版 Node nvm install iojs 安装最新版 iojs nvm install unstable 安装最新不稳定版本的 Node]]></content>
  </entry>
  <entry>
    <title><![CDATA[css3属性box-decoration-break]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fcss3%E5%B1%9E%E6%80%A7box-decoration-break%2F</url>
    <content type="text"><![CDATA[这两天接触到一个很有意思的 CSS 属性 – box-decoration-break。下面就一起去一探究竟。 因为 MDN 上关于这个属性，没有中文文档，所以一直在想一个合理贴切的中文翻译。直译一下： box – 盒，可以理解为元素盒模型 decoration – 装饰，理解为元素样式 break – 断行，参考word-break ，理解为断行时候的表现 那么，这个属性可以先理解为，元素在发生断行时其样式的表现形式。 MDN 上英文释意为：The box-decoration-break CSS property specifies how an element’s fragments should be rendered when broken across multiple lines, columns, or pages。大意是 box-decoration-break 属性规定了一个元素片段在发生折行/断行时，应该如何被渲染。 可选取值只有两个： 1234&#123; box-decoration-break: slice; // 默认取值 box-decoration-break: clone;&#125; 换行示例这个属性通常作用于内联元素。假设我们存在如下结构，并且给它添加一个边框： 1234&lt;span&gt;ABCDEFGHIJKLMN&lt;/span&gt;span &#123; border: 2px solid #999;&#125; 嗯，效果如下，平平无奇： 好，接下来就是 break，我们把上面一行的文字断行，样式不变： 1&lt;span&gt;ABCD &lt;br/&gt;EFG &lt;br/&gt; HI&lt;br/&gt; JKLMN&lt;/span&gt; 得到如下结果： O，可以看到，文字换行的同时，边框也随之变化，头尾两行都有 3 边边框，中间两行只有上下两边边框。如果将 4 行合起来，可以拼成图一，这个是正常的展示效果。 接下来，我们加上本文的主角 box-decoration-break: clone： 1234span &#123; border: 2px solid #999;+ box-decoration-break: clone;&#125; 生效后，我们将会得到这样的结果： box-decoration-break: clone 使用小结看到这里，我们已经可以大概理解这个属性的作用了： 使用了 box-decoration-break: clone 的内联元素，如果存在折行显示，那么每一行都将拥有原本单行的所有完整样式。 再看个例子加深下理解，存在如下结构，其使用了 box-decoration-break: clone 前后两种效果： 1&lt;span &gt;每一行 &lt;br/&gt;样式 &lt;br/&gt; 都 &lt;br/&gt; 保持&lt;br/&gt; 完整独立&lt;/span&gt; CodePen Demo – box-decoration-break点击预览 box-decoration-break: clone 生效样式影响范围当然，使用了 box-decoration-break: clone 的元素并非对每一个样式都会生效，只会作用于下列样式： background border border-image box-shadow clip-path margin padding Syntax box-decoration-break: clone 实际应用接下来看看，有没有什么靠谱的实际应用场景。 box-decoration-break: clone 实现文本选中效果会有这样的场景，我们希望对一个多行文本中的特定一段文本进行着重展示。这个时候，我们可以通过 &lt;p&gt; 嵌套 &lt;span&gt; ，对 &lt;span&gt; 包裹的文字进行一些特定的展示。 譬如我们有这样一段文案： 123&lt;p&gt;The &lt;span&gt;box-decoration-break&lt;/span&gt; CSS property specifies how an element&apos;s fragments should be rendered when broken across multiple lines, columns, or pages..Each box fragment is rendered independently with the &lt;span&gt;specified border, padding, and margin wrapping each fragment.&lt;/span&gt; The border-radius, border-image, and box-shadow are applied to each &lt;span&gt;fragment independently.&lt;/span&gt; &lt;/p&gt; 其中，我们将需要强调的内容通过 &lt;span&gt; 标签包裹起来，赋予特定样式并且加上 box-decoration-break: clone，这样，无论强调文案是否换行，每一处的强调背景都是一致的： 123456789101112p &#123; font-size: 22px; line-height: 36px;&#125;span &#123; background-image: linear-gradient(135deg, deeppink, yellowgreen); color: #fff; padding: 2px 10px; border-radius: 50% 3em 50% 3em; box-decoration-break: clone;&#125; 得到如下效果： 如果不加 box-decoration-break: clone 呢？那么如果存在换行，效果会大打折扣： CodePen Demo – text-decoration-break 文本选中效果点击预览 box-decoration-break 每行文字带特定边框又会有这样的场景，我们希望每一行文案都带有特定的边框样式，像这样： 怎么实现呢？也许可以每一行都是一个 &lt;p&gt;，每一行 &lt;p&gt; 设定上述样式。但是如果文本内容不确定，容器的宽度也不确定呢？ 这种场景，使用 box-decoration-break 也非常便捷。当然这里有个小技巧，正常而言， box-decoration-break: clone只对 inline 元素生效，如果我们的文案像是这样包裹在 &lt;p&gt; 标签内： 123&lt;p&gt;The box-decoration-break CSS property specifies how an element&apos;s fragments should be rendered when broken across multiple lines, columns, or pages..Each box fragment is rendered independently with the specified border, padding, and margin wrapping each fragment. The border-radius, border-image, and box-shadow are applied to each fragment independently. &lt;/p&gt; 要使 box-decoration-break: clone 对 &lt;p&gt; 生效，可以通过设定 &lt;p&gt; 的 display: inline 来实现。如此一来，要实现上述效果，我们只需要： 12345p &#123; display: inline; box-decoration-break: clone; background:linear-gradient(110deg, deeppink 0%, deeppink 98%, transparent 98%, transparent 100%);&#125; 无论文本内容或者容器宽度如何变化，都能完美适配： CodePen Demo – box-decoration-break 每行文字带特定边框点击预览 box-decoration-break 结合过渡动画结合上面的内容，我们还可以考虑将 box-decoration-break 与过渡效果或者动画效果结合起来。 譬如，我们希望当我们 hover 文字内容的时候，一些重点需要展示的文字段落能够被强调展示，可能是这样： CodePen Demo – box-decoration-break 过渡动画点击预览 又或者是这样： CodePen Demo – box-decoration-break 结合过渡动画点击预览 你可以尝试点进 Demo ，然后去掉 box-decoration-break: clone ，会发现效果大打折扣。 兼容性额，按照惯例兼容性应该都不太行。并且 MDN 也给出了这样的提示： This is an experimental technology. Check the Browser compatibility table carefully before using this in production. 看看 Can I Use，其实还好，除了 IE 系列全军覆没，所以可以考虑应用在移动端。即便这个属性不兼容，降级展示对页面不会造成什么影响： 另外，本文中，给出的代码都是 box-decoration-break: clone ，CodePen 自带了 autoprefixer 实际中可能需要写成： 1234&#123; box-decoration-break: clone; -webkit-box-decoration-break: clone;&#125; 最后国内看到了大漠老师和张鑫旭大大都已经写过这个属性，大家可以对比着看看，加深理解： CSS/CSS3 box-decoration-break属性简介 初探box-decoration-break 更多精彩 CSS 技术文章汇总在我的 Github – iCSS ，持续更新，欢迎点个 star 订阅收藏。 好了，本文到此结束，希望对你有帮助 :) 如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。]]></content>
  </entry>
  <entry>
    <title><![CDATA[浏览器多标签页通信]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E6%A0%87%E7%AD%BE%E9%A1%B5%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[浏览器多标签页通信有助于降低服务器负载，提高运营人员的工作效率，提高用户体验。是前端开发优化的一个重要环节。 需求来源在多数CMS（内容管理系统）后台上，常见的是一个文章列表页面，点击列表项会打开一个新的文章详情页面。编辑人员经常在这个详情页面上对文章操作，比如修改标题、配图、摘要等内容。操作完毕之后，由于文章页和列表页是两个页面，文章内容数据不能及时同步到列表，这样就照成运营人员多次误操作，这大大降低了运营人员的工作效率。 对于前端工程师来讲，实现浏览器多个页卡之间的通信，及时更新相关数据更改，是一件重要的事情。 例如有一个需求：当文章详情页面更新的时候，会同步到文章列表页。 实现方式方式一：cookie+setIntervalcookie最初是在客户端用于存储用户的会话信息的。由于HTTP是一种无状态的协议，服务器单从网络连接上无法知道客户身份。通过cookie就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该cookie一同提交给服务器。服务器检查该cookie，以此来辨认用户状态。服务器还可以根据需要修改cookie的内容。 在JavaScript中，cookie的操作接口即document.cookie，通过这个接口可以读取、写入、删除cookie。这个操作其实不太友好，所以很多工具库提供了cookie的操作方法。我这里提供一个简单的封装方法。 123456789101112131415161718192021var QQ = &#123;&#125;;QQ.Cookie=&#123; set:function(name,value,expires,path,domain)&#123; if(typeof expires==&quot;undefined&quot;)&#123; expires=new Date(new Date().getTime()+3600*1000); &#125; document.cookie=name+&quot;=&quot;+escape(value)+((expires)?&quot;; expires=&quot;+expires.toGMTString():&quot;&quot;)+((path)?&quot;; path=&quot;+path:&quot;; path=/&quot;)+((domain)?&quot;;domain=&quot;+domain:&quot;&quot;); &#125;, get:function(name)&#123; var arr=document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;)); if(arr!=null)&#123; return unescape(arr[2]); &#125; return null; &#125;, clear:function(name,path,domain)&#123; if(this.get(name))&#123; document.cookie=name+&quot;=&quot;+((path)?&quot;; path=&quot;+path:&quot;; path=/&quot;)+((domain)?&quot;; domain=&quot;+domain:&quot;&quot;)+&quot;;expires=Fri, 02-Jan-1970 00:00:00 GMT&quot;; &#125; &#125;&#125;; cookie有个特性，一个页面产生的cookie能被与这个页面的同一目录或者其他子目录下的页面访问，这样页面之间就产生了一个共享的存储空间。通常把cookie的path设置为一个更高级别的目录，比如默认“/”，从而使更多的页面共享cookie，实现多页面之间相互通信。 cookie所在的域，默认为请求的地址，也可以通过设置document.domain为父域等方式扩大cookie可被访问的域。 实现原理：列表页通过setInterval定时器循环监听cookie的数据变动列表页代码： 123456789window.onload=function()&#123; var tid = &apos;&apos;; setInterval(function()&#123; if(tid != QQ.Cookie.get(&quot;tid&quot;))&#123; alert(&apos;数据更新！&apos;)； tid = QQ.Cookie.get(&quot;tid&quot;) &#125; &#125;, 1000);&#125; 当详情页有数据修改时后，写入cookie详情页代码： 123456789101112&lt;input id=&quot;content&quot; type=&quot;text&quot;&gt;&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;&lt;script&gt; window.onload=function()&#123; var oBtn=document.getElementById(&quot;btn&quot;); var oInput=document.getElementById(&quot;content&quot;); oBtn.onclick=function()&#123; var val=oInput.value; QQ.Cookie.set(&quot;tid&quot;,val); &#125; &#125;&lt;/script&gt; cookie+setInterval的不足：1、cookie空间有限，浏览器在每一个域名下最多能设置30-50个cookie，容量最多4K左右。2、每次HTTP请求会把当前域的cookie发送到服务器上，而有些cookie只是浏览器才用的到，浪费网络带宽。3、setInterval的频率设置，过大会影响浏览器性能，过小会影响时效性。 cookie+setInterval的优点：兼容性好，几乎所有的浏览器都支持。 方式二：localStorage在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。localStorage的API也很简单，提供了JS的读写操作。 1234567891011121314if(！window.localStorage)&#123; alert(&quot;浏览器不支持localstorage&quot;); return false;&#125;else&#123; var storage = window.localStorage; //通过属性写入a字段 storage.a = 1; //通过方法写入b字段 storage.setItem(&quot;b&quot;,2); storage.getItem(&quot;a&quot;); storage.b; storage.clear();&#125; 它还比cookie多了一个优点，提供了onstorage以及storage事件，可以绑定一个回调函数，使用如下： 123window.onstorage = function(e)&#123;console.log(e)&#125;// 或者window.addEventListener(&apos;storage&apos;, function()&#123; console.log(e)&#125;) localStorage是Storage对象的实例。对Storage对象进行任何修改，都会在触发storage事件。当通过属性或者setItem()方法保存数据，或者使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会触发该事件。通过这个事件，我们可以实现页卡之间的变动监听。 实现原理：列表页通过storage监听localStorage的数据变动列表页代码： 1234567&lt;script&gt; window.addEventListener(&quot;storage&quot;,function(event)&#123; console.log(&quot;newValue is&quot;+localStorage.getItem(&quot;tid&quot;)); console.log(&quot;oldValue is&quot;+event.oldValue); window.alert(&apos;数据更新！&apos;); &#125;,false); &lt;/script&gt; 当详情页有数据修改时后，写入localStorage详情页代码： 123456789101112&lt;input id=&quot;content&quot; type=&quot;text&quot;/&gt;&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;&lt;script&gt; window.onload=function()&#123; var oBtn=document.getElementById(&quot;btn&quot;); var oInput=document.getElementById(&quot;content&quot;); oBtn.onclick=function()&#123; var val=oInput.value; localStorage.setItem(&quot;tid&quot;,val); &#125; &#125;&lt;/script&gt; 不过，onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。还有就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key为a，值为1的localStorage，再执行：localStorage.setItem(‘a’, 1)代码，同样是不会触发监听函数的。 localStorage的不足：1、浏览器的容量大小不统一（比cookie大很多了），并且在高版本的浏览器才支持localStorage这个属性2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，需要JSON转换。3、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。4、localStorage只能监听非己页面的数据变化，这一点严重影响使用。 localStorage的优点：1、解决了cookie容量小和时效性不足的问题。 方式三：WebSocketWebSocket API是下一代客户端–服务器的异步通信方法，已被W3C进行了标准化。WebSocket API最伟大之处在于服务器和客户端可以双向实时通信。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。 它的使用很简单，如下： 123456789101112131415161718// 创建一个Socket实例var socket = new WebSocket(&apos;ws://localhost:8080&apos;); // 打开Socket socket.onopen = function(event) &#123; // 发送一个初始化消息 socket.send(&apos;I am the client and I\&apos;m listening!&apos;); // 监听消息 socket.onmessage = function(event) &#123; console.log(&apos;Client received a message&apos;,event); &#125;; // 监听Socket的关闭 socket.onclose = function(event) &#123; console.log(&apos;Client notified socket has closed&apos;,event); &#125;; // 关闭Socket.... socket.close() &#125;; WebSocket提供了send方法和onmessage事件，用来发送和接收数据。onmessage事件提供了一个data属性，它可以包含消息的Body部分。消息的Body部分必须是一个字符串，可以进行序列化/反序列化操作，以便传递更多的数据。 实现原理：列表页通过onmessage监听socket服务器发送过来的消息列表页代码： 12345678&lt;script&gt; var socket = new WebSocket(&apos;ws://localhost:8080&apos;); socket.onopen = function(event) &#123; socket.onmessage = function(event) &#123; console.log(&apos;Client received a message&apos;, event); &#125;; &#125;; &lt;/script&gt; 当详情页有数据修改时后，通过socket连接，通知列表页更新数据。详情页代码： 123456789101112131415&lt;input id=&quot;content&quot; type=&quot;text&quot;/&gt;&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;&lt;script&gt; var socket = new WebSocket(&apos;ws://localhost:8080&apos;); window.onload=function()&#123; var oBtn=document.getElementById(&quot;btn&quot;); var oInput=document.getElementById(&quot;content&quot;); oBtn.onclick=function()&#123; var val=oInput.value; socket.onopen = function(event) &#123; // 发送数据类型必须是string、ArrayBuffer、Blob之一 socket.send(&apos;数据更新!&apos;); &#125; &#125;&lt;/script&gt; WebSocket的语法非常简单，不过需要IE10+浏览器才支持WebSocket通信。如果你的业务需要兼容IE8，9。业界通常使用第三方库来解决这个问题，比如Socket.IO，它使用检测功能来判断是否建立WebSocket连接，或者是AJAX long-polling连接，或Flash等，可快速创建实时的应用程序。Socket.IO还提供了一个NodeJS API，它看起来非常像浏览器的API。 WebSocket的不足：1、它需要服务端的支持才能完成任务。如果socket数据量比较大的话，会严重消耗服务器的资源。 WebSocket的优点：1、使用简单，功能灵活、强大，如果部署了WebSocket服务器，可以实现很多实时的功能。 方式四：BroadcastChannelBroadcastChannel即广播频道，是window下面的一个API，该API是用于同源不同页面之间完成通信的功能。我们可以理解它是一个广播台，所有的广播实例，都会接入这个广播台（中介者模式中的控制中心），所以，只要在初始化实例时，传入相同的频道值，就会被接入到一个相同的广播频道中。它的实现最简单，很多第三方JS库都实现了一套自己的BroadcastChannel。 实现原理：列表页通过onmessage监听其他页面发送过来的消息列表页代码： 12345// 接收广播let articleCast = new BroadcastChannel(&apos;mychannel&apos;);articleCast.onmessage = function (e) &#123; console.log(e.data);&#125; 当详情页有数据修改时后，通过postMessage，传递数据。详情页代码： 1234// 创建广播并发送let listCast = new BroadcastChannel(&apos;mychannel&apos;); myObj = &#123; tid: &quot;123&quot;, title: &quot;更改后的标题&quot; &#125;;listCast.postMessage(myObj); BroadcastChannel的不足：1、兼容性极差，只支持最新版的Chrome和Firefox，完全不支持IE和Safari。 BroadcastChannel的优点：1、使用简单，功能单一，跨页面通信的理想选择。 方式五：SharedWorkerSharedWorker也是HTML5提供的新的浏览器API，叫共享工作线程。它允许多个页面共享使用线程，每个页面都链接到该共享工作线程的某个端口号上。页面通过该端口与共享工作线程进行通信。目前的Web所有程序的操作都基于页面的，而SharedWorker的引入开辟了一个“Web程序”在后台线程的概念。而且它还可以和页面交互，相当于把所有页面都聚拢起来了。上例讲为每个页面都维护一份WebSocket代码不仅耗费大量的连接数，而且还拖慢性能。这些通用的连接最好当然做成可跨域页面共用的，在SharedWorker引入之前并没有一个完美的跨页面通信解决方案。 实现原理列表页通过onmessage监听SharedWoker发送过来的消息列表页代码： 12345678&lt;script&gt; var s = new SharedWorker(&apos;x.js&apos;); s.port.onmessage = function(e)&#123; console.log(e.data); window.alert(&quot;数据变化！&quot;) &#125;; s.port.start();&lt;/script&gt; 当详情页有数据修改时后，通过SharedWorker，通知列表页更新数据。 12345678&lt;input id=&quot;content&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot; /&gt;&lt;script&gt; var s = new SharedWorker(&apos;x.js&apos;); btn.onclick=function()&#123; s.port.postMessage(document.getElementById(&apos;content&apos;).value); &#125;; s.port.start();&lt;/script&gt; 其中共享线程x.js的代码也很简单，它的工作是双向的，每一个页面都可以用来接收和发送数据。 123456789//x.jsvar pool = [];onconnect = function(e) &#123; pool.push(e.ports[0]); e.ports[0].onmessage = function(e)&#123; for(var i=0; i&lt;pool.length; i++) pool[i].postMessage(e.data); &#125;;&#125;; SharedWorker就像运行在浏览器后端的守卫者，可以被多个window同时使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)。 SharedWorker的不足：1、兼容性较差，IE完全不支持，chrome和Firefox支持很完善，Safari部分支持，如果你的业务是内部系统，不考虑IE，可以使用。2、API比较简单，配置繁琐，使用起来还是比较麻烦。 SharedWorker的优点：1、功能强大，不限于浏览器通信，还有共享数据，方法等功能。由于是另启的一个新线程，不影响主线程代码业务，性能优秀，无需借助服务器，是一个完美的跨页面通信解决方案。 我们做了什么？（划重点）SharedWorker提供的API很少，使用比较简单，如果需要完成复杂的页面通信，还是有一定难度。基于此，我实现了一款基于SharedWorker的封装库，叫作superSharedWorker 它是一款页面之间通信的JavaScript框架，它通过shared worker 实现纯浏览器页卡之间的通信。你无需了解shared worker，可以快速使用页面之间的数据传递，快捷，强大。它的优点就是通过原生JS实现，无需依赖任何JS库实现了对sharedWorker的封装。开箱即用，配置简单。 两种使用方式：1、ES6 import的方式 123import superSharedWorker from &apos;./src/index.js&apos;;let superSharedWorker = new superSharedWorker(&apos;page1&apos;, callback); //注册superSharedWorker.send(&apos;hello world!&apos;); //发送消息 2、script标签外链的形式 12345678910&lt;script src=&quot;./build/super-sharedworker.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; //&lt;!-- var superSharedWorker = new SuperShared(&apos;page1&apos;, onRecvMsg); function onRecvMsg(message) &#123; console.log(message) &#125; superSharedWorker.send(&apos;hello, world&apos;); //--&gt;&lt;/script&gt; 更多用法举例： 12345let superSharedWorker = new superSharedWorker(&apos;page1&apos;, callback); //注册superSharedWorker.add(&#123;name:&apos;chunpengliu&apos;, sex:1&#125;);superSharedWorker.del(&apos;sex&apos;);// 删除缓冲区数据superSharedWorker.send(&#123;&apos;time&apos;:2019&#125;, &apos;page2&apos;); //一次性发送缓冲区数据，只发送给name=&quot;page2&quot;的页面superSharedWorker.close(); //关闭线程，节省资源 它提供了很多强大的功能，可一对一，一对多发送消息。像使用git一样传递数据。 小结通过讨论，实现了四种实现浏览器标签页之间的通信，分别是使用cookie、使用websocket协议、通过localstorage、以及使用html5浏览器的新特性SharedWorker，每种方法各有利弊。如果不考虑兼容旧的浏览器，superSharedWorker 或许是最好的解决方案，优化使用效率，提升用户体验，赶快使用浏览器多标签页通信功能吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript多线程编程-worker]]></title>
    <url>%2F2019%2F03%2F07%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FJavaScript%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-worker%2F</url>
    <content type="text"><![CDATA[远离浏览器卡顿，提高用户体验，提升代码运行效率，使用多线程编程方法。 浏览器端JavaScript是以单线程的方式执行的，也就是说JavaScript和UI渲染占用同一个主线程，那就意味着，如果JavaScript进行高负载的数据处理，UI渲染就很有可能被阻断，浏览器就会出现卡顿，降低了用户体验。 为此，JavaScript提供了异步操作，比如定时器(setTimeout、setInterval)事件、Ajax请求、I/O回调等。我们可以把高负载的任务使用异步处理，它们将会被放入浏览器的事件任务队列（event loop）中去，等到JavaScript运行时执行线程空闲时候，事件队列才会按照先进先出的原则被一一执行。 通过类似定时器，回调函数等异步编程方式在平常的工作中已经足够，但是如果做复杂运算，这种方式的不足就逐渐体现出来，比如settimeout拿到的值并不正确，或者页面有复杂运算的时候很容易触发假死状态，异步代码会影响主线程的代码执行，异步终究还是单线程，不能从根本上解决问题。 多线程（Web Worker）就应运而生，它是HTML5标准的一部分，这一规范定义了一套 API，允许一段JavaScript程序运行在主线程之外的另外一个线程中。将一些任务分配给后者运行。在主线程运行的同时，Worker（子）线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。 什么是web worker worker是window对象的一个方法，就是用它来创建多线程。可以通过以下方式来检测你的浏览器是否支持worker 1if (window.Worker) &#123;…… your code ……&#125; 一个worker是使用一个构造函数（Worker()）创建的一个对象，这个构造函数需要传入一个的JavaScript文件，这个文件包含将在工作线程中运行的代码。类似于这样： 1let myWorker = new Worker(&apos;worker.js&apos;); 主线程和子线程的数据不是共享的，worker通过postMessage() 方法和onmessage事件进行数据通信。主线程和子线程是双向的，都可以发送和监听事件。向一个worker发送消息需要这样做（main.js）： 12345myWorker.postMessage(&apos;hello, world&apos;); // 发送worker.onmessage = function (event) &#123; // 接收 console.log(&apos;Received message &apos; + event.data); doSomething();&#125; postMessage所传的数据都是拷贝传递（ArrayBuffer类型除外），所以子线程也是类似传递（worker.js） 123addEventListener(&apos;message&apos;, function (e) &#123; postMessage(&apos;You said: &apos; + e.data);&#125;, false); 当子线程运行结束后，使用完毕，为了节省系统资源，可以手动关闭子线程。如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，它就会自动关闭。 123456789// 在主线程中关闭worker.terminate();// 在子线程里线程close();Worker也提供了错误处理机制，当出错时会触发error事件。// 监听 error 事件worker.addEventListener(&apos;error&apos;, function (e) &#123; console.log(&apos;ERROR&apos;, e);&#125;); web worker本身很简单，但是它的限制特别多。 使用的问题1、同源限制分配给Worker 线程运行的脚本文件（worker.js），必须与主线程的脚本文件(main.js)同源。这里的同源限制包括协议、域名和端口，不支持本地地址（file://）。这会带来一个问题，我们经常使用CDN来存储js文件，主线程的worker.js的域名指的是html文件所在的域，通过new Worker（url）加载的url属于CDN的域，会带来跨域的问题，实际开发中我们不会吧所有的代码都放在一个文件中让子线程加载，肯定会选择模块化开发。通过工具或库把代码合并到一个文件中，然后把子线程的代码生成一个文件url。解决方法：(1)将动态生成的脚本转换成Blob对象。(2)然后给这个Blob对象创建一个URL。(3)最后将这个创建好的URL作为地址传给Worker的构造函数。 1234let script = &apos;console.log(&quot;hello world!&quot;);&apos;let workerBlob = new Blob([script], &#123; type: &quot;text/javascript&quot; &#125;);let url = URL.createObjectURL(workerBlob);let worker = new Worker(url); 2、访问限制Worker子线程所在的全局对象，与主线程不在同一个上下文环境，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象，global对象的指向有变更，window需要改写成self，不能执行alert()方法和confirm()等方法，只能读取部分navigator对象内的数据。另外chrome的console.log()倒是可以使用，也支持debugger断点，增加调试的便利性。 3、使用异步Worker子线程中可以使用XMLHttpRequest 对象发出 AJAX 请求，可以使用setTimeout() setInterval()方法，也可使用websocket进行持续链接。也可以通过importScripts(url)加载另外的脚本文件，但是仍然不能跨域。 应用场景：1、使用专用线程进行数学运算Web Worke设计的初衷就是用来做计算耗时任务，大数据的处理，而这种计算放在worker中并不会中断前台用户的操作，避免代码卡顿带来不必要的用户体验。例如处理ajax返回的大批量数据，读取用户上传文件，计算MD5，canvas的位图的过滤，分析视频和声频文件等。worker中除了缺失了DOM和BOM操作能力以外，还是拥有非常强大的js逻辑运算处理的能力的，相当于nodejs一个级别的的运行环境。 2、高频的用户交互高频的用户交互适用于根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等类似场景，用户频繁输入的响应处理同样可以考虑放在web worker中执行。例如，我们可以 做一个像Word一样的应用：当用户打字时，后台立即在词典中进行查找，帮助用户自动纠错等等。 3、数据的预取对于一些有大量数据的前后台交互产品，可以新开一个线程专门用来进行数据的预取和缓冲数据，worker可以用在本地web数据库的行写入和更改，长时间持续的运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断，也有利于随时响应主线程的通信。也可以配合XMLHttpRequest和websocket进行不断开的通信，实现守卫进程。 兼容性 总体来说，兼容性还是不错的， 移动端可以放心使用，桌面端要求不高的话，也可以使用。 superWorker为了更方便快捷的使用web worker，我们封装了一个工具，可以通过模块化的方式编写运行在web worker中的脚本，避免同源策略，减少服务端发送一个额外的url请求，无需了解web worker，就像使用setTimeout一样，快速使用superWorker，提升你的编码效率和运行效率，它有以下优点：1、原生JS实现，无任何依赖库。2、简单快速，摈弃繁琐的创建文件、绑定事件，实现无侵入、无感知运行新线程的代码。3、返回Promise类型的数据，支持链式调用，清晰明了。4、支持多种方式新建worker，包括匿名函数、函数列表、文本文件、html片段、url、类，方便快捷。5、gzipped压缩后仅仅 1.2kb。 使用教程：123456import superWorker from &apos;superWorker&apos;let worker = superWorker(function (a, b) &#123; // 子线程中要运行的代码 return a + b;&#125;);worker.start(1, 2).then((r)=&gt;console.log(r)); // 3 用法 1superWorker（code， [type]） 参数 1code：运行的代码， type（非必须）：代码类型，目前支持0、1、2、3、4。 实现原理：先进行源代码转文件： 12let workerBlob = new Blob(code, &#123; type: &quot;text/javascript&quot; &#125;);let url = URL.createObjectURL(workerBlob); 对类型拆分，code参数支持传入匿名函数、函数列表、文本文件、url、HTML内嵌标签、类等功能，首先对传入的代码进行分类匹配，字符串化，然后进行拼接运行 1code = `($&#123;Function.prototype.toString.call(code)&#125;)($&#123;exportsObjName&#125;)`; 对于传入的方法，分别在主线程中的exports对象进行标记，和worker子线程中的exportsObjName对象中进行赋值。对于ES6 模块化的代码，进行过滤转译。 12345// 处理 \nexport default function xxx()&#123;&#125; =&gt; exports.default = true; exportsObjName.default = function xx()&#123;&#125;code = code.replace(/^(\s*)export\s+default\s+/m, (s, before) =&gt; &#123; exports.default = true; return `$&#123;before&#125;$&#123;exportsObjName&#125;.default=`;&#125;); 形成主线程exports和子线程exportsObjName中的方法进行一一对应。 worker主线程与主线程进行通讯则是仍然需要通过postMessage方法和onmessage回调事件来进行，这个我们统一进行了双向绑定，分别对主线程和子线程执行setup。 12345function setup(ctx, pmMethods, callbacks) &#123; ctx.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123; // …… &#125;)&#125; 在主线程中对worker封装了一些快捷的方法，比如关闭线程： 1234worker.terminate = () =&gt; &#123; URL.revokeObjectURL(url); term.call(this);&#125;; 并把子线程拥有的方法、属性，暴露出来，方便主线程通过传递参数调用。 12345worker.expose = methodName =&gt; &#123; worker[i] = function () &#123; return worker[&apos;call&apos;](methodName, [].slice.call(arguments)); &#125;;&#125;; 大致如下图： 欢迎小伙伴们使用以及批评指正。有问题多多反馈，多多交流。 小结对于web worker这项新技术，无论在PC还是在移动web，都很实用，腾讯新闻前端组进行了广泛的尝试，Web Worker 的实现为前端程序带来了后台计算的能力，实现了主 UI 线程与复杂计运算线程的分离，从而极大减轻了因计算量大而造成 UI 阻塞而出现的界面渲染卡、掉帧的情况，并且更大程度地利用了终端硬件的性能。superWorker能解决掉事件绑定，同源策略等繁琐的问题，它目前最大的问题在于不兼容IE9，在兼容性要求不是那么严格的地方，尽可能的使用吧！]]></content>
  </entry>
  <entry>
    <title><![CDATA[为啥程序员下班后只关显示器从不关电脑]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%B8%BA%E5%95%A5%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%8B%E7%8F%AD%E5%90%8E%E5%8F%AA%E5%85%B3%E6%98%BE%E7%A4%BA%E5%99%A8%E4%BB%8E%E4%B8%8D%E5%85%B3%E7%94%B5%E8%84%91%2F</url>
    <content type="text"><![CDATA[你下班时是不是只将显示器一关，揣上手机就走了？ 曾有安保人员晚上来办公室巡查时问，为什么这些人不关机就下班呢？ 作为程序员，你会心一笑。对方不明白如果关机了，第二天程序员上班可能会崩溃： 打开IDEA，并定位到昨天的代码，十分钟 打开Navicat，两分钟 打开笔记软件，一分钟 打开浏览器，找到昨天的历史记录，五分钟 打开Charles，三分钟 打开各种IM软件，五分钟 打开Xshell，连上，五分钟 打开邮箱，两分钟 …… 等一切工具准备就绪后，半个小时已经过去了。你知道程序员的时薪有多贵吗？ 对程序员来说，关机不仅意味着第二天需要开一堆软件浪费时间，更重要的是工作思路也随之断了，第二天重回昨天的思路也挺费劲的。 笔者分别采访了几个不同岗位的程序员，一起来探索程序员界的两大未解之谜： 为什么程序员下班从不关机？ 程序员多久才关一次机？ 1 Joker，运维工程师，上一次关机是前年 我不关机是因为太懒了。一般公司给程序员配置的电脑多数性能不会太高，服役时间较长，开机关机一次需要很长的时间。 从开机到打开各种软件，再进入工作状态，天知道要多久。再说了平常程序员的工作状态是有电话打过来说线上出问题了，赶紧处理一下。 时间紧急，光开机的时间就可以把问题解决了。时间就是金钱，所以我从来不关机。 曾经遇到一次故障，涉及核心业务级别比较高。我当时正开车回家，挂了电话后立即靠边停，打开电脑修复故障（老婆不在时，电脑坐副驾）。 消息群里我们几个人几乎同时响应正在处理。一分钟后，我修复好了，在群里周知大伙。 有同学说，“艾玛，我这才刚开机！” 呵呵，他竟然下班关机，不过那位同事现在即使送他钱也不敢下班关机。 至于什么时候才关机？我貌似从公司拿过笔记本后就没再关机过。不对，前年电脑升级时重启过一次，耽误不少事，之后再也没关过机了。 Joker电脑的任务栏 2 刘海，前端工程师，绝不关机 我从不关机是因为启动前端项目开发环境需要各种前置命令，很麻烦。 还有的是浏览器还打开着当时查到的解决方案呢，关机那不就丢了吗？其实关机最怕的是会丢了重要的东西，但是我忘了会丢什么，算了，对于前端来说，淡定才是主流。 多久关一次机？能不关机绝不关机，就像熬鹰一样，这里就是熬电脑，它啥时候扛不住了，就放它重启一次，做人不能太苛刻。 笔者：熬鹰……给跪了。 刘海电脑的任务栏 3 赵越，Java工程师，工作完成就关机 我不关机是因为今天的工作没有做完，电脑得留着思路现场。例如当时浏览器搜索资料页面、项目中类的位置、SQL语句等等，那样第二天来了，可以快速地接上前一天的思路。 有一回下班时我把没写完的SQL给关了，第二天上班后完全忘了前一天写到一半的思路了。毕竟程序员是属鱼的嘛。 如果下班时我的工作做完了，我还是会关机的。 笔者：对了，工作能做完吗？ 赵越电脑的任务栏 4 李奇，数据分析工程师，从不关机 我不关机是要保护现场，方便第二天能快速接上前一天的工作思路。平常打开了很多开发工具像IDEA这种不想关，毕竟上面都是程序员的操作痕迹，标志着上次工作进行到哪里了，上班时一开显示屏思路就可以无缝连接。 有的时候到了下班时间，但机子还在跑着数据呢，我不能在公司干等着。于是电脑开机运行，我到家后远程电脑看数据是否跑完了，等跑完了直接发给需求方。 有时候周末接到报警了，我就立刻远程公司的电脑解决。 我从来不关机，每次关机都是被迫关机：一次是公司停电了，一次是公司搬工位。 而且如果电脑关机了，心理上就是要把工作抛在脑后了。要过另一种生活，不关机就是工作一直在我心中。 笔者：此人单身。 5 任凯，测试工程师，一周关一次 我会在每周五下班时关机让它周末休息。我来公司时间长了，电脑老化但又懒得换，于是每次开机都是一个考验。要么机子起不来，要么重启后发现有软件不好用了，每次都要和电脑战斗半天。 以前曾试过重启电脑后起不来，把电脑送去给 IT维修，结果换了一台更烂的，安装了一天的软件都不好使。 通过采访得知，程序员是“不下班”一族。即使人下班回家了，但电脑不下班。下班不关机除了第二天能快速进入工作状态外，还便于程序员在非工作时间还在跑数据、快速解决突发故障、远程电脑解决问题等。 肩膀始终有责任的程序员们，给你们点赞。 ·END· 转自：https://www.cnblogs.com/gdjk/p/10468994.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[数组去重10种方法]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FJS%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D10%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1let originalArray = [1, '1', '1', 2, true, 'true', false, false, null, null, &#123;&#125;, &#123;&#125;, 'abc', 'abc', undefined, undefined, NaN, NaN]; 1、ES6 的 Set 对象1234567let resultArr = Array.from(new Set(originalArray));// 或者用扩展运算符let resultArr = [...new Set(originalArray)];console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN] 这是最简单快捷的去重方法，但是细心的同学会发现，这里的 {} 没有去重。可是又转念一想，2 个空对象的地址并不相同，所以这里并没有问题，结果 ok。 2、Map 的 has 方法123456789101112const resultArr = new Array();for (let i = 0; i &lt; originalArray.length; i++) &#123; // 没有该 key 值 if (!map.has(originalArray[i])) &#123; map.set(originalArray[i], true); resultArr.push(originalArray[i]); &#125;&#125;console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN] 但是它与 Set 的数据结构比较相似，结果 ok。 3、indexOf 和 includes建立一个新的空数组，遍历源数组，往这个空数组里塞值，每次 push 之前，先判断是否已有相同的值。 判断的方法有 2 个：indexOf 和 includes，但它们的结果之间有细微的差别。先看 indexOf。 12345678const resultArr = [];for (let i = 0; i &lt; originalArray.length; i++) &#123; if (resultArr.indexOf(originalArray[i]) &lt; 0) &#123; resultArr.push(originalArray[i]); &#125;&#125;console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN] indexOf 并不没处理 NaN。 再来看 includes，它是在 ES7 中正式提出的。 12345678const resultArr = [];for (let i = 0; i &lt; originalArray.length; i++) &#123; if (!resultArr.includes(originalArray[i])) &#123; resultArr.push(originalArray[i]); &#125;&#125;console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN] includes 处理了 NaN 4、sort先将原数组排序，生成新的数组，然后遍历排序后的数组，相邻的两两进行比较，如果不同则存入新数组。 1234567891011const sortedArr = originalArray.sort();const resultArr = [sortedArr[0]];for (let i = 1; i &lt; sortedArr.length; i++) &#123; if (sortedArr[i] !== resultArr[resultArr.length - 1]) &#123; resultArr.push(sortedArr[i]); &#125;&#125;console.log(resultArr);// [1, "1", 2, NaN, NaN, &#123;…&#125;, &#123;…&#125;, "abc", false, null, true, "true", undefined] 从结果可以看出，对源数组进行了排序。但同样的没有处理 NaN。 5、双层 for 循环 + splice双层循环，外层遍历源数组，内层从 i+1 开始遍历比较，相同时删除这个值。 123456789101112for (let i = 0; i &lt; originalArray.length; i++) &#123; for (let j = (i + 1); j &lt; originalArray.length; j++) &#123; // 第一个等于第二个，splice去掉第二个 if (originalArray[i] === originalArray[j]) &#123; originalArray.splice(j, 1); j--; &#125; &#125;&#125;console.log(originalArray);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN] splice 方法会修改源数组，所以这里我们并没有新开空数组去存储，最终输出的是修改之后的源数组。但同样的没有处理 NaN。 6、原始去重定义一个新数组，并存放原数组的第一个元素，然后将源数组一一和新数组的元素对比，若不同则存放在新数组中。 12345678910111213141516let resultArr = [originalArray[0]];for(var i = 1; i &lt; originalArray.length; i++)&#123; var repeat = false; for(var j=0; j &lt; resultArr.length; j++)&#123; if(originalArray[i] === resultArr[j])&#123; repeat = true; break; &#125; &#125; if(!repeat)&#123; resultArr.push(originalArray[i]); &#125;&#125;console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN] 这是最原始的去重方法，很好理解，但写法繁琐。同样的没有处理 NaN。 7、ES5 的 reducereduce 是 ES5 中方法，常用于值的累加。它的语法： 1arr.reduce(callback[, initialValue]) reduce 的第一个参数是一个 callback，callback 中的参数分别为： Accumulator(累加器)、currentValue(当前正在处理的元素)、currentIndex(当前正在处理的元素索引，可选)、array(调用 reduce 的数组，可选)。 reduce 的第二个参数，是作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。 利用 reduce 的特性，再结合之前的 includes(也可以用 indexOf)，就能得到新的去重方法： 123456const reducer = (acc, cur) =&gt; acc.includes(cur) ? acc : [...acc, cur];const resultArr = originalArray.reduce(reducer, []);console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN] 这里的 [] 就是初始值(initialValue)。acc 是累加器，在这里的作用是将没有重复的值塞入新数组（它一开始是空的）。 reduce 的写法很简单，但需要多加理解。它可以处理 NaN，结果 ok。 8、对象的属性每次取出原数组的元素，然后在对象中访问这个属性，如果存在就说明重复。 12345678910const resultArr = [];const obj = &#123;&#125;;for(let i = 0; i &lt; originalArray.length; i++)&#123; if(!obj[originalArray[i]])&#123; resultArr.push(originalArray[i]); obj[originalArray[i]] = 1; &#125;&#125;console.log(resultArr);// [1, 2, true, false, null, &#123;…&#125;, "abc", undefined, NaN] 但这种方法有缺陷。从结果看，它貌似只关心值，不关注类型。还把 {} 给处理了，但这不是正统的处理办法，所以 不推荐使用。 9、filter + hasOwnPropertyfilter 方法会返回一个新的数组，新数组中的元素，通过 hasOwnProperty 来检查是否为符合条件的元素。 1234567const obj = &#123;&#125;;const resultArr = originalArray.filter(function (item) &#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true);&#125;);console.log(resultArr);// [1, "1", 2, true, "true", false, null, &#123;…&#125;, "abc", undefined, NaN] 这 貌似 是目前看来最完美的解决方案了。这里稍加解释一下： hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。 typeof item + item 的写法，是为了保证值相同，但类型不同的元素被保留下来。例如：第一个元素为 number1，第二第三个元素都是 string1，所以第三个元素就被去除了。 obj[typeof item + item] = true 如果 hasOwnProperty 没有找到该属性，则往 obj 里塞键值对进去，以此作为下次循环的判断依据。 如果 hasOwnProperty 没有检测到重复的属性，则告诉 filter 方法可以先积攒着，最后一起输出。 看似 完美解决了我们源数组的去重问题，但在实际的开发中，一般不会给两个空对象给我们去重。所以稍加改变源数组，给两个空对象中加入键值对。 1let originalArray = [1, '1', '1', 2, true, 'true', false, false, null, null, &#123;a: 1&#125;, &#123;a: 2&#125;, 'abc', 'abc', undefined, undefined, NaN, NaN]; 然后再用 filter + hasOwnProperty 去重。 然而，结果竟然把 {a: 2} 给去除了！！！这就不对了。 所以，这种方法有点去重 过头 了，也是存在问题的。 10、lodash 中的 _.uniq灵机一动，让我想到了 lodash 的去重方法 _.uniq，那就尝试一把： 123console.log(_.uniq(originalArray));// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN] 用法很简单，可以在实际工作中正确处理去重问题。 然后，我在好奇心促使下，看了它的源码，指向了 baseUniq 文件，它的源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function baseUniq(array, iteratee, comparator) &#123; let index = -1 let includes = arrayIncludes let isCommon = true const &#123; length &#125; = array const result = [] let seen = result if (comparator) &#123; isCommon = false includes = arrayIncludesWith &#125; else if (length &gt;= LARGE_ARRAY_SIZE) &#123; const set = iteratee ? null : createSet(array) if (set) &#123; return setToArray(set) &#125; isCommon = false includes = cacheHas seen = new SetCache &#125; else &#123; seen = iteratee ? [] : result &#125; outer: while (++index &lt; length) &#123; let value = array[index] const computed = iteratee ? iteratee(value) : value value = (comparator || value !== 0) ? value : 0 if (isCommon &amp;&amp; computed === computed) &#123; let seenIndex = seen.length while (seenIndex--) &#123; if (seen[seenIndex] === computed) &#123; continue outer &#125; &#125; if (iteratee) &#123; seen.push(computed) &#125; result.push(value) &#125; else if (!includes(seen, computed, comparator)) &#123; if (seen !== result) &#123; seen.push(computed) &#125; result.push(value) &#125; &#125; return result&#125; 有比较多的干扰项，那是为了兼容另外两个方法，_.uniqBy 和 _.uniqWith。去除掉之后，就会更容易发现它是用 while 做了循环。当遇到相同的值得时候，continue outer 再次进入循环进行比较，将没有重复的值塞进 result 里，最终输出。 另外，_.uniqBy 方法可以通过指定 key，来专门去重对象列表。 12_.uniqBy([&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;, &#123; 'x': 1 &#125;], 'x');// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;] _.uniqWith 方法可以完全地给对象中所有的键值对，进行比较。 1234var objects = [&#123; 'x': 1, 'y': 2 &#125;, &#123; 'x': 2, 'y': 1 &#125;, &#123; 'x': 1, 'y': 2 &#125;];_.uniqWith(objects, _.isEqual);// =&gt; [&#123; 'x': 1, 'y': 2 &#125;, &#123; 'x': 2, 'y': 1 &#125;] 这两个方法，都还挺实用的。 总结从上述的这些方法来看，ES6 开始出现的方法（如 Set、Map、includes），都能完美地解决我们日常开发中的去重需求，关键它们还都是原生的，写法还更简单。 所以，我们提倡拥抱原生，因为它们真的没有那么难以理解，至少在这里我觉得它比 lodash 里 _.uniq 的源码要好理解得多，关键是还能解决问题。 摘录自：https://segmentfault.com/a/1190000018371055]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue组件之间8种组件通信方式总结]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fvue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[对于vue来说，组件之间的消息传递是非常重要的，下面是我对组件之间消息传递的各种方式的总结，总共有8种方式。 1.props和$emit父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Vue.component('child',&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, props:['message'],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit('getChildData',val) &#125; &#125; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'hello' &#125; &#125;, methods:&#123; //执行子组件触发的事件 getChildData(val)&#123; console.log(val) &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 在上面的例子中，有父组件parent和子组件child。1).父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；2).子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。 2. $attrs和$listeners第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Vue.component('C',&#123; template:` &lt;div&gt; &lt;input type="text" v-model="$attrs.messagec" @input="passCData($attrs.messagec)"&gt; &lt;/div&gt; `, methods:&#123; passCData(val)&#123; //触发父组件A中的事件 this.$emit('getCData',val) &#125; &#125; &#125;) Vue.component('B',&#123; data()&#123; return &#123; mymessage:this.message &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt; &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt; &lt;C v-bind="$attrs" v-on="$listeners"&gt;&lt;/C&gt; &lt;/div&gt; `, props:['message'],//得到父组件传递过来的数据 methods:&#123; passData(val)&#123; //触发父组件中的事件 this.$emit('getChildData',val) &#125; &#125; &#125;) Vue.component('A',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;B :messagec="messagec" :message="message" v-on:getCData="getCData" v-on:getChildData="getChildData(message)"&gt;&lt;/B&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'hello', messagec:'hello c' //传递给c组件的数据 &#125; &#125;, methods:&#123; getChildData(val)&#123; console.log('这是来自B组件的数据') &#125;, //执行C子组件触发的事件 getCData(val)&#123; console.log("这是来自C组件的数据："+val) &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;A&gt;&lt;/A&gt; &lt;/div&gt; ` &#125;) 3.中央事件总线上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Vue.component('brother1',&#123; data()&#123; return &#123; mymessage:'hello brother1' &#125; &#125;, template:` &lt;div&gt; &lt;p&gt;this is brother1 compoent!&lt;/p&gt; &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt; `, methods:&#123; passData(val)&#123; //触发全局事件globalEvent bus.$emit('globalEvent',val) &#125; &#125; &#125;) Vue.component('brother2',&#123; template:` &lt;div&gt; &lt;p&gt;this is brother2 compoent!&lt;/p&gt; &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt; &lt;/div&gt; `, data()&#123; return &#123; mymessage:'hello brother2', brothermessage:'' &#125; &#125;, mounted()&#123; //绑定全局事件globalEvent bus.$on('globalEvent',(val)=&gt;&#123; this.brothermessage=val; &#125;) &#125; &#125;) //中央事件总线 var bus=new Vue(); var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt; &lt;/div&gt; ` &#125;) 4.provide和inject父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。 123456789101112131415161718192021222324252627282930313233343536Vue.component('child',&#123; inject:['for'],//得到父组件传递过来的数据 data()&#123; return &#123; mymessage:this.for &#125; &#125;, template:` &lt;div&gt; &lt;input type="tet" v-model="mymessage"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, provide:&#123; for:'test' &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 5.v-model父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$emit('input',this.mymessage);//通过如此调用可以改变父组件上v-model绑定的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;child v-model="message"&gt;&lt;/child&gt; &lt;/div&gt; `, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 6.$parent和$children12345678910111213141516171819202122232425262728293031323334353637383940414243444546Vue.component('child',&#123; props:&#123; value:String, //v-model会自动传递一个字段为value的prop属性 &#125;, data()&#123; return &#123; mymessage:this.value &#125; &#125;, methods:&#123; changeValue()&#123; this.$parent.message = this.mymessage;//通过如此调用可以改变父组件的值 &#125; &#125;, template:` &lt;div&gt; &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; &lt;/div&gt; &#125;) Vue.component('parent',&#123; template:` &lt;div&gt; &lt;p&gt;this is parent compoent!&lt;/p&gt; &lt;button @click="changeChildValue"&gt;test&lt;/button &gt; &lt;child&gt;&lt;/child&gt; &lt;/div&gt; `, methods:&#123; changeChildValue()&#123; this.$children[0].mymessage = 'hello'; &#125; &#125;, data()&#123; return &#123; message:'hello' &#125; &#125; &#125;) var app=new Vue(&#123; el:'#app', template:` &lt;div&gt; &lt;parent&gt;&lt;/parent&gt; &lt;/div&gt; ` &#125;) 7.vuex处理组件之间的数据交互如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令清单]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。 Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 一、新建代码库 123456# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 1234567# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 123456789101112131415# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交 12345678910111213# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支 1234567891011121314151617181920212223242526272829# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签 123456789101112131415161718# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息 1234567891011121314151617181920212223242526272829303132333435363738394041# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步 12345678910111213141516# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销 12345678910111213141516171819202122# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他 12# 生成一个可供发布的压缩包$ git archive 转自：阮一峰(http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)]]></content>
  </entry>
  <entry>
    <title><![CDATA[40条常见的移动端Web页面问题解决方案]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F40%E6%9D%A1%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AFWeb%E9%A1%B5%E9%9D%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[1、安卓浏览器看背景图片，有些设备会模糊。 用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？ 经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。 想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100100，背景图必须得200200，然后background-size:contain;，这样显示出来的图片就比较清晰了。 代码如下： 123456background: url(../images/icon/all.png) no-repeat center center;-webkit-background-size: 50px 50px;background-size: 50px 50px;display: inline-block;width: 100%;height: 50px; 或者指定 background-size:contain;都可以，大家试试！ 2、图片加载 若您遇到图片加载很慢的问题，对这种情况，手机开发一般用canvas方法加载： 具体的canvas API 参见：http://javascript.ruanyifeng.com/htmlapi/canvas.html 下面举例说明一个canvas的例子： 1&lt;li&gt;&lt;canvas&gt;&lt;/canvas&gt;&lt;/li&gt; js动态加载图片和li 总共举例17张图片！ 1234567891011121314151617181920212223242526var total = 17;var zWin = $(window);var render = function () &#123; var padding = 2; var winWidth = zWin.width(); var picWidth = Math.floor((winWidth - padding * 3) / 4); var tmpl = ''; for (var i = 1; i &lt;= totla; i++) &#123; var p = padding; var imgSrc = 'img/' + i + '.jpg'; if (i % 4 == 1) &#123; p = 0; &#125; tmpl += '&lt;li style="width:' + picWidth + 'px;height:' + picWidth + 'px;padding-left:' + p + 'px;padding-top:' + padding + 'px;"&gt;&lt;canvas id="cvs_' + i + '"&gt;&lt;/canvas&gt;&lt;/li&gt;'; var imageObj = new Image(); imageObj.index = i; imageObj.onload = function () &#123; var cvs = $('#cvs_' + this.index)[0].getContext('2d'); cvs.width = this.width; cvs.height = this.height; cvs.drawImage(this, 0, 0); &#125; imageObj.src = imgSrc; &#125;&#125;render(); 3、假如手机网站不用兼容IE浏览器，一般我们会使用zeptojs。 zeptojs内置Touch events方法，具体可以看http://zeptojs.com/#Touch events 看了一下zeptio新版的API，已经支持IE10以上浏览器，对zeptojs可以选择使用！ 4、防止手机中网页放大和缩小。 这点是最基本的，最为手机网站开发者来说应该都知道的，就是设置meta中的viewport 还有就是，有些手机网站我们看到如下声明： 1&lt;!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd"&gt; 设置了DTD的方式是XHTML的写法，假如我们页面运用的是html5，可以不用设置DTD,直接声明。 使用viewport使页面禁止缩放。 通常把user-scalable设置为0来关闭用户对页面视图缩放的行为 1&lt;meta name="viewport" content="user-scalable=0" /&gt; 但是为了更好的兼容，我们会使用完整的viewport设置。 1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" /&gt; 当然，user-scalable=0,有的人也写成user-scalable=no，都可以的。 5、apple-mobile-web-app-capable apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。 语法： 1&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; 说明： 如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示。你可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。 6、format-detection format-detection 启动或禁用自动识别页面中的电话号码。 语法： 1&lt;meta name="format-detection" content="telephone=no"&gt; 说明： 默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能。 7、html5调用安卓或者ios的拨号功能 html5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。 如下： 1&lt;a href="tel:10010"&gt;10010&lt;/a&gt; 8、html5GPS定位功能 具体请看：http://www.w3school.com.cn/html5/html_5_geolocation.asp 9、上下拉动滚动条时卡顿、慢 1234body &#123; -webkit-overflow-scrolling: touch; overflow-scrolling: touch; &#125; 10、禁止复制、选中文本 123456Element &#123; -webkit-user-select: none; -moz-user-select: none; -khtml-user-select: none; user-select: none; &#125; 解决移动设备可选中页面文本(视产品需要而定) 11、长时间按住页面出现闪退 1element &#123; -webkit-touch-callout: none;&#125; 12、iphone及ipad下输入框默认内阴影 1Element&#123; -webkit-appearance: none; &#125; 13、ios和android下触摸元素时出现半透明灰色遮罩 1Element &#123; -webkit-tap-highlight-color:rgba(255,255,255,0)&#125; 14、active兼容处理 即 伪类 :active 失效 方法一：body添加ontouchstart 1&lt;body ontouchstart=&quot;&quot;&gt; 方法二：js给 document 绑定 touchstart 或 touchend 事件 12345678910111213141516&lt;style&gt;a &#123; color: #000;&#125;a:active &#123; color: #fff;&#125;&lt;/style&gt;&lt;a herf=foo&gt;bar&lt;/a&gt;&lt;script&gt; document.addEventListener('touchstart', function () &#123; &#125;, false);&lt;/script&gt; 15、动画定义3D启用硬件加速 1234Element &#123; -webkit-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 16、Retina屏的1px边框 具体请百度谷歌关键字，解决方案有很多 17、webkit mask 兼容处理 某些低端手机不支持css3 mask，可以选择性的降级处理。 比如可以使用js判断来引用不同class： 12345if ('WebkitMask' in document.documentElement.style) &#123; alert('支持mask');&#125; else &#123; alert('不支持mask');&#125; 18、旋转屏幕时，字体大小调整的问题 123html, body, form, fieldset, p, div, h1, h2, h3, h4, h5, h6 &#123; -webkit-text-size-adjust: 100%;&#125; 19、transition闪屏 123456ele &#123; /*设置内嵌的元素在 3D 空间如何呈现：保留3D */ -webkit-transform-style: preserve-3d; /* 设置进行转换的元素的背面在面对用户时是否可见：隐藏 */ -webkit-backface-visibility: hidden;&#125; 20、圆角bug 某些Android手机圆角失效 123ele &#123; background-clip: padding-box;&#125; 21、顶部状态栏背景色 1&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; 说明： 除非你先使用apple-mobile-web-app-capable指定全屏模式，否则这个meta标签不会起任何作用。 如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank-translucent，则状态栏显示为黑色半透明。 如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。 如果设置为blank-translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。 默认值是default。 22、设置缓存 1&lt;meta http-equiv="Cache-Control" content="no-cache" /&gt; 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 23、桌面图标 1234&lt;link rel="apple-touch-icon" href="touch-icon-iphone.png"/&gt;&lt;link rel="apple-touch-icon" sizes="76x76" href="touch-icon-ipad.png"/&gt;&lt;link rel="apple-touch-icon" sizes="120x120" href="touch-icon-iphone-retina.png"/&gt;&lt;link rel="apple-touch-icon" sizes="152x152" href="touch-icon-ipad-retina.png"/&gt; iOS下针对不同设备定义不同的桌面图标。如果不定义则以当前屏幕截图作为图标。 上面的写法可能大家会觉得会有默认光泽，下面这种设置方法可以去掉光泽效果，还原设计图的效果！ 1&lt;link rel="apple-touch-icon-precomposed" href="touch-icon-iphone.png" /&gt; 图片尺寸可以设定为5757（px）或者Retina可以定为114114（px），ipad尺寸为72*72（px) 24、启动画面 1&lt;link rel="apple-touch-startup-image" href="start.png"/&gt; iOS下页面启动加载时显示的画面图片，避免加载时的白屏。 可以通过madia来指定不同的大小： 1&lt;!--iPhone--&gt;&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt;&lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt; 25、浏览器私有及其它meta 以下属性在项目中没有应用过，可以写一个demo测试以下！ 123456789101112131415161718&lt;!-- QQ浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name="x5-fullscreen" content="true"&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name="x5-orientation" content="portrait"&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name="x5-orientation" content="landscape"&gt;&lt;!-- 应用模式 --&gt;&lt;meta name="x5-page-mode" content="app"&gt; &lt;!-- UC浏览器私有 --&gt;&lt;!-- 全屏模式 --&gt;&lt;meta name="full-screen" content="yes"&gt;&lt;!-- 强制竖屏 --&gt;&lt;meta name="screen-orientation" content="portrait"&gt;&lt;!-- 强制横屏 --&gt;&lt;meta name="screen-orientation" content="landscape"&gt;&lt;!-- 应用模式 --&gt;&lt;meta name="browsermode" content="application"&gt; 其它,针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 1&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt; 微软的老式浏览器 1&lt;meta name="MobileOptimized" content="320"&gt; windows phone 点击无高光 1&lt;meta name="msapplication-tap-highlight" content="no"&gt; 26、 IOS中input键盘事件keyup、keydown、keypress支持不是很好 问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。 用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才能相应！ 解决办法： 可以用html5的oninput事件去代替keyup 123456&lt;input type="text" id="testInput"&gt;&lt;script type="text/javascript"&gt; document.getElementById('testInput').addEventListener('input', function (e) &#123; var value = e.target.value; &#125;);&lt;/script&gt; 然后就达到类似keyup的效果！ 27、h5网站input 设置为type=number的问题 h5网页input 的type设置为number一般会产生三个问题，一个问题是maxlength属性不好用了。另外一个是form提交的时候，默认给取整了。三是部分安卓手机出现样式问题。 问题一解决，我目前用的是js。如下 12345678&lt;input type="number" oninput="checkTextLength(this ,10)"&gt;&lt;script&gt; function checkTextLength(obj, length) &#123; if (obj.value.length &gt; length) &#123; obj.value = obj.value.substr(0, length); &#125; &#125;&lt;/script&gt; 问题二，是因为form提交默认做了表单验证，step默认是1,要设置step属性，假如保留2位小数，写法如下： 1&lt;input type="number" step="0.01" /&gt; 关于step，我在这里做简单的介绍，input 中type=number，一般会自动生成一个上下箭头，点击上箭头默认增加一个step，点击下箭头默认会减少一个step。number中默认step是1。也就是step=0.01,可以允许输入2位小数，并且点击上下箭头分别增加0.01和减少0.01。 假如step和min一起使用，那么数值必须在min和max之间。 看下面的例子： 1&lt;input type="number" step="3.1" min="1" /&gt; 输入框可以输入哪些数字？ 首先，最小值是1，那么可以输入1.0，第二个是可以输入（1+3.1）那就是4.1,以此类推，每次点击上下箭头都会增加或者减少3.1，输入其他数字无效。这就是step的简单介绍。 问题三，去除input默认样式 12345678input[type=number] &#123; -moz-appearance: textfield;&#125;input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; margin: 0;&#125; 28、ios 设置input 按钮样式会被默认样式覆盖 解决方式如下： 1234input,textarea &#123; border: 0; -webkit-appearance: none; &#125; 设置默认样式为none 29、IOS键盘字母输入，默认首字母大写 解决方案，设置如下属性 1&lt;input type="text" autocapitalize="off" /&gt; 30、select 下拉选择设置右对齐 设置如下： 1select option &#123;direction: rtl;&#125; 31、通过transform进行skew变形，rotate旋转会造成出现锯齿现象 可以设置如下： 123-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); transform: rotate(-4deg) skew(10deg) translateZ(0); outline: 1px solid rgba(255,255,255,0); 32、移动端点击300ms延迟 300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。 推荐两个js，一个是fastclick，一个是tap.js 关于300ms延迟，具体请看：http://thx.github.io/mobile/300ms-click-delay/ 33、移动端点透问题 案例如下： 1&lt;div id="haorooms"&gt;点头事件测试&lt;/div&gt;&lt;a href="#"&gt;www.xxx.com&lt;/a&gt; div是绝对定位的蒙层,并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件： 123$('#haorooms').on('tap', function () &#123; $('#haorooms').hide();&#125;); 我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。 原因： touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。 解决： （1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。（2）用fastclick，https://github.com/ftlabs/fastclick（3）用preventDefault阻止a标签的click（4）延迟一定的时间(300ms+)来处理事件 （不推荐）（5）以上一般都能解决，实在不行就换成click事件。 下面介绍一下touchend事件，如下： 123$("#haorooms").on("touchend", function (event) &#123; event.preventDefault();&#125;); 34、消除 IE10 里面的那个叉号 1input:-ms-clear&#123;display:none;&#125; 35、关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等) iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。 123-webkit-text-size-adjust: 100%;-ms-text-size-adjust: 100%;text-size-adjust: 100%; 36、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格 可以通过正则去掉 1this.value = this.value.replace(/\u2006/g, ''); 37、移动端 HTML5 audio autoplay 失效问题 这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。 解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。 解决代码： 1234document.addEventListener('touchstart', function () &#123; document.getElementsByTagName('audio')[0].play(); document.getElementsByTagName('audio')[0].pause();&#125;); 38、移动端 HTML5 input date 不支持 placeholder 问题 这个我感觉没有什么好的解决方案，用如下方法 1&lt;input placeholder="Date" class="textbox-n" type="text" onfocus="(this.type='date')" id="date"&gt; 有的浏览器可能要点击两遍！ 39、部分机型存在type为search的input，自带close按钮样式修改方法 有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为 1#Search::-webkit-search-cancel-button&#123; display: none; &#125; 如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。 40、唤起select的option展开 zepto方式: 1$(sltElement).trrgger("mousedown"); 原生js方式: 123456function showDropdown(sltElement) &#123; var event; event = document.createEvent('MouseEvents'); event.initMouseEvent('mousedown', true, true, window); sltElement.dispatchEvent(event);&#125;;]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用IntersectionObserve-API轻松实现惰性加载和无限滚动]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%88%A9%E7%94%A8IntersectionObserve-API%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0%E6%83%B0%E6%80%A7%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[网页开发时，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。 上图的绿色方块不断滚动，顶部会提示它的可见性。传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 一、API它的用法非常简单。 1var io = new IntersectionObserver(callback, option); 上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。 123456// 开始观察io.observe(document.getElementById('example')); // 停止观察io.unobserve(element); // 关闭观察器io.disconnect(); 上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。 12io.observe(elementA);io.observe(elementB); 二、callback 参数目标元素的可见性变化时，就会调用观察器的回调函数callback。callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。 123var io = new IntersectionObserver(entries =&gt; &#123; console.log(entries); &#125;); 上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。 三、IntersectionObserverEntry 对象IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。 1234567891011121314151617181920&#123; time: 3893.92, rootBounds: ClientRect &#123; bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // ... &#125;, intersectionRect: ClientRect &#123; // ... &#125;, intersectionRatio: 0.54, target: element&#125; 每个属性的含义如下。 123456time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒target：被观察的目标元素，是一个 DOM 节点对象rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回nullboundingClientRect：目标元素的矩形区域的信息intersectionRect：目标元素与视口（或根元素）的交叉区域的信息intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0 上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的intersectionRatio图中都已经注明。我写了一个 Demo[http://jsbin.com/canuze/edit?js,console,output]，演示IntersectionObserverEntry对象。**注意，这个 Demo 只能在 Chrome 51+ 运行**。 四、实例：惰性加载（lazy load）有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。有了 IntersectionObserver API，实现起来就很容易了。 123456789101112131415161718function query(selector) &#123; return Array.from(document.querySelectorAll(selector));&#125; var observer = new IntersectionObserver( function(changes) &#123; changes.forEach(function(change) &#123; var container = change.target; var content = container.querySelector('template').content; container.appendChild(content); observer.unobserve(container); &#125;); &#125;); query('.lazy-loaded').forEach(function (item) &#123; observer.observe(item);&#125;); 上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。 五、实例：无限滚动无限滚动（infinite scroll）的实现也很简单。 123456789101112var intersectionObserver = new IntersectionObserver( function (entries) &#123; // 如果不可见，就返回 if (entries[0].intersectionRatio &lt;= 0) return; loadItems(10); console.log('Loaded new items'); &#125;); // 开始观察intersectionObserver.observe( document.querySelector('.scrollerFooter')); 无限滚动时，最好在页面底部有一个页尾栏（又称sentinels）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用observe()方法，现有的IntersectionObserver可以保持使用。 六、Option 对象IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。 6.1 threshold 属性threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。 123456new IntersectionObserver( entries =&gt; &#123;/* ... */&#125;, &#123; threshold: [0, 0.25, 0.5, 0.75, 1] &#125;); 用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 6.2 root 属性，rootMargin 属性很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。 123456789var opts = &#123; root: document.querySelector('.container'), rootMargin: "500px 0px" &#125;; var observer = new IntersectionObserver( callback, opts); 上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。 七、注意点IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。 八、参考链接IntersectionObserver’s Coming into View[https://developers.google.com/web/updates/2016/04/intersectionobserver]Intersection Observers Explained[https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md] 转自：http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript排序,冒泡,选择,插入,归并]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FJavaScript%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1-%E9%80%89%E6%8B%A9-%E6%8F%92%E5%85%A5-%E5%BD%92%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[不过说到排序，最容易想到的就是冒泡排序，选择排序，插入排序了。 冒泡排序 依次比较相邻的两个元素，如果后一个小于前一个，则交换，这样从头到尾一次，就将最大的放到了末尾。 从头到尾再来一次，由于每进行一轮，最后的都已经是最大的了，因此后一轮需要比较次数可以比上一次少一个。虽然你还是可以让他从头到尾来比较，但是后面的比较是没有意义的无用功，为了效率，你应该对代码进行优化。 图片演示如下 代码实现： 12345678910111213function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; for (var j = 0; j &lt; len - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; // 相邻元素两两对比 var temp = arr[j + 1]; // 元素交换 arr[j + 1] = arr[j]; arr[j] = temp &#125; &#125; &#125; return arr&#125; 选择排序 选择排序我觉得是最简单的了，大一学VB的时候，就只记住了这个排序方法，原理非常简单：每次都找一个最大或者最小的排在开始即可。 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。动图演示： 代码演示： 12345678910111213141516function selectionSort(arr) &#123; var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) &#123; minIndex = i; for (var j = i + 1; j &lt; len; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; // 寻找最小的数 minIndex = j; // 将最小数的索引保存 &#125; &#125; temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 插入排序 插入排序也比较简单。就像打扑克一样，依次将拿到的元素插入到正确的位置即可。 1.将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。2.从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动图演示： 代码示例： 1234567891011121314function insertionSort(arr) &#123; var len = arr.length; var preIndex, current; for (var i = 1; i &lt; len; i++) &#123; preIndex = i - 1; current = arr[i]; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) &#123; arr[preIndex + 1] = arr[preIndex]; preIndex-- &#125; arr[preIndex + 1] = current &#125; return arr&#125; 简单的代价是低效 上面三种都是非常简单的排序方法，简单的同时呢，效率也会比较低，还是拿这本书里的对比图来说明： 时间复杂度都高达O(n^2),而它们后面的一些排序算法时间复杂度基本都只有O(n log n)。 我的强迫症又犯了，我想要高效率一点的排序方法。 归并排序 简单把这本书的内容过了一遍，当时就理解了这个归并排序，因此这里就谈一下这个归并排序吧。 基本原理是分治法，就是分开并且递归来排序。 步骤如下： 1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；4.重复步骤 3 直到某一指针达到序列尾；5.将另一序列剩下的所有元素直接复制到合并序列尾。 动图演示： 代码示例： 1234567891011121314151617181920212223function mergeSort(arr) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return merge(mergeSort(left), mergeSort(right))&#125;function merge(left, right) &#123; var result = []; while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result&#125; 既然是个爱折腾的人，折腾了总得看看效果吧。 效率测试 由于我学这个来进行排序不是对简单数组，数组内都是对象，要对对象的某个属性进行排序，还要考虑升降序。 因此我的代码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * [归并排序] * @param &#123;[Array]&#125; arr [要排序的数组] * @param &#123;[String]&#125; prop [排序字段，用于数组成员是对象时，按照其某个属性进行排序，简单数组直接排序忽略此参数] * @param &#123;[String]&#125; order [排序方式 省略或asc为升序 否则降序] * @return &#123;[Array]&#125; [排序后数组，新数组，并非在原数组上的修改] */var mergeSort = (function() &#123; // 合并 var _merge = function(left, right, prop) &#123; var result = []; // 对数组内成员的某个属性排序 if (prop) &#123; while (left.length &amp;&amp; right.length) &#123; if (left[0][prop] &lt;= right[0][prop]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; &#125; else &#123; // 数组成员直接排序 while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()); &#125; else &#123; result.push(right.shift()); &#125; &#125; &#125; while (left.length) result.push(left.shift()); while (right.length) result.push(right.shift()); return result; &#125;; var _mergeSort = function(arr, prop) &#123; // 采用自上而下的递归方法 var len = arr.length; if (len &lt; 2) &#123; return arr; &#125; var middle = Math.floor(len / 2), left = arr.slice(0, middle), right = arr.slice(middle); return _merge(_mergeSort(left, prop), _mergeSort(right, prop), prop); &#125;; return function(arr, prop, order) &#123; var result = _mergeSort(arr, prop); if (!order || order.toLowerCase() === 'asc') &#123; // 升序 return result; &#125; else &#123; // 降序 var _ = []; result.forEach(function(item) &#123; _.unshift(item); &#125;); return _; &#125; &#125;;&#125;)(); 需要对哪个属性进行排序是不确定，可以随意指定，因此写成了参数。有由于不想让这些东西在每次循环都进行判断，因此代码有点冗余。 关于降序的问题，也没有加入参数中，而是简单的升序后再逆序输出。原因是不想让每次循环递归里都去判断条件，所以简单处理了。 下面就是见证效率的时候了，一段数据模拟： 12345678var getData = function() &#123; return Mock.mock(&#123; "list|1000": [&#123; name: '@cname', age: '@integer(0,500)' &#125;] &#125;).list&#125;; 上面使用Mock进行了模拟数据，关于Mock ： http://mockjs.com/ 实际测试来啦： 1234567891011121314151617// 效率测试var arr = getData();console.time('归并排序');mergeSort(arr, 'age');console.timeEnd('归并排序');console.time('冒泡排序');for (var i = 0, l = arr.length; i &lt; l - 1; ++i) &#123; var temp; for (var j = 0; j &lt; l - i - 1; ++j) &#123; if (arr[j].age &gt; arr[j + 1].age) &#123; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125;&#125;console.timeEnd('冒泡排序'); 进行了五次，效果如下： 1234567891011121314// 归并排序: 6.592ms// 冒泡排序: 25.959ms// 归并排序: 1.334ms// 冒泡排序: 20.078ms// 归并排序: 1.085ms// 冒泡排序: 16.420ms// 归并排序: 1.200ms// 冒泡排序: 16.574ms// 归并排序: 2.593ms// 冒泡排序: 12.653ms 最低4倍，最高近16倍的效率之差还是比较满意的。 虽然1000条数据让前端排序的可能性不大，但是几十上百条的情况还是有的。另外由于node，JavaScript也能运行的服务端了，这个效率的提升也还是有用武之地的。 一点疑问 归并排序里面使用了递归，在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为： However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. 然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。gitbook上这本书的作者对此有疑问，我也有疑问。 归并中虽然用了递归，但是他是放在return后的呀。关于在renturn后的递归是有尾递归优化的呀。 关于尾递归优化是指：本来外层函数内部再调用一个函数的话，由于外层函数需要等待内层函数返回后才能返回结果，进入内层函数后，外层函数的信息，内存中是必须记住的，也就是调用堆栈。而内部函数放在return关键字后，就表示外层函数到此也就结束了，进入内层函数后，没有必要再记住外层函数内的所有信息。 上面是我的理解的描述，不知道算不算准确。chrome下已经可以开启尾递归优化的功能了，我觉得这个递归是不该影响他在JavaScript下的使用的。 最后 有兴趣的话，推荐读读这本书，进行排序的时候，可以考虑一些更高效的方法。 不过需要注意的是，这些高效率的排序方法，一般都需要相对较多的额外内存空间，需要权衡一下。 另外，非常小规模的数据就没有必要了。一是影响太小，而是我们人的效率问题，一分钟能从头写个冒泡、选择、插入的排序方法，而换成是归并排序呢？]]></content>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享CORS详解]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 本文详细介绍CORS的内部机制。 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： 123HEADGETPOST （2）HTTP的头信息不超出以下几种字段： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 三、简单请求3.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 3.2 withCredentials 属性 上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 四、非简单请求4.1 预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 4.2 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他CORS相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 4.3 浏览器的正常请求和回应一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常CORS请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 五、与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 （完） 转自：阮一峰的网络日志（http://www.ruanyifeng.com/blog/2016/04/cors.html）]]></content>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中几种实用的跨域方法]]></title>
    <url>%2F2019%2F03%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FJavaScript%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%94%A8%E7%9A%84%E8%B7%A8%E5%9F%9F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这里说的js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。 要解决跨域的问题，我们可以使用以下几种方法： 1、通过jsonp跨域 script标签是不受同源策略影响的，它可以引入来自任何地方的js文件。而jsonp的原理就是，在客户端和服务端定义一个函数，当客户端发起一个请求时，服务端返回一段javascript代码，其中调用了在客户端定义的函数，并将相应的数据作为参数传入该函数。 服务端获取到jsonp_callback传递的函数名jsonp_cb，返回一段对该函数调用的js代码 12345678910111213function jsonp_cb(data) &#123; console.log(data);&#125;function ajax() &#123; var url = "http://xx.com/test.php?jsonp_callback=jsonp_cb"; var script = document.createElement('script'); // 发送请求 script.src = url; document.head.appendChild(script);&#125;ajax() 2、img ping img标签也是没有跨域限制的，但它只能用来发送GET请求，且无法获取服务端的响应文本，可以利用它实现一些简单的、单向的跨域通信，例如跟踪用户的点击 1234567var img = new Image();img.onload = function () &#123; console.log('done') img.onload = null; img = null;&#125;img.src = "http://xx/xx.gif" 3、使用window.name来进行跨域 window对象拥有name属性，它有一个特点：相同协议下，在一个页面中，不随URL的改变而改变示例代码 1window.name = 'string' // 字符串，一般允许的最大值为2Mconsole.log(window.name)location = 'http://funteas.com/' 此时，在控制台输入window.name，结果依然是”string” 1window.name // "string" window.name的值只能是字符串，任何其他类型的值都会“转化”为字符串例如 12window.name = function()&#123;&#125;console.log(window.name)// "function()&#123;&#125;" 通过window.name实现跨域也很简单，iframe拥有contentWindow属性，其指向该iframe的window对象的引用，如果在iframe的src指向的页面中设置window.name值，那么就可以通过iframe.contentWindow.name就可以拿到这个值了 1234567var url = "http://funteas.com/lab/windowName";var iframe = document.createElement('iframe')iframe.onload = function()&#123; var data = iframe.contentWindow.name console.log(data)&#125;iframe.src = urldocument.body.appendChild(iframe) 然而，chrome会提示你跨域了！而我们已经知道window.name不随URL的改变而改版，也就是说，onload时，已经获取到了name，只不过因为不同源，当前页面的脚本无法拿到iframe.contentWindow.name，此时只需要把iframe.src改为同源即可 12345678var url = "http://funteas.com/lab/windowName";var iframe = document.createElement('iframe')iframe.onload = function()&#123; iframe.src = 'favicon.ico'; var data = iframe.contentWindow.name console.log(data)&#125;iframe.src = urldocument.body.appendChild(iframe) 刷新页面，你会发现iframe不断刷新，这是因为每次onload，iframe的src被修改，然后再次触发onload，从而导致iframe循环刷新，修改下即可 12345678910111213var url = "http://funteas.com/lab/windowName";var iframe = document.createElement('iframe')var state = true;iframe.onload = function()&#123; if(state === true)&#123; iframe.src = 'favicon.ico'; state = false; &#125;else if(state === false)&#123; state = null var data = iframe.contentWindow.name console.log(data) &#125;&#125;iframe.src = urldocument.body.appendChild(iframe) 上面请求的是一个静态页面，而服务端通常需要的是动态数据 1echo '&lt;script&gt; window.name = "&#123;\"name\":\"story\"&#125;"&lt;/script&gt;'; 4、使用HTML5中新引进的window.postMessage方法来跨域传送数据 postMessage允许不同源之间的脚本进行通信，用法 1otherWindow.postMessage(message, targetOrigin); otherWindow 引用窗口 iframe.contentwindow 或 window.open返回的对象 message 为要传递的数据 targetOrigin 为目标源 123456789101112131415161718192021222324252627// http://127.0.0.1:80var iframe = document.createElement('iframe')iframe.onload = function () &#123; var popup = iframe.contentWindow popup.postMessage("hello", "http://127.0.0.1:5000");&#125;iframe.src = 'http://127.0.0.1:5000/lab/postMessage'document.body.appendChild(iframe)// 监听返回的postMessagewindow.addEventListener("message", function (event) &#123; if (event.origin !== "http://127.0.0.1:5000") return console.log(event.data)&#125;, false)// http://127.0.0.1:5000/lab/postMessagewindow.addEventListener("message", function (event) &#123; // 验证消息来源 if (event.origin !== "http://127.0.0.1") return console.log(event.source); // 消息源 popup console.log(event.origin); // 消息源URI https://secure.example.net console.log(event.data); // 来自消息源的数据 hello // 返回数据 var message = 'world'; event.source.postMessage(message, event.origin);&#125;, false); 5、CORS CORS（跨域资源共享）是一种跨域访问的机制，可以让AJAX实现跨域访问。它允许一个域上的脚本向另一个域提交跨域 AJAX 请求。实现此功能非常简单，只需由服务器发送一个响应标头即可。 1Access-Control-Allow-Origin: * // 允许来自任何域的请求Access-Control-Allow-Origin: http://funteas.com/ // 仅允许来自http://funteas.com/的请求 当客户端的ajax请求的url为其他域时，对于支持CORS的浏览器，请求头会自动添加Origin，值为当前host 123var xhr = new XMLHttpRequest();var url = 'http://bar.other/resources/public-data/';xhr.open('GET', url, true);xhr.send(); CORS默认不发送cookie，如果要发送cookie，需要设置withCredentials 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 同时，服务端也要设置 1Access-Control-Allow-Credentials: true 查看MDN关于CORS的介绍]]></content>
  </entry>
  <entry>
    <title><![CDATA[你敢在post和get上刁难我，就别怪我装逼了]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BD%A0%E6%95%A2%E5%9C%A8post%E5%92%8Cget%E4%B8%8A%E5%88%81%E9%9A%BE%E6%88%91%EF%BC%8C%E5%B0%B1%E5%88%AB%E6%80%AA%E6%88%91%E8%A3%85%E9%80%BC%E4%BA%86%2F</url>
    <content type="text"><![CDATA[之前好几次面试都被问到post和get有什么区别，肯定很多同学和我一样说了一大堆什么post比get安全，get比post传的少乱起八糟这样的答案，但是面试官就还是不停的问你，还有呢还有呢？当时我就火了还有啥？回来之后上网搜来来回回就那么几个答案，今天被我找到了正确的答案，今天分享给大家。 GET和POST是HTTP请求的两种基本方法，要说它们的区别，接触过WEB开发的人都能说出一二。 最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。 你可能自己写过无数个GET和POST请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。 当你在面试中被问到这个问题，你的内心充满了自信和喜悦。 你轻轻松松的给出了一个“标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 “很遗憾，这不是我们要的回答!” 请告诉我真相。。。 如果我告诉你GET和POST本质上没有区别你信吗? 让我们扒下GET和POST的外衣，坦诚相见吧! GET和POST是什么?HTTP协议中的两种发送请求的方法。 HTTP是什么?HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。 HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。 那么，“标准答案”里的那些区别是怎么回事? 在我大万维网世界中，TCP就像汽车，我们用TCP来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则HTTP诞生了。HTTP给汽车运输设定了好几个服务类别，有GET, POST, PUT, DELETE等等，HTTP规定，当执行GET请求的时候，要给汽车贴上GET的标签(设置method为GET)，而且要求把传送的数据放在车顶上(url中)以方便记录。如果是POST请求，就要在车上贴上POST的标签，并把货物放在车厢里。当然，你也可以在GET的时候往车厢内偷偷藏点货物，但是这是很不光彩;也可以在POST的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP只是个行为准则，而TCP才是GET和POST怎么实现的基本。 但是，我们只看到HTTP对GET和POST参数的传送渠道(url还是requrest body)提出了要求。“标准答案”里关于参数大小的限制又是从哪来的呢? 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器(发起http请求)和服务器(接受http请求)就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物(url中无限加参数)。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，(大多数)浏览器通常都会限制url长度在2K个字节，而(大多数)服务器最多处理64K大小的url。超过的部分，恕不处理。如果你用GET服务，在request body偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然GET可以带request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了? 我们的大BOSS还等着出场呢。。。 这位BOSS有多神秘?当你试图在网上找“GET和POST的区别”的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET和POST还有一个重大区别，简单的说： GET产生一个TCP数据包;POST产生两个TCP数据包。 长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑!跳入需谨慎。为什么? GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你“GET与POST的区别”的时候，你的内心是不是这样的?]]></content>
  </entry>
  <entry>
    <title><![CDATA[chrome模拟微信浏览器环境]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fchrome%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[User Agent 是用户浏览器内的一串字符，它描述了这个浏览器是那款浏览器、用户用的是哪个操作系统等等的一些属性。网页可以获取它来提供针对性的服务，当然，也可以被腾讯用来阻止你的访问。 我用的是 Chrome，其他浏览器也大同小异。在你打开那个网页链接，打开开发者工具， 然后按 ctrl shift p 打开命令框，搜索 network conditions（网络调节） 并打开。 找到下面的 User Agent，取消选择 Select automatically （自动选择），然后在下面的输入框中加入“ MicroMessenger ”即可。 你做出的更改会在关闭开发者工具后复原。所以不要关闭开发者工具，然后重新输入那个链接地址，打开即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动端输入框填坑系列]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BE%93%E5%85%A5%E6%A1%86%E5%A1%AB%E5%9D%91%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[输入在移动端是一个很常用的功能，那么输入框必然是一个很重要的部分。然而，移动端输入框总会遇到各种各样的问题，无论是样式还是ios和android两端体验不一致都是很让我们头疼的问题，那么如何使移动web的输入框体验更贴近原生也成了一个需要我们多多思考和研究的问题。 一、文字输入限制问题我们拿最多可输入16个字为例。当输入字数（注意，不是字符长度）超过16字时，会触发tips提示，并且不能继续输入。 办法一：textarea可以使用maxlength进行输入字数限制。但是这个办法只能单纯的限制length，有时并不能真正的结局问题。办法二：在将第二个办法之前先来讲讲下面的几种情况： 1、非直接的文字输入什么叫做非直接的文字输入呢？ 当输入汉字时必然会是非直接输入，需要我们点选才能正式输入。当我们字数限制为16个字，需要实时检查是否到16字。输入文字时，当有非直接的文字输入时，监听keydown事件和input事件都会直接触发判断字数逻辑，会截断我们正在输入的文字。解决办法：监听compositionend（当直接的文字输入时触发）这时，当没选中中文的时候不会进行字数判断。 123456$('#input').on('compositionend', function (e) &#123; var len = $(this).val().length; if (len &gt; 16) &#123; // 提示超过16字 &#125;&#125;); 2、emoji表情的输入当输入emoji的时候，但是，当输入emoji表情的时候，js中判断emoji表情的length为2，因此emoji正常应该最多只能输入8个，但是ios端却把emoji的length算为1，可以输入16个emoji。这样就导致了两端的体验不同。因此需要在js中来进行字数限制。再加上汉字输入问题，那么就加入一个标记位，来判断是否是直接的文字输入。然后监听input，限制字数，当超过字数限制的时候，把前16个字截断显示出来就ok了。 12345678910111213141516var cpLock;$('#input').on('compositionstart', function (e) &#123; cpLock = true；&#125;);$('#input').on('compositionend', function (e) &#123; cpLock = false;&#125;);$('#input').on('input', function (e) &#123; if (!cpLock) &#123; if (e.target.value.length - 17 &gt;= 0) &#123; var txt = $(e.target).val().substring(0, 16); $(e.target).val(txt); // 超过16字提示 &#125; &#125;&#125;); 二、textarea置底展示问题ios中的输入体验永远伴随着一个问题，就是当唤起键盘后，整个页面会被键盘压缩，也就是说页面的高度变小，并且所有的fixed全部变为了absolute。 android效果： 使用fixed定位可见android中唤起键盘是覆盖在页面上，不会压缩页面 在ios上的效果： 那么如果我们需要将输入框固定在屏幕下方，而当键盘被唤起同时输入框固定在键盘上方（如下图样式）该如何解决呢？ 可以看出，键盘会将页面顶上去。那么如果希望可以将输入框和键盘完全贴合，我们可以使用div模拟一个假的输入框，使用定位将真正的输入框隐藏掉，当点击假的输入框的时候，将真正的输入框定位到键盘上方，并且手动获取输入框焦点。 在实现过程中需要注意下面几个问题：1、真正的输入框的位置计算：首先记录无键盘时的window.innerHeight，当键盘弹出后再获取当前的window.innerHeight，两者的差值即为键盘的高度，那么定位真输入框自然就很容易了2、在ios下手动获取焦点不可以用click事件，需要使用tap事件才可以手动触发 1234$('#fake-input').on($.os.ios ? 'tap' : 'click', function () &#123; initHeight = window.innerHeight; $('#input').focus();&#125;); 3、当键盘收起的时候我们需要将真输入框再次隐藏掉，除了使用失去焦点（blur）方法，还有什么方法可以判断键盘是否收起呢？这里可以使用setInterval监听，当当前window.innerHeight和整屏高度相等的时候判断为键盘收起。注意：键盘弹起需要一点时间，所以计算当前屏幕高度也需要使用setInterval4、因为textarea中的文字不能置底显示，当输入超过一行textarea需要自动调整高度，因此将scrollHeight赋值给textarea的height。当删除文字的时候需要height也有变化，因此每次input都先将height置0，然后再赋值。 12$('#textarea').css('height', 0);$('#textarea').css('height', $('#textarea')[0].scrollHeight); 未完待续… 原创文章转载请注明： 转载自AlloyTeam：http://www.alloyteam.com/2017/03/moves-the-input-box-fill-series-a/]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于input属性type=file的及其files对象的深层探究]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E5%85%B3%E4%BA%8Einput%E5%B1%9E%E6%80%A7type-file%E7%9A%84%E5%8F%8A%E5%85%B6files%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E5%B1%82%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[我们都知道，html5中有个input type=file元素。用该元素可以实现页面上传文件的功能 但一般的做法只是简单的在表单中操作，我来研究一下深层东西 想要了解它，就要知道它的内置对象，files 页面上写一个input，然后选俩个图片，打印这个input对象 1234$("input[name='file1']").change( function(e)&#123; console.log($("input[name='file1']"))&#125;) 发现有下列值，在0中，有一个files对象 我们发现input选择的文件被记录到了这个对象中，这个是fileList对象，是一个只读对象，不能修改 因为它不能修改，所以很难实现对已选中多个文件的删除某个文件等操作 里面记录了文件的name，size，type，和修改时间等，可知这个对象只存放了一些文件的信息，相当于是本地文件的索引，并不是把文件放到input中了，上传文件时它会再去找到实际的本地文件 利用这个files对象，我们可以实现很多功能，例如： 一.选择图片未经后端显示预览图片方法1：利用window的url工具将文件生成url，再将url赋值给img的src属性，显示出选中图像顺便提一下，input中控制选中类型加一个accept属性就行了，只会显示设定的文件类型 1&lt;input id="file1" type="file" name="file1" multiple="multiple" accept=".doc，.jpg"&gt; 1234567891011121314151617181920212223242526$('.fbpj-camera').change(function (event) &#123; //$('.dianpuzhuangxiu .addmokuai .block .shuoming1 .pic .pic1').children().remove(); // 根据这个 &lt;input&gt; 获取文件的 HTML5 js 对象 var files = event.target.files, file; if (files &amp;&amp; files.length &gt; 0) &#123; // 获取目前上传的文件 file = files[0]; // 来在控制台看看到底这个对象是什么 console.log(file); // 那么我们可以做一下诸如文件大小校验的动作 if (file.size &gt; 1024 * 1024 * 2) &#123; alert('图片大小不能超过 2MB!'); return false; &#125; // !!!!!! // 下面是关键的关键，通过这个 file 对象生成一个可用的图像 URL // 获取 window 的 URL 工具 var URL = window.URL || window.webkitURL; // 通过 file 生成目标 url var imgURL = URL.createObjectURL(file); // 用这个 URL 产生一个 &lt;img&gt; 将其显示出来 $('.fbpj .container').prev().find("img").attr('src', imgURL); // 使用下面这句可以在内存中释放对此 url 的伺服，跑了之后那个 URL 就无效了 //URL.revokeObjectURL(imgURL); &#125;&#125;); 方法2：利用html5的FileReader()读取文件（前提是浏览器支持的话）1234567if(window.FileReader) &#123; var fr = new FileReader(); // add your code here &#125; else &#123; alert("Not supported by your browser!"); &#125; 12&lt;input type="file" name="file" onchange="showPreview(this)" /&gt; &lt;img id="portrait" src="" width="70" height="75"&gt; 12345678910function showPreview(source) &#123; var file = source.files[0]; if (window.FileReader) &#123; var fr = new FileReader(); fr.onloadend = function (e) &#123; document.getElementById("portrait").src = e.target.result; &#125;; fr.readAsDataURL(file); //也是利用将图片作为url读出 &#125;&#125; FileReader还有一些其他用法12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt; &lt;meta name="author" content="oscar999"&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function handleFiles(files) &#123; if (files.length) &#123; var file = files[0]; var reader = new FileReader(); reader.onload = function () &#123; document.getElementById("filecontent").innerHTML = this.result; &#125;; reader.readAsText(file); //作为字符串读出 &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="file" id="file" onchange="handleFiles(this.files)"/&gt;&lt;div id="filecontent"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 二.文件拖拽的方法保存文件关于文件拖拽下面有注释，我主要说一下怎么给用js给input赋值，而不是手动去选文件 因为拖拽的区域只是一个div，无法进行上传操作，所以需要加一个form和input，让拖拽进去的文件进入input中。 取出files后，用$(“#file1”)[0].files=files;将文件赋值给input，注意赋值的必须是fileList对象，不要试图只放进去一个文件，fileList只读。 然后用h5中的FormData将form转化，提交即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;style&gt; .container &#123; width: 300px; height: 300px; border: 2px dashed #ddd; text-align: center; padding: 50px; &#125; &lt;/style&gt; &lt;title&gt; 培训活动列表 &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt; 拖拽进入&lt;/div&gt;&lt;form id="form1" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file1" id="file1" value=""/&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt; $('.container').bind('dragenter dragover', ignoreDrag); $(".container").on(&#123; drop: function (e) &#123; var flag = true; e.preventDefault(); //jquery的file要去e.originalEvent里面拿，拖拽获取files的方式与input的不同 var files = e.originalEvent.dataTransfer.files; //var files = e.dataTransfer.files; 原生的话这样就可以获取 for (var i = 0; i &lt; files.length; i++) &#123; myFileReader(files[i], function (result, file) &#123; if (result) &#123; //文件 console.log(file.name) &#125; else &#123; //文件夹 console.log("不要上传文件夹") flag = false; &#125; &#125;); &#125; if (flag) &#123; $("#file1")[0].files = files; //关键：将取到的文件赋值给input，用于ajax提交文件！！！ var formData = new FormData($("#form1")[0]); $.ajax(&#123; url: "/it/orderManage/saveActivity", type: 'POST', data: formData, // 告诉jQuery不要去处理发送的数据 processData: false, // 告诉jQuery不要去设置Content-Type请求头 contentType: false, async: true, success: function (ret) &#123; //alert("上传成功") if (ret) &#123; $("#trainInfoModal").modal("hide"); layer.alert("保存成功") $('#orderTable').bootstrapTable("refresh"); $("#trainInfoModal input").val(""); $("#trainInfoModal textarea").val(""); &#125; &#125; &#125;); &#125; console.log(files); &#125; &#125;) function ignoreDrag(e) &#123; e.originalEvent.stopPropagation(); e.originalEvent.preventDefault(); &#125; function myFileReader(file, callback) &#123; if (!window.FileReader) &#123; callback(true, file); return false; &#125; var fr = new FileReader(); fr.readAsDataURL(file); fr.onload = function (e) &#123; callback(true, file); &#125; fr.onerror = function (e) &#123; //不好判断是否是文件夹，通过上传报错可以判断是文件夹 callback(false, file); &#125; return true; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 后台获取文件还是用MutipartFile[]接收 暂时先总结这么多 作者：lianzhang861来源：CSDN原文：https://blog.csdn.net/lianzhang861/article/details/80283120版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
  </entry>
  <entry>
    <title><![CDATA[世界很大，我们很小，保持谦虚，稳步前行才是关键]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%B8%96%E7%95%8C%E5%BE%88%E5%A4%A7%EF%BC%8C%E6%88%91%E4%BB%AC%E5%BE%88%E5%B0%8F%EF%BC%8C%E4%BF%9D%E6%8C%81%E8%B0%A6%E8%99%9A%EF%BC%8C%E7%A8%B3%E6%AD%A5%E5%89%8D%E8%A1%8C%E6%89%8D%E6%98%AF%E5%85%B3%E9%94%AE%2F</url>
    <content type="text"><![CDATA[写了 Node 就算是后端了吗？其实不是的，你可以说自己跨入大前端行列了，可以说自己是会crud的页面仔，但是我个人的观点来讲，你是不算是一个全栈或后端的，因为随便几个问题就可以打破你是后端的这个概念了。 nginx 你很了解了吗？微服务你知道是什么概念吗？docker你了解过吗？你知道 Node 擅长处理密集型 IO（高并发），但是高并发下应该注意什么，没什么经验的你知道吗？即使是理论？从自己瞎玩到企业级运用其实是有很大差距的，如果你也能用 koa 抽象出像 egg 这样的企业级框架，那就确实是很厉害了，你在使用框架时，你觉得你很厉害，但是其实服务集群的稳定性、健壮性都是框架帮你实现的而已，去除框架，自己本身剩下的东西才是最重要的，而 node 也只是帮我们打开了一扇新世界的大门，让你从前端的繁杂过渡到了深度的世界而已，so~ emmmm，其实我看书是算比较慢的，因为我经常一章自己可能需要看 2-3 遍，书中的代码我必然是看了后再自己写的，有时候觉得书中太复杂，可能会自己按照书中的思想去改造，结果改到后来发现还是书中的设计正确然而写一篇总结博客，每章的内容可能需要看3-4遍才能保证全面且大部分正确，所以可能更新较慢 世界很大，我们很小，保持谦虚，稳步前行才是关键]]></content>
  </entry>
  <entry>
    <title><![CDATA[react笔记-虚拟DOM与DOM-diff算法]]></title>
    <url>%2F2018%2F10%2F26%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Freact%E7%AC%94%E8%AE%B0-%E8%99%9A%E6%8B%9FDOM%E4%B8%8EDOM-diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1). 虚拟DOM是什么?一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应如果只是更新虚拟DOM, 页面是不会重绘的 2). Virtual DOM 算法的基本步骤用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把差异应用到真实DOM树上，视图就更新了 3). 进一步理解Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;04_component&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; /* 验证: 虚拟DOM+DOM Diff算法: 最小化页面重绘 */ class HelloWorld extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; date: new Date() &#125; &#125; componentDidMount () &#123; setInterval(() =&gt; &#123; this.setState(&#123; date: new Date() &#125;) &#125;, 1000) &#125; render () &#123; console.log(&apos;render()&apos;) return ( &lt;p&gt; Hello, &lt;input type=&quot;text&quot; placeholder=&quot;Your name here&quot;/&gt;!&amp;nbsp; &lt;span&gt;It is &#123;this.state.date.toTimeString()&#125;&lt;/span&gt; &lt;/p&gt; ) &#125; &#125; ReactDOM.render( &lt;HelloWorld/&gt;, document.getElementById(&apos;example&apos;) )&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[react笔记-组件的生命周期]]></title>
    <url>%2F2018%2F10%2F26%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Freact%E7%AC%94%E8%AE%B0-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[组件的三个生命周期状态: Mount：插入真实 DOM Update：被重新渲染 Unmount：被移出真实 DOM 生命周期流程: 第一次初始化显示: ReactDOM.render(, containDom) constructor() componentWillMount() : 将要插入回调 render() : 用于插入虚拟DOM回调 componentDidMount() : 已经插入回调 每次更新state: this.setState({}) componentWillReceiveProps(): 接收父组件新的属性 componentWillUpdate() : 将要更新回调 render() : 更新(重新渲染) componentDidUpdate() : 已经更新回调 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件 componentWillUnmount() : 组件将要被移除回调 常用的方法 render(): 必须重写, 返回一个自定义的虚拟DOM constructor(): 初始化状态, 绑定this(可以箭头函数代替) componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;10_ComponentLife&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;example&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react.development.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/react-dom.development.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/babel&quot;&gt; /* 需求: 自定义组件 1. 让指定的文本做显示/隐藏的动画 2. 切换时间为2S 3. 点击按钮从界面中移除组件界面 */ class Fade extends React.Component &#123; constructor (props) &#123; super(props) console.log(&apos;constructor(): 创建组件对象&apos;) this.state = &#123; opacity: 1 &#125; this.removeComponent = this.removeComponent.bind(this) &#125; componentWillMount () &#123; console.log(&apos;componentWillMount(): 初始化将要挂载&apos;) &#125; componentDidMount () &#123;// 在此方法中启动定时器/绑定监听/发送ajax请求 console.log(&apos;componentDidMount(): 初始化已经挂载&apos;) // 保存到当前组件对象中 this.intervalId = setInterval(function () &#123; console.log(&apos;--------&apos;) // 得到当前opacity let &#123;opacity&#125; = this.state // 更新opacity opacity -= 0.1 if(opacity&lt;=0) &#123; opacity = 1 &#125; // 更新状态 this.setState(&#123;opacity&#125;) &#125;.bind(this), 200) &#125; componentWillUpdate () &#123; console.log(&apos;componentWillUpdate(): 将要更新&apos;) &#125; componentDidUpdate () &#123; console.log(&apos;componentDidUpdate(): 已经更新&apos;) &#125; componentWillUnmount () &#123;// 清除定时器/解除监听 console.log(&apos;componentWillUnmount(): 将要被移除&apos;) clearInterval(this.intervalId) &#125; removeComponent () &#123; ReactDOM.unmountComponentAtNode(document.getElementById(&apos;example&apos;)) &#125; render() &#123; console.log(&apos;render() 渲染组件&apos;) return ( &lt;div&gt; &lt;h2 style=&#123;&#123;opacity:this.state.opacity&#125;&#125;&gt;&#123;this.props.content&#125;&lt;/h2&gt; &lt;button onClick=&#123;this.removeComponent&#125;&gt;不活了&lt;/button&gt; &lt;/div&gt; ) &#125; &#125; ReactDOM.render(&lt;Fade content=&quot;react学不会, 怎么办?&quot;/&gt;, document.getElementById(&apos;example&apos;))&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa中间件]]></title>
    <url>%2F2018%2F09%2F26%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fkoa%E4%B8%AD%E9%97%B4%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、什么是 Koa 的中间件通俗的讲：中间件就是匹配路由之前或者匹配路由完成做的一系列的操作，我们就可以把它叫做中间件。 在 express 中间件（Middleware）是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处理请求-响应循环流程中的中间件，一般被命名为 next 的变量。在 Koa 中中间件和 express 有点类似 中间件的功能包括：执行任何代码。 修改请求和响应对象。 终结请求-响应循环。 调用堆栈中的下一个中间件。 如果我的 get、post 回调函数中，没有 next 参数，那么就配了。如果想往下匹配的话，那么需要写 next() 二、Koa 应用可使用如下几种中间件：应用级中间件路由级中间件错误处理中间件第三方中间件 1.应用级中间件12345678910111213141516171819202122232425262728293031323334//引入 koa模块var Koa=require('koa');var router = require('koa-router')(); /*引入是实例化路由** 推荐*/var app=new Koa();//Koa中间件//匹配任何路由 ，如果不写next，这个路由被匹配到了就不会继续向下匹配/* app.use(async (ctx)=&gt;&#123; ctx.body='这是一个中间件'; &#125;)* *//*匹配路由之前打印日期*/app.use(async (ctx,next)=&gt;&#123; console.log(new Date()); await next(); /*当前路由匹配完成以后继续向下匹配*/&#125;)router.get('/',async (ctx)=&gt;&#123; ctx.body="首页";&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body="新闻列表页面";&#125;)router.get('/login',async (ctx)=&gt;&#123; ctx.body="新闻列表页面";&#125;)app.use(router.routes()); /*启动路由*/app.use(router.allowedMethods());app.listen(3002); 2.路由级中间件123456789101112131415161718192021222324252627282930//引入 koa模块var Koa=require('koa');var router = require('koa-router')(); /*引入是实例化路由** 推荐*/var app=new Koa();//Koa中间件//匹配任何路由，如果不写next，这个路由被匹配到了就不会继续向下匹配router.get('/',async (ctx)=&gt;&#123; ctx.body="首页";&#125;)// 匹配到news路由以后继续向下匹配路由router.get('/news',async (ctx,next)=&gt;&#123; console.log('这是一个新闻1'); await next();&#125;)router.get('/news',async (ctx)=&gt;&#123; ctx.body='这是一个新闻';&#125;)router.get('/login',async (ctx)=&gt;&#123; ctx.body="新闻列表页面";&#125;)app.use(router.routes()); /*启动路由*/app.use(router.allowedMethods());app.listen(3002); 3.错误处理中间件123456789101112131415161718192021222324252627282930313233343536373839//引入 koa模块var Koa=require('koa');var router = require('koa-router')(); /*引入是实例化路由** 推荐*/var app=new Koa();//Koa中间件//匹配任何路由 ，如果不写next，这个路由被匹配到了就不会继续向下匹配//www.域名.com/newsapp.use(async (ctx,next)=&gt;&#123; console.log('这是一个中间件01'); next(); if(ctx.status==404)&#123; /*如果页面找不到*/ ctx.status = 404; ctx.body="这是一个 404 页面" &#125;else&#123; console.log(ctx.url); &#125;&#125;)router.get('/',async (ctx)=&gt;&#123; ctx.body="首页";&#125;)router.get('/news',async (ctx)=&gt;&#123; console.log('这是新闻2'); ctx.body='这是一个新闻';&#125;)router.get('/login',async (ctx)=&gt;&#123; ctx.body="新闻列表页面";&#125;)app.use(router.routes()); /*启动路由*/app.use(router.allowedMethods());app.listen(3002); 4.中间件执行流程：洋葱圈1234567891011121314151617181920212223242526272829303132333435363738394041//引入 koa模块var Koa=require(&apos;koa&apos;);var router = require(&apos;koa-router&apos;)(); /*引入是实例化路由** 推荐*/var app=new Koa();//Koa中间件//匹配任何路由 ，如果不写next，这个路由被匹配到了就不会继续向下匹配//www.域名.com/newsapp.use(async (ctx,next)=&gt;&#123; console.log(&apos;1、这是第一个中间件01&apos;); await next(); console.log(&apos;5、匹配路由完成以后又会返回来执行中间件&apos;);&#125;)app.use(async (ctx,next)=&gt;&#123; console.log(&apos;2、这是第二个中间件02&apos;); await next(); console.log(&apos;4、匹配路由完成以后又会返回来执行中间件&apos;);&#125;)router.get(&apos;/&apos;,async (ctx)=&gt;&#123; ctx.body=&quot;首页&quot;;&#125;)router.get(&apos;/news&apos;,async (ctx)=&gt;&#123; console.log(&apos;3、匹配到了news这个路由&apos;); ctx.body=&apos;这是一个新闻&apos;;&#125;)app.use(router.routes()); /*启动路由*/app.use(router.allowedMethods());app.listen(3002);]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac下chrome关闭跨域限制]]></title>
    <url>%2F2018%2F03%2F30%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fmac%E4%B8%8Bchrome%E5%85%B3%E9%97%AD%E8%B7%A8%E5%9F%9F%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1open -n /Applications/Google\ Chrome.app/ --args --disable-web-security --user-data-dir=/Users/用户名/MyChromeDevUserData/]]></content>
  </entry>
  <entry>
    <title><![CDATA[移动开发不同手机弹出数字键盘问题]]></title>
    <url>%2F2017%2F11%2F09%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E7%A7%BB%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%8D%E5%90%8C%E6%89%8B%E6%9C%BA%E5%BC%B9%E5%87%BA%E6%95%B0%E5%AD%97%E9%94%AE%E7%9B%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[做手机页面时，遇到数字输入的键盘的问题，之前的做法只是一刀切的使用 type=”tel”，不过一直觉得九宫格的电话号码键盘上的英文字母太碍事了。于是想要尝试其它的实现方案，最终的结论却令人沮丧。不过也趁机详细了解了下pattern这个属性。type=”tel” 和 type=”number” 的区别这里还是先那么先交代一下最初遇到的问题。其实无论是tel还是number都不是完美的： type=”tel” 优点是iOS和Android的键盘表现都差不多 缺点是那些字母好多余，虽然我没有强迫症但还是感觉怪怪的啊。 [图片上传中…(image-fb2657-1510218512899-0)] type=”number” 优点是Android下实现的一个真正的数字键盘 缺点一：iOS下不是九宫格键盘，输入不方便 缺点二：旧版Android（包括微信所用的X5内核）在输入框后面会有超级鸡肋的小尾巴，好在Android 4.4.4以后给去掉了。 [图片上传失败…(image-42eb84-1510218512901)] [图片上传失败…(image-ca5b01-1510218512901)] 不过对于缺点二，我们可以用webkit私有的伪元素给fix掉： 1input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button &#123; -webkit-appearance: none; appearance: none; margin: 0; &#125; pattern属性pattern用于验证表单输入的内容，通常HTML5的type属性，比如email、tel、number、data类、url等，已经自带了简单的数据格式验证功能了，加上pattern后，前端部分的验证更加简单高效了。 显而易见，pattern的属性值要用正则表达式。 实例简单的数字验证数字的验证有两个： 1&lt;input type=&quot;number&quot; pattern=&quot;\d&quot;&gt; &lt;input type=&quot;number&quot; pattern=&quot;[0-9]*&quot;&gt; [图片上传失败…(image-e580b3-1510218512901)] 对表单验证来说，这两个正则的作用是一样的，表现的话差异就很大： iOS中，只有[0-9]\*才可以调起九宫格数字键盘，\d 无效 Android 4.4以下(包括X5内核)，两者都调起数字键盘； Android 4.4.4以上，只认 type 属性，也就是说，如果上面的代码将 type=&quot;number&quot; 改为 type=&quot;text&quot; ，将调起全键盘而不会是九宫格数字键盘。 常用的正则表达式pattern的用法都一样，这里不再啰嗦各种详细写法了，只是列出来一些常用的正则就好了： 信用卡 [0-9]{13,16} 银联卡 ^62[0-5]\d{13,16}$ Visa: ^4[0-9]{12}(?:[0-9]{3})?$ 万事达：^5[1-5][0-9]{14}$ QQ号码： [1-9][0-9]{4,14} 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 身份证：^([0-9]){7,18}(x|X)?$ 密码：^[a-zA-Z]\w{5,17}$ 字母开头，长度在6~18之间，只能包含字母、数字和下划线 强密码：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间 7个汉字或14个字符：^[\u4e00-\u9fa5]{1,7}$|^[\dA-Za-z_]{1,14}$ 浏览器支持很不幸，pattern的浏览器支持很惨：]]></content>
  </entry>
  <entry>
    <title><![CDATA[mac命令行启动tomcat]]></title>
    <url>%2F2017%2F10%2F09%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fmac%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8tomcat%2F</url>
    <content type="text"><![CDATA[1、检查安装环境 可以在shell终端运行如下命令查看是否安装了java，以及JDK的版本： Java -version 如果没有安装，请到https://www.java.com/en/download/下载安装 2、开始安装Tomcat 下载链接：http://tomcat.apache.org/ 可以下载tar.gz文件，8.X版本，文件夹名称是apache-tomcat-8.5.9.tar.gz 3、终端操作 3.1、将apache-tomcat-8.5.9.tar.gz文件移动到/usr/local/下 sudo mv /Users/feng/Downloads/apache-tomcat-8.5.9.tar.gz /usr/local/ 3.2、解压缩在/usr/local/目录 sudo cd /usr/local/ tar zxvf apache-tomcat-8.5.9.tar.gz . 3.3、建立链接，方便维护使用 sudo ln -s /usr/local/apache-tomcat-8.5.9 /Library/Tomcat 3.4、使自己成为目录的持有者 sudo chown -R 你的系统用户名 /Library/Tomcat 3.5、允许bin目录下程序运行 sudo chmod 755 /Library/Tomcat/bin/*.sh 完成 4、启动Tomcat 命令行启动： /Library/Tomcat/bin/startup.sh 若出现如下提示则表示安装并运行成功： Using CATALINA_BASE: /Library/Tomcat Using CATALINA_HOME: /Library/Tomcat Using CATALINA_TMPDIR: /Library/Tomcat/temp Using JRE_HOME: /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Home （有时候到这一步了还是依然无法访问8080，有可能是tomcat版本的问题，换成7.0.65版本就OK） 停止tomcat： shutdown.sh (如果不能停止使用killall -9 java 命令杀死进程，用ps -ef| grep java再验证下是否全部杀掉了进程) 5、打开浏览器，输入 http://localhost:8080/ 回车之后如果看到Apache Tomcat，表示已经成功运行Tomcat 6、配置Tomcat启动脚本： 6.1、在/usr/bin目录下，使用vi创建tomcat文件，添加如下命令： #!/bin/bash case $1 instart)sh /Library/Tomcat/bin/startup.sh;;stop)sh /Library/Tomcat/bin/shutdown.sh;;restart)sh /Library/Tomcat/bin/shutdown.shsh /Library/Tomcat/bin/startup.sh;;*)echo “Usage: start|stop|restart”;;esac exit 0 6.2、赋予文件执行权限： chmod 777 tomcat 6.3、将这个文件放置到终端包含的路径中，例如/usr/bin，而后便可以在终端中简单地输入tomcat start和tomcat stop启用tomcat了。 快捷命令如下： 1）tomcat start 2) tomcat stop 3) tomcat restart]]></content>
  </entry>
  <entry>
    <title><![CDATA[overflow深入理解]]></title>
    <url>%2F2017%2F07%2F01%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Foverflow%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.如果overflow-x与overflow-y的值相同则等同于overflow；如果overflow-x与overflow-y的值不相同且其中一个属性值被赋为visible，而另一个值被赋为hidden/scroll/auto,那么这个visible会被重置为auto]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS实现多重边框]]></title>
    <url>%2F2017%2F06%2F28%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FCSS%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E8%BE%B9%E6%A1%86%2F</url>
    <content type="text"><![CDATA[实现这样的效果 简单 123456789101112.box &#123; width: 150px; display: flex; justify-content: center; align-items: center; height: 200px; background-color: lightskyblue; border: 20px solid royalblue;&#125;&lt;div class=&quot;box&quot;&gt; box&lt;/div&gt; 但要实现这样的效果，不包裹div的前提下，使用outline属性 12345678910.box &#123; width: 150px; display: flex; justify-content: center; align-items: center; height: 200px; background-color: lightskyblue; border: 20px solid royalblue; outline: solid 20px brown;&#125; 但要实现这样的效果 outline 是不行的 如果使用 outline 只会这样 1234567891011.box &#123; width: 150px; display: flex; justify-content: center; align-items: center; height: 200px; background-color: lightskyblue; border: 20px solid royalblue; border-radius: 30px; outline: solid 20px brown;&#125; 但是用阴影 box-shadow 可以做到 就像这样 1234567891011.box &#123; width: 150px; display: flex; justify-content: center; align-items: center; height: 200px; background-color: lightskyblue; border: 20px solid royalblue; border-radius: 30px; box-shadow: 0 0 0 20px brown;&#125; 还能这样 12345678910111213.box &#123; width: 150px; display: flex; justify-content: center; align-items: center; height: 200px; background-color: lightskyblue; border: 20px solid royalblue; border-radius: 30px; box-shadow: 0 0 0 20px brown, 0 0 0 40px salmon, 0 0 0 60px crimson;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[HBuilder使用逍遥安卓5.1版本模拟器方法]]></title>
    <url>%2F2017%2F06%2F17%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FHBuilder%E4%BD%BF%E7%94%A8%E9%80%8D%E9%81%A5%E5%AE%89%E5%8D%935-1%E7%89%88%E6%9C%AC%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.下载逍遥安卓模拟器逍遥安卓模拟器官网地址：逍遥安卓模拟器官网；安装成功后不要着急打开，因为默认是安卓4.4版本，还要下载逍遥安卓5.1.1安卓系统内核 2.下载逍遥安卓5.1.1安卓系统内核去官方论坛下载，地址：公测版逍遥安卓5.1.1安卓系统内核模拟器独家发布;或者百度网盘下载，链接: https://pan.baidu.com/s/1boQApNT 密码: xctb 3.安装5.1.1内核双击就可安装 安装好之后打开逍遥安卓多开器，点击“新建模拟器”，选择“创建Android 5.1.1模拟器”，等待创建成功就可以打开了。 4.关联HBuilder打开HBuilder安装目录 Hbuilder/tools/adbs，复制这3个文件 拷贝到逍遥模拟器安装目录的 Memu文件夹下 在逍遥模拟器中打开开发者调试选项打开USB调试 在HBuilder选项中修改端口 21503 打开逍遥安卓模拟器 重启HBuilder就可以调试了]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS3弹性盒模型]]></title>
    <url>%2F2017%2F04%2F16%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2FCSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。设置 display 属性的值为 flex 或 inline-flex。注意： 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。弹性子元素默认情况每个容器只有一行。 ##弹性盒模型属性： #####flex-direction属性:指定了弹性子元素在父容器中的位置。 row：横向从左到右排列（左对齐），默认的排列方式。row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。column：纵向排列。column-reverse：反转纵向排列，从后往前排，最后一项排在最上面。 #####justify-content :内容对齐（justify-content）属性应用在弹性容器上，把弹性项沿着弹性容器的主轴线（main axis）对齐。 flex-start：弹性项目向行头紧挨着填充。这个是默认值。第一个弹性项的main-start外边距边线被放置在该行的main-start边线，而后续弹性项依次平齐摆放。flex-end：弹性项目向行尾紧挨着填充。第一个弹性项的main-end外边距边线被放置在该行的main-end边线，而后续弹性项依次平齐摆放。center：弹性项目居中紧挨着填充。（如果剩余的自由空间是负的，则弹性项目将在两个方向上同时溢出）。space-between：弹性项目平均分布在该行上。如果剩余空间为负或者只有一个弹性项，则该值等同于flex-start。否则，第1个弹性项的外边距和行的main-start边线对齐，而最后1个弹性项的外边距和行的main-end边线对齐，然后剩余的弹性项分布在该行上，相邻项目的间隔相等。space-around：弹性项目平均分布在该行上，两边留有一半的间隔空间。如果剩余空间为负或者只有一个弹性项，则该值等同于center。否则，弹性项目沿该行分布，且彼此间隔相等（比如是20px），同时首尾两边和弹性容器之间留有一半的间隔（1/2*20px=10px）。 #####align-items :弹性盒子元素在侧轴（纵轴）方向上的对齐方式。 flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。 #####flex-wrap 属性：弹性盒子的子元素换行方式 nowrap - 默认， 弹性容器为单行。该情况下弹性子项可能会溢出容器。wrap - 弹性容器为多行。该情况下弹性子项溢出的部分会被放置到新行，子项内部会发生断行wrap-reverse -反转 wrap 排列。 #####align-content :修改 flex-wrap 属性的行为。类似于 align-items, 但它不是设置弹性子元素的对齐，而是设置各个行的对齐。 stretch - 默认。各行将会伸展以占用剩余的空间。flex-start - 各行向弹性盒容器的起始位置堆叠。flex-end - 各行向弹性盒容器的结束位置堆叠。center -各行向弹性盒容器的中间位置堆叠。space-between -各行在弹性盒容器中平均分布。space-around - 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。 ##弹性盒模型子元素属性： #####order: 排序 **：用整数值来定义排列顺序，数值小的排在前面。可以为负值。 #####margin：对齐 #####align-self ：弹性元素自身在侧轴（纵轴）方向上的对齐方式。 auto：如果’align-self’的值为’auto’，则其计算值为元素的父元素的’align-items’值，如果其没有父元素，则计算值为’stretch’。flex-start：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界。flex-end：弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界。center：弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度）。baseline：如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。stretch：如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。 #####flex ：指定弹性子元素如何分配空间。 auto: 计算值为 1 1 autoinitial: 计算值为 0 1 autonone：计算值为 0 0 autoinherit：从父元素继承[ flex-grow ]：定义弹性盒子元素的扩展比率。[ flex-shrink ]：定义弹性盒子元素的收缩比率。[ flex-basis ]：定义弹性盒子元素的默认基准值。]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用jsencrypt执行OpenSSL的RSA加密，解密]]></title>
    <url>%2F2017%2F02%2F23%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2F%E4%BD%BF%E7%94%A8jsencrypt%E6%89%A7%E8%A1%8COpenSSL%E7%9A%84RSA%E5%8A%A0%E5%AF%86%EF%BC%8C%E8%A7%A3%E5%AF%86%2F</url>
    <content type="text"><![CDATA[jsencrypt的GITHUB地址：https://github.com/travist/jsencrypt 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;使用jsencrypt执行OpenSSL的RSA加密，解密&lt;/title&gt; &lt;/head&gt; &lt;!--引入jsencrypt.js--&gt; &lt;script src=&quot;../bin/jsencrypt.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; //公钥 var PUBLIC_KEY = &apos;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDlOJu6TyygqxfWT7eLtGDwajtNFOb9I5XRb6khyfD1Yt3YiCgQWMNW649887VGJiGr/L5i2osbl8C9+WJTeucF+S76xFxdU6jE0NQ+Z+zEdhUTooNRaY5nZiu5PgDB0ED/ZKBUSLKL7eibMxZtMlUDHjm4gwQco1KRMDSmXSMkDwIDAQAB&apos;; //私钥 var PRIVATE_KEY = &apos;MIICXQIBAAKBgQDlOJu6TyygqxfWT7eLtGDwajtNFOb9I5XRb6khyfD1Yt3YiCgQWMNW649887VGJiGr/L5i2osbl8C9+WJTeucF+S76xFxdU6jE0NQ+Z+zEdhUTooNRaY5nZiu5PgDB0ED/ZKBUSLKL7eibMxZtMlUDHjm4gwQco1KRMDSmXSMkDwIDAQABAoGAfY9LpnuWK5Bs50UVep5c93SJdUi82u7yMx4iHFMc/Z2hfenfYEzu+57fI4fvxTQ//5DbzRR/XKb8ulNv6+CHyPF31xk7YOBfkGI8qjLoq06V+FyBfDSwL8KbLyeHm7KUZnLNQbk8yGLzB3iYKkRHlmUanQGaNMIJziWOkN+N9dECQQD0ONYRNZeuM8zd8XJTSdcIX4a3gy3GGCJxOzv16XHxD03GW6UNLmfPwenKu+cdrQeaqEixrCejXdAFz/7+BSMpAkEA8EaSOeP5Xr3ZrbiKzi6TGMwHMvC7HdJxaBJbVRfApFrE0/mPwmP5rN7QwjrMY+0+AbXcm8mRQyQ1+IGEembsdwJBAN6az8Rv7QnD/YBvi52POIlRSSIMV7SwWvSK4WSMnGb1ZBbhgdg57DXaspcwHsFV7hByQ5BvMtIduHcT14ECfcECQATeaTgjFnqE/lQ22Rk0eGaYO80cc643BXVGafNfd9fcvwBMnk0iGX0XRsOozVt5AzilpsLBYuApa66NcVHJpCECQQDTjI2AQhFc1yRnCU/YgDnSpJVm1nASoRUnU8Jfm3Ozuku7JUXcVpt08DFSceCEX9unCuMcT72rAQlLpdZir876&apos;; //使用公钥加密 var encrypt = new JSEncrypt(); encrypt.setPublicKey(&apos;-----BEGIN PUBLIC KEY-----&apos; + PUBLIC_KEY + &apos;-----END PUBLIC KEY-----&apos;); var encrypted = encrypt.encrypt(&apos;ceshi01&apos;); console.log(&apos;加密后数据:%o&apos;, encrypted); //使用私钥解密 var decrypt = new JSEncrypt(); decrypt.setPrivateKey(&apos;-----BEGIN RSA PRIVATE KEY-----&apos;+PRIVATE_KEY+&apos;-----END RSA PRIVATE KEY-----&apos;); var uncrypted = decrypt.decrypt(encrypted); console.log(&apos;解密后数据:%o&apos;, uncrypted); &lt;/script&gt;&lt;/html&gt; JSEncrypt v2.3.1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/*! JSEncrypt v2.3.1 | https://npmcdn.com/jsencrypt@2.3.1/LICENSE.txt */!function(t,e)&#123;&quot;function&quot;==typeof define&amp;&amp;define.amd?define([&quot;exports&quot;],e):e(&quot;object&quot;==typeof exports&amp;&amp;&quot;string&quot;!=typeof exports.nodeName?module.exports:t)&#125;(this,function(t)&#123;function e(t,e,i)&#123;null!=t&amp;&amp;(&quot;number&quot;==typeof t?this.fromNumber(t,e,i):null==e&amp;&amp;&quot;string&quot;!=typeof t?this.fromString(t,256):this.fromString(t,e))&#125;function i()&#123;return new e(null)&#125;function r(t,e,i,r,s,n)&#123;for(;--n&gt;=0;)&#123;var o=e*this[t++]+i[r]+s;s=Math.floor(o/67108864),i[r++]=67108863&amp;o&#125;return s&#125;function s(t,e,i,r,s,n)&#123;for(var o=32767&amp;e,h=e&gt;&gt;15;--n&gt;=0;)&#123;var a=32767&amp;this[t],u=this[t++]&gt;&gt;15,c=h*a+u*o;a=o*a+((32767&amp;c)&lt;&lt;15)+i[r]+(1073741823&amp;s),s=(a&gt;&gt;&gt;30)+(c&gt;&gt;&gt;15)+h*u+(s&gt;&gt;&gt;30),i[r++]=1073741823&amp;a&#125;return s&#125;function n(t,e,i,r,s,n)&#123;for(var o=16383&amp;e,h=e&gt;&gt;14;--n&gt;=0;)&#123;var a=16383&amp;this[t],u=this[t++]&gt;&gt;14,c=h*a+u*o;a=o*a+((16383&amp;c)&lt;&lt;14)+i[r]+s,s=(a&gt;&gt;28)+(c&gt;&gt;14)+h*u,i[r++]=268435455&amp;a&#125;return s&#125;function o(t)&#123;return Be.charAt(t)&#125;function h(t,e)&#123;var i=Ke[t.charCodeAt(e)];return null==i?-1:i&#125;function a(t)&#123;for(var e=this.t-1;e&gt;=0;--e)t[e]=this[e];t.t=this.t,t.s=this.s&#125;function u(t)&#123;this.t=1,this.s=0&gt;t?-1:0,t&gt;0?this[0]=t:-1&gt;t?this[0]=t+this.DV:this.t=0&#125;function c(t)&#123;var e=i();return e.fromInt(t),e&#125;function f(t,i)&#123;var r;if(16==i)r=4;else if(8==i)r=3;else if(256==i)r=8;else if(2==i)r=1;else if(32==i)r=5;else&#123;if(4!=i)return void this.fromRadix(t,i);r=2&#125;this.t=0,this.s=0;for(var s=t.length,n=!1,o=0;--s&gt;=0;)&#123;var a=8==r?255&amp;t[s]:h(t,s);0&gt;a?&quot;-&quot;==t.charAt(s)&amp;&amp;(n=!0):(n=!1,0==o?this[this.t++]=a:o+r&gt;this.DB?(this[this.t-1]|=(a&amp;(1&lt;&lt;this.DB-o)-1)&lt;&lt;o,this[this.t++]=a&gt;&gt;this.DB-o):this[this.t-1]|=a&lt;&lt;o,o+=r,o&gt;=this.DB&amp;&amp;(o-=this.DB))&#125;8==r&amp;&amp;0!=(128&amp;t[0])&amp;&amp;(this.s=-1,o&gt;0&amp;&amp;(this[this.t-1]|=(1&lt;&lt;this.DB-o)-1&lt;&lt;o)),this.clamp(),n&amp;&amp;e.ZERO.subTo(this,this)&#125;function p()&#123;for(var t=this.s&amp;this.DM;this.t&gt;0&amp;&amp;this[this.t-1]==t;)--this.t&#125;function l(t)&#123;if(this.s&lt;0)return&quot;-&quot;+this.negate().toString(t);var e;if(16==t)e=4;else if(8==t)e=3;else if(2==t)e=1;else if(32==t)e=5;else&#123;if(4!=t)return this.toRadix(t);e=2&#125;var i,r=(1&lt;&lt;e)-1,s=!1,n=&quot;&quot;,h=this.t,a=this.DB-h*this.DB%e;if(h-- &gt;0)for(a&lt;this.DB&amp;&amp;(i=this[h]&gt;&gt;a)&gt;0&amp;&amp;(s=!0,n=o(i));h&gt;=0;)e&gt;a?(i=(this[h]&amp;(1&lt;&lt;a)-1)&lt;&lt;e-a,i|=this[--h]&gt;&gt;(a+=this.DB-e)):(i=this[h]&gt;&gt;(a-=e)&amp;r,0&gt;=a&amp;&amp;(a+=this.DB,--h)),i&gt;0&amp;&amp;(s=!0),s&amp;&amp;(n+=o(i));return s?n:&quot;0&quot;&#125;function d()&#123;var t=i();return e.ZERO.subTo(this,t),t&#125;function g()&#123;return this.s&lt;0?this.negate():this&#125;function m(t)&#123;var e=this.s-t.s;if(0!=e)return e;var i=this.t;if(e=i-t.t,0!=e)return this.s&lt;0?-e:e;for(;--i&gt;=0;)if(0!=(e=this[i]-t[i]))return e;return 0&#125;function y(t)&#123;var e,i=1;return 0!=(e=t&gt;&gt;&gt;16)&amp;&amp;(t=e,i+=16),0!=(e=t&gt;&gt;8)&amp;&amp;(t=e,i+=8),0!=(e=t&gt;&gt;4)&amp;&amp;(t=e,i+=4),0!=(e=t&gt;&gt;2)&amp;&amp;(t=e,i+=2),0!=(e=t&gt;&gt;1)&amp;&amp;(t=e,i+=1),i&#125;function b()&#123;return this.t&lt;=0?0:this.DB*(this.t-1)+y(this[this.t-1]^this.s&amp;this.DM)&#125;function T(t,e)&#123;var i;for(i=this.t-1;i&gt;=0;--i)e[i+t]=this[i];for(i=t-1;i&gt;=0;--i)e[i]=0;e.t=this.t+t,e.s=this.s&#125;function S(t,e)&#123;for(var i=t;i&lt;this.t;++i)e[i-t]=this[i];e.t=Math.max(this.t-t,0),e.s=this.s&#125;function R(t,e)&#123;var i,r=t%this.DB,s=this.DB-r,n=(1&lt;&lt;s)-1,o=Math.floor(t/this.DB),h=this.s&lt;&lt;r&amp;this.DM;for(i=this.t-1;i&gt;=0;--i)e[i+o+1]=this[i]&gt;&gt;s|h,h=(this[i]&amp;n)&lt;&lt;r;for(i=o-1;i&gt;=0;--i)e[i]=0;e[o]=h,e.t=this.t+o+1,e.s=this.s,e.clamp()&#125;function E(t,e)&#123;e.s=this.s;var i=Math.floor(t/this.DB);if(i&gt;=this.t)return void(e.t=0);var r=t%this.DB,s=this.DB-r,n=(1&lt;&lt;r)-1;e[0]=this[i]&gt;&gt;r;for(var o=i+1;o&lt;this.t;++o)e[o-i-1]|=(this[o]&amp;n)&lt;&lt;s,e[o-i]=this[o]&gt;&gt;r;r&gt;0&amp;&amp;(e[this.t-i-1]|=(this.s&amp;n)&lt;&lt;s),e.t=this.t-i,e.clamp()&#125;function D(t,e)&#123;for(var i=0,r=0,s=Math.min(t.t,this.t);s&gt;i;)r+=this[i]-t[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;if(t.t&lt;this.t)&#123;for(r-=t.s;i&lt;this.t;)r+=this[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;r+=this.s&#125;else&#123;for(r+=this.s;i&lt;t.t;)r-=t[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;r-=t.s&#125;e.s=0&gt;r?-1:0,-1&gt;r?e[i++]=this.DV+r:r&gt;0&amp;&amp;(e[i++]=r),e.t=i,e.clamp()&#125;function w(t,i)&#123;var r=this.abs(),s=t.abs(),n=r.t;for(i.t=n+s.t;--n&gt;=0;)i[n]=0;for(n=0;n&lt;s.t;++n)i[n+r.t]=r.am(0,s[n],i,n,0,r.t);i.s=0,i.clamp(),this.s!=t.s&amp;&amp;e.ZERO.subTo(i,i)&#125;function x(t)&#123;for(var e=this.abs(),i=t.t=2*e.t;--i&gt;=0;)t[i]=0;for(i=0;i&lt;e.t-1;++i)&#123;var r=e.am(i,e[i],t,2*i,0,1);(t[i+e.t]+=e.am(i+1,2*e[i],t,2*i+1,r,e.t-i-1))&gt;=e.DV&amp;&amp;(t[i+e.t]-=e.DV,t[i+e.t+1]=1)&#125;t.t&gt;0&amp;&amp;(t[t.t-1]+=e.am(i,e[i],t,2*i,0,1)),t.s=0,t.clamp()&#125;function B(t,r,s)&#123;var n=t.abs();if(!(n.t&lt;=0))&#123;var o=this.abs();if(o.t&lt;n.t)return null!=r&amp;&amp;r.fromInt(0),void(null!=s&amp;&amp;this.copyTo(s));null==s&amp;&amp;(s=i());var h=i(),a=this.s,u=t.s,c=this.DB-y(n[n.t-1]);c&gt;0?(n.lShiftTo(c,h),o.lShiftTo(c,s)):(n.copyTo(h),o.copyTo(s));var f=h.t,p=h[f-1];if(0!=p)&#123;var l=p*(1&lt;&lt;this.F1)+(f&gt;1?h[f-2]&gt;&gt;this.F2:0),d=this.FV/l,g=(1&lt;&lt;this.F1)/l,m=1&lt;&lt;this.F2,v=s.t,b=v-f,T=null==r?i():r;for(h.dlShiftTo(b,T),s.compareTo(T)&gt;=0&amp;&amp;(s[s.t++]=1,s.subTo(T,s)),e.ONE.dlShiftTo(f,T),T.subTo(h,h);h.t&lt;f;)h[h.t++]=0;for(;--b&gt;=0;)&#123;var S=s[--v]==p?this.DM:Math.floor(s[v]*d+(s[v-1]+m)*g);if((s[v]+=h.am(0,S,s,b,0,f))&lt;S)for(h.dlShiftTo(b,T),s.subTo(T,s);s[v]&lt;--S;)s.subTo(T,s)&#125;null!=r&amp;&amp;(s.drShiftTo(f,r),a!=u&amp;&amp;e.ZERO.subTo(r,r)),s.t=f,s.clamp(),c&gt;0&amp;&amp;s.rShiftTo(c,s),0&gt;a&amp;&amp;e.ZERO.subTo(s,s)&#125;&#125;&#125;function K(t)&#123;var r=i();return this.abs().divRemTo(t,null,r),this.s&lt;0&amp;&amp;r.compareTo(e.ZERO)&gt;0&amp;&amp;t.subTo(r,r),r&#125;function A(t)&#123;this.m=t&#125;function U(t)&#123;return t.s&lt;0||t.compareTo(this.m)&gt;=0?t.mod(this.m):t&#125;function O(t)&#123;return t&#125;function V(t)&#123;t.divRemTo(this.m,null,t)&#125;function N(t,e,i)&#123;t.multiplyTo(e,i),this.reduce(i)&#125;function J(t,e)&#123;t.squareTo(e),this.reduce(e)&#125;function I()&#123;if(this.t&lt;1)return 0;var t=this[0];if(0==(1&amp;t))return 0;var e=3&amp;t;return e=e*(2-(15&amp;t)*e)&amp;15,e=e*(2-(255&amp;t)*e)&amp;255,e=e*(2-((65535&amp;t)*e&amp;65535))&amp;65535,e=e*(2-t*e%this.DV)%this.DV,e&gt;0?this.DV-e:-e&#125;function P(t)&#123;this.m=t,this.mp=t.invDigit(),this.mpl=32767&amp;this.mp,this.mph=this.mp&gt;&gt;15,this.um=(1&lt;&lt;t.DB-15)-1,this.mt2=2*t.t&#125;function M(t)&#123;var r=i();return t.abs().dlShiftTo(this.m.t,r),r.divRemTo(this.m,null,r),t.s&lt;0&amp;&amp;r.compareTo(e.ZERO)&gt;0&amp;&amp;this.m.subTo(r,r),r&#125;function L(t)&#123;var e=i();return t.copyTo(e),this.reduce(e),e&#125;function q(t)&#123;for(;t.t&lt;=this.mt2;)t[t.t++]=0;for(var e=0;e&lt;this.m.t;++e)&#123;var i=32767&amp;t[e],r=i*this.mpl+((i*this.mph+(t[e]&gt;&gt;15)*this.mpl&amp;this.um)&lt;&lt;15)&amp;t.DM;for(i=e+this.m.t,t[i]+=this.m.am(0,r,t,e,0,this.m.t);t[i]&gt;=t.DV;)t[i]-=t.DV,t[++i]++&#125;t.clamp(),t.drShiftTo(this.m.t,t),t.compareTo(this.m)&gt;=0&amp;&amp;t.subTo(this.m,t)&#125;function C(t,e)&#123;t.squareTo(e),this.reduce(e)&#125;function H(t,e,i)&#123;t.multiplyTo(e,i),this.reduce(i)&#125;function j()&#123;return 0==(this.t&gt;0?1&amp;this[0]:this.s)&#125;function k(t,r)&#123;if(t&gt;4294967295||1&gt;t)return e.ONE;var s=i(),n=i(),o=r.convert(this),h=y(t)-1;for(o.copyTo(s);--h&gt;=0;)if(r.sqrTo(s,n),(t&amp;1&lt;&lt;h)&gt;0)r.mulTo(n,o,s);else&#123;var a=s;s=n,n=a&#125;return r.revert(s)&#125;function F(t,e)&#123;var i;return i=256&gt;t||e.isEven()?new A(e):new P(e),this.exp(t,i)&#125;// Copyright (c) 2005-2009 Tom Wu// All Rights Reserved.// See &quot;LICENSE&quot; for details.function _()&#123;var t=i();return this.copyTo(t),t&#125;function z()&#123;if(this.s&lt;0)&#123;if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1&#125;else&#123;if(1==this.t)return this[0];if(0==this.t)return 0&#125;return(this[1]&amp;(1&lt;&lt;32-this.DB)-1)&lt;&lt;this.DB|this[0]&#125;function Z()&#123;return 0==this.t?this.s:this[0]&lt;&lt;24&gt;&gt;24&#125;function G()&#123;return 0==this.t?this.s:this[0]&lt;&lt;16&gt;&gt;16&#125;function $(t)&#123;return Math.floor(Math.LN2*this.DB/Math.log(t))&#125;function Y()&#123;return this.s&lt;0?-1:this.t&lt;=0||1==this.t&amp;&amp;this[0]&lt;=0?0:1&#125;function W(t)&#123;if(null==t&amp;&amp;(t=10),0==this.signum()||2&gt;t||t&gt;36)return&quot;0&quot;;var e=this.chunkSize(t),r=Math.pow(t,e),s=c(r),n=i(),o=i(),h=&quot;&quot;;for(this.divRemTo(s,n,o);n.signum()&gt;0;)h=(r+o.intValue()).toString(t).substr(1)+h,n.divRemTo(s,n,o);return o.intValue().toString(t)+h&#125;function Q(t,i)&#123;this.fromInt(0),null==i&amp;&amp;(i=10);for(var r=this.chunkSize(i),s=Math.pow(i,r),n=!1,o=0,a=0,u=0;u&lt;t.length;++u)&#123;var c=h(t,u);0&gt;c?&quot;-&quot;==t.charAt(u)&amp;&amp;0==this.signum()&amp;&amp;(n=!0):(a=i*a+c,++o&gt;=r&amp;&amp;(this.dMultiply(s),this.dAddOffset(a,0),o=0,a=0))&#125;o&gt;0&amp;&amp;(this.dMultiply(Math.pow(i,o)),this.dAddOffset(a,0)),n&amp;&amp;e.ZERO.subTo(this,this)&#125;function X(t,i,r)&#123;if(&quot;number&quot;==typeof i)if(2&gt;t)this.fromInt(1);else for(this.fromNumber(t,r),this.testBit(t-1)||this.bitwiseTo(e.ONE.shiftLeft(t-1),ht,this),this.isEven()&amp;&amp;this.dAddOffset(1,0);!this.isProbablePrime(i);)this.dAddOffset(2,0),this.bitLength()&gt;t&amp;&amp;this.subTo(e.ONE.shiftLeft(t-1),this);else&#123;var s=new Array,n=7&amp;t;s.length=(t&gt;&gt;3)+1,i.nextBytes(s),n&gt;0?s[0]&amp;=(1&lt;&lt;n)-1:s[0]=0,this.fromString(s,256)&#125;&#125;function tt()&#123;var t=this.t,e=new Array;e[0]=this.s;var i,r=this.DB-t*this.DB%8,s=0;if(t-- &gt;0)for(r&lt;this.DB&amp;&amp;(i=this[t]&gt;&gt;r)!=(this.s&amp;this.DM)&gt;&gt;r&amp;&amp;(e[s++]=i|this.s&lt;&lt;this.DB-r);t&gt;=0;)8&gt;r?(i=(this[t]&amp;(1&lt;&lt;r)-1)&lt;&lt;8-r,i|=this[--t]&gt;&gt;(r+=this.DB-8)):(i=this[t]&gt;&gt;(r-=8)&amp;255,0&gt;=r&amp;&amp;(r+=this.DB,--t)),0!=(128&amp;i)&amp;&amp;(i|=-256),0==s&amp;&amp;(128&amp;this.s)!=(128&amp;i)&amp;&amp;++s,(s&gt;0||i!=this.s)&amp;&amp;(e[s++]=i);return e&#125;function et(t)&#123;return 0==this.compareTo(t)&#125;function it(t)&#123;return this.compareTo(t)&lt;0?this:t&#125;function rt(t)&#123;return this.compareTo(t)&gt;0?this:t&#125;function st(t,e,i)&#123;var r,s,n=Math.min(t.t,this.t);for(r=0;n&gt;r;++r)i[r]=e(this[r],t[r]);if(t.t&lt;this.t)&#123;for(s=t.s&amp;this.DM,r=n;r&lt;this.t;++r)i[r]=e(this[r],s);i.t=this.t&#125;else&#123;for(s=this.s&amp;this.DM,r=n;r&lt;t.t;++r)i[r]=e(s,t[r]);i.t=t.t&#125;i.s=e(this.s,t.s),i.clamp()&#125;function nt(t,e)&#123;return t&amp;e&#125;function ot(t)&#123;var e=i();return this.bitwiseTo(t,nt,e),e&#125;function ht(t,e)&#123;return t|e&#125;function at(t)&#123;var e=i();return this.bitwiseTo(t,ht,e),e&#125;function ut(t,e)&#123;return t^e&#125;function ct(t)&#123;var e=i();return this.bitwiseTo(t,ut,e),e&#125;function ft(t,e)&#123;return t&amp;~e&#125;function pt(t)&#123;var e=i();return this.bitwiseTo(t,ft,e),e&#125;function lt()&#123;for(var t=i(),e=0;e&lt;this.t;++e)t[e]=this.DM&amp;~this[e];return t.t=this.t,t.s=~this.s,t&#125;function dt(t)&#123;var e=i();return 0&gt;t?this.rShiftTo(-t,e):this.lShiftTo(t,e),e&#125;function gt(t)&#123;var e=i();return 0&gt;t?this.lShiftTo(-t,e):this.rShiftTo(t,e),e&#125;function mt(t)&#123;if(0==t)return-1;var e=0;return 0==(65535&amp;t)&amp;&amp;(t&gt;&gt;=16,e+=16),0==(255&amp;t)&amp;&amp;(t&gt;&gt;=8,e+=8),0==(15&amp;t)&amp;&amp;(t&gt;&gt;=4,e+=4),0==(3&amp;t)&amp;&amp;(t&gt;&gt;=2,e+=2),0==(1&amp;t)&amp;&amp;++e,e&#125;function yt()&#123;for(var t=0;t&lt;this.t;++t)if(0!=this[t])return t*this.DB+mt(this[t]);return this.s&lt;0?this.t*this.DB:-1&#125;function vt(t)&#123;for(var e=0;0!=t;)t&amp;=t-1,++e;return e&#125;function bt()&#123;for(var t=0,e=this.s&amp;this.DM,i=0;i&lt;this.t;++i)t+=vt(this[i]^e);return t&#125;function Tt(t)&#123;var e=Math.floor(t/this.DB);return e&gt;=this.t?0!=this.s:0!=(this[e]&amp;1&lt;&lt;t%this.DB)&#125;function St(t,i)&#123;var r=e.ONE.shiftLeft(t);return this.bitwiseTo(r,i,r),r&#125;function Rt(t)&#123;return this.changeBit(t,ht)&#125;function Et(t)&#123;return this.changeBit(t,ft)&#125;function Dt(t)&#123;return this.changeBit(t,ut)&#125;function wt(t,e)&#123;for(var i=0,r=0,s=Math.min(t.t,this.t);s&gt;i;)r+=this[i]+t[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;if(t.t&lt;this.t)&#123;for(r+=t.s;i&lt;this.t;)r+=this[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;r+=this.s&#125;else&#123;for(r+=this.s;i&lt;t.t;)r+=t[i],e[i++]=r&amp;this.DM,r&gt;&gt;=this.DB;r+=t.s&#125;e.s=0&gt;r?-1:0,r&gt;0?e[i++]=r:-1&gt;r&amp;&amp;(e[i++]=this.DV+r),e.t=i,e.clamp()&#125;function xt(t)&#123;var e=i();return this.addTo(t,e),e&#125;function Bt(t)&#123;var e=i();return this.subTo(t,e),e&#125;function Kt(t)&#123;var e=i();return this.multiplyTo(t,e),e&#125;function At()&#123;var t=i();return this.squareTo(t),t&#125;function Ut(t)&#123;var e=i();return this.divRemTo(t,e,null),e&#125;function Ot(t)&#123;var e=i();return this.divRemTo(t,null,e),e&#125;function Vt(t)&#123;var e=i(),r=i();return this.divRemTo(t,e,r),new Array(e,r)&#125;function Nt(t)&#123;this[this.t]=this.am(0,t-1,this,0,0,this.t),++this.t,this.clamp()&#125;function Jt(t,e)&#123;if(0!=t)&#123;for(;this.t&lt;=e;)this[this.t++]=0;for(this[e]+=t;this[e]&gt;=this.DV;)this[e]-=this.DV,++e&gt;=this.t&amp;&amp;(this[this.t++]=0),++this[e]&#125;&#125;function It()&#123;&#125;function Pt(t)&#123;return t&#125;function Mt(t,e,i)&#123;t.multiplyTo(e,i)&#125;function Lt(t,e)&#123;t.squareTo(e)&#125;function qt(t)&#123;return this.exp(t,new It)&#125;function Ct(t,e,i)&#123;var r=Math.min(this.t+t.t,e);for(i.s=0,i.t=r;r&gt;0;)i[--r]=0;var s;for(s=i.t-this.t;s&gt;r;++r)i[r+this.t]=this.am(0,t[r],i,r,0,this.t);for(s=Math.min(t.t,e);s&gt;r;++r)this.am(0,t[r],i,r,0,e-r);i.clamp()&#125;function Ht(t,e,i)&#123;--e;var r=i.t=this.t+t.t-e;for(i.s=0;--r&gt;=0;)i[r]=0;for(r=Math.max(e-this.t,0);r&lt;t.t;++r)i[this.t+r-e]=this.am(e-r,t[r],i,0,0,this.t+r-e);i.clamp(),i.drShiftTo(1,i)&#125;function jt(t)&#123;this.r2=i(),this.q3=i(),e.ONE.dlShiftTo(2*t.t,this.r2),this.mu=this.r2.divide(t),this.m=t&#125;function kt(t)&#123;if(t.s&lt;0||t.t&gt;2*this.m.t)return t.mod(this.m);if(t.compareTo(this.m)&lt;0)return t;var e=i();return t.copyTo(e),this.reduce(e),e&#125;function Ft(t)&#123;return t&#125;function _t(t)&#123;for(t.drShiftTo(this.m.t-1,this.r2),t.t&gt;this.m.t+1&amp;&amp;(t.t=this.m.t+1,t.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);t.compareTo(this.r2)&lt;0;)t.dAddOffset(1,this.m.t+1);for(t.subTo(this.r2,t);t.compareTo(this.m)&gt;=0;)t.subTo(this.m,t)&#125;function zt(t,e)&#123;t.squareTo(e),this.reduce(e)&#125;function Zt(t,e,i)&#123;t.multiplyTo(e,i),this.reduce(i)&#125;function Gt(t,e)&#123;var r,s,n=t.bitLength(),o=c(1);if(0&gt;=n)return o;r=18&gt;n?1:48&gt;n?3:144&gt;n?4:768&gt;n?5:6,s=8&gt;n?new A(e):e.isEven()?new jt(e):new P(e);var h=new Array,a=3,u=r-1,f=(1&lt;&lt;r)-1;if(h[1]=s.convert(this),r&gt;1)&#123;var p=i();for(s.sqrTo(h[1],p);f&gt;=a;)h[a]=i(),s.mulTo(p,h[a-2],h[a]),a+=2&#125;var l,d,g=t.t-1,m=!0,v=i();for(n=y(t[g])-1;g&gt;=0;)&#123;for(n&gt;=u?l=t[g]&gt;&gt;n-u&amp;f:(l=(t[g]&amp;(1&lt;&lt;n+1)-1)&lt;&lt;u-n,g&gt;0&amp;&amp;(l|=t[g-1]&gt;&gt;this.DB+n-u)),a=r;0==(1&amp;l);)l&gt;&gt;=1,--a;if((n-=a)&lt;0&amp;&amp;(n+=this.DB,--g),m)h[l].copyTo(o),m=!1;else&#123;for(;a&gt;1;)s.sqrTo(o,v),s.sqrTo(v,o),a-=2;a&gt;0?s.sqrTo(o,v):(d=o,o=v,v=d),s.mulTo(v,h[l],o)&#125;for(;g&gt;=0&amp;&amp;0==(t[g]&amp;1&lt;&lt;n);)s.sqrTo(o,v),d=o,o=v,v=d,--n&lt;0&amp;&amp;(n=this.DB-1,--g)&#125;return s.revert(o)&#125;function $t(t)&#123;var e=this.s&lt;0?this.negate():this.clone(),i=t.s&lt;0?t.negate():t.clone();if(e.compareTo(i)&lt;0)&#123;var r=e;e=i,i=r&#125;var s=e.getLowestSetBit(),n=i.getLowestSetBit();if(0&gt;n)return e;for(n&gt;s&amp;&amp;(n=s),n&gt;0&amp;&amp;(e.rShiftTo(n,e),i.rShiftTo(n,i));e.signum()&gt;0;)(s=e.getLowestSetBit())&gt;0&amp;&amp;e.rShiftTo(s,e),(s=i.getLowestSetBit())&gt;0&amp;&amp;i.rShiftTo(s,i),e.compareTo(i)&gt;=0?(e.subTo(i,e),e.rShiftTo(1,e)):(i.subTo(e,i),i.rShiftTo(1,i));return n&gt;0&amp;&amp;i.lShiftTo(n,i),i&#125;function Yt(t)&#123;if(0&gt;=t)return 0;var e=this.DV%t,i=this.s&lt;0?t-1:0;if(this.t&gt;0)if(0==e)i=this[0]%t;else for(var r=this.t-1;r&gt;=0;--r)i=(e*i+this[r])%t;return i&#125;function Wt(t)&#123;var i=t.isEven();if(this.isEven()&amp;&amp;i||0==t.signum())return e.ZERO;for(var r=t.clone(),s=this.clone(),n=c(1),o=c(0),h=c(0),a=c(1);0!=r.signum();)&#123;for(;r.isEven();)r.rShiftTo(1,r),i?(n.isEven()&amp;&amp;o.isEven()||(n.addTo(this,n),o.subTo(t,o)),n.rShiftTo(1,n)):o.isEven()||o.subTo(t,o),o.rShiftTo(1,o);for(;s.isEven();)s.rShiftTo(1,s),i?(h.isEven()&amp;&amp;a.isEven()||(h.addTo(this,h),a.subTo(t,a)),h.rShiftTo(1,h)):a.isEven()||a.subTo(t,a),a.rShiftTo(1,a);r.compareTo(s)&gt;=0?(r.subTo(s,r),i&amp;&amp;n.subTo(h,n),o.subTo(a,o)):(s.subTo(r,s),i&amp;&amp;h.subTo(n,h),a.subTo(o,a))&#125;return 0!=s.compareTo(e.ONE)?e.ZERO:a.compareTo(t)&gt;=0?a.subtract(t):a.signum()&lt;0?(a.addTo(t,a),a.signum()&lt;0?a.add(t):a):a&#125;function Qt(t)&#123;var e,i=this.abs();if(1==i.t&amp;&amp;i[0]&lt;=Ae[Ae.length-1])&#123;for(e=0;e&lt;Ae.length;++e)if(i[0]==Ae[e])return!0;return!1&#125;if(i.isEven())return!1;for(e=1;e&lt;Ae.length;)&#123;for(var r=Ae[e],s=e+1;s&lt;Ae.length&amp;&amp;Ue&gt;r;)r*=Ae[s++];for(r=i.modInt(r);s&gt;e;)if(r%Ae[e++]==0)return!1&#125;return i.millerRabin(t)&#125;function Xt(t)&#123;var r=this.subtract(e.ONE),s=r.getLowestSetBit();if(0&gt;=s)return!1;var n=r.shiftRight(s);t=t+1&gt;&gt;1,t&gt;Ae.length&amp;&amp;(t=Ae.length);for(var o=i(),h=0;t&gt;h;++h)&#123;o.fromInt(Ae[Math.floor(Math.random()*Ae.length)]);var a=o.modPow(n,this);if(0!=a.compareTo(e.ONE)&amp;&amp;0!=a.compareTo(r))&#123;for(var u=1;u++&lt;s&amp;&amp;0!=a.compareTo(r);)if(a=a.modPowInt(2,this),0==a.compareTo(e.ONE))return!1;if(0!=a.compareTo(r))return!1&#125;&#125;return!0&#125;function te()&#123;this.i=0,this.j=0,this.S=new Array&#125;function ee(t)&#123;var e,i,r;for(e=0;256&gt;e;++e)this.S[e]=e;for(i=0,e=0;256&gt;e;++e)i=i+this.S[e]+t[e%t.length]&amp;255,r=this.S[e],this.S[e]=this.S[i],this.S[i]=r;this.i=0,this.j=0&#125;function ie()&#123;var t;return this.i=this.i+1&amp;255,this.j=this.j+this.S[this.i]&amp;255,t=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=t,this.S[t+this.S[this.i]&amp;255]&#125;function re()&#123;return new te&#125;function se()&#123;if(null==Oe)&#123;for(Oe=re();Je&gt;Ne;)&#123;var t=Math.floor(65536*Math.random());Ve[Ne++]=255&amp;t&#125;for(Oe.init(Ve),Ne=0;Ne&lt;Ve.length;++Ne)Ve[Ne]=0;Ne=0&#125;return Oe.next()&#125;function ne(t)&#123;var e;for(e=0;e&lt;t.length;++e)t[e]=se()&#125;function oe()&#123;&#125;function he(t,i)&#123;return new e(t,i)&#125;function ae(t,i)&#123;if(i&lt;t.length+11)return console.error(&quot;Message too long for RSA&quot;),null;for(var r=new Array,s=t.length-1;s&gt;=0&amp;&amp;i&gt;0;)&#123;var n=t.charCodeAt(s--);128&gt;n?r[--i]=n:n&gt;127&amp;&amp;2048&gt;n?(r[--i]=63&amp;n|128,r[--i]=n&gt;&gt;6|192):(r[--i]=63&amp;n|128,r[--i]=n&gt;&gt;6&amp;63|128,r[--i]=n&gt;&gt;12|224)&#125;r[--i]=0;for(var o=new oe,h=new Array;i&gt;2;)&#123;for(h[0]=0;0==h[0];)o.nextBytes(h);r[--i]=h[0]&#125;return r[--i]=2,r[--i]=0,new e(r)&#125;function ue()&#123;this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null&#125;function ce(t,e)&#123;null!=t&amp;&amp;null!=e&amp;&amp;t.length&gt;0&amp;&amp;e.length&gt;0?(this.n=he(t,16),this.e=parseInt(e,16)):console.error(&quot;Invalid RSA public key&quot;)&#125;function fe(t)&#123;return t.modPowInt(this.e,this.n)&#125;function pe(t)&#123;var e=ae(t,this.n.bitLength()+7&gt;&gt;3);if(null==e)return null;var i=this.doPublic(e);if(null==i)return null;var r=i.toString(16);return 0==(1&amp;r.length)?r:&quot;0&quot;+r&#125;function le(t,e)&#123;for(var i=t.toByteArray(),r=0;r&lt;i.length&amp;&amp;0==i[r];)++r;if(i.length-r!=e-1||2!=i[r])return null;for(++r;0!=i[r];)if(++r&gt;=i.length)return null;for(var s=&quot;&quot;;++r&lt;i.length;)&#123;var n=255&amp;i[r];128&gt;n?s+=String.fromCharCode(n):n&gt;191&amp;&amp;224&gt;n?(s+=String.fromCharCode((31&amp;n)&lt;&lt;6|63&amp;i[r+1]),++r):(s+=String.fromCharCode((15&amp;n)&lt;&lt;12|(63&amp;i[r+1])&lt;&lt;6|63&amp;i[r+2]),r+=2)&#125;return s&#125;function de(t,e,i)&#123;null!=t&amp;&amp;null!=e&amp;&amp;t.length&gt;0&amp;&amp;e.length&gt;0?(this.n=he(t,16),this.e=parseInt(e,16),this.d=he(i,16)):console.error(&quot;Invalid RSA private key&quot;)&#125;function ge(t,e,i,r,s,n,o,h)&#123;null!=t&amp;&amp;null!=e&amp;&amp;t.length&gt;0&amp;&amp;e.length&gt;0?(this.n=he(t,16),this.e=parseInt(e,16),this.d=he(i,16),this.p=he(r,16),this.q=he(s,16),this.dmp1=he(n,16),this.dmq1=he(o,16),this.coeff=he(h,16)):console.error(&quot;Invalid RSA private key&quot;)&#125;function me(t,i)&#123;var r=new oe,s=t&gt;&gt;1;this.e=parseInt(i,16);for(var n=new e(i,16);;)&#123;for(;this.p=new e(t-s,1,r),0!=this.p.subtract(e.ONE).gcd(n).compareTo(e.ONE)||!this.p.isProbablePrime(10););for(;this.q=new e(s,1,r),0!=this.q.subtract(e.ONE).gcd(n).compareTo(e.ONE)||!this.q.isProbablePrime(10););if(this.p.compareTo(this.q)&lt;=0)&#123;var o=this.p;this.p=this.q,this.q=o&#125;var h=this.p.subtract(e.ONE),a=this.q.subtract(e.ONE),u=h.multiply(a);if(0==u.gcd(n).compareTo(e.ONE))&#123;this.n=this.p.multiply(this.q),this.d=n.modInverse(u),this.dmp1=this.d.mod(h),this.dmq1=this.d.mod(a),this.coeff=this.q.modInverse(this.p);break&#125;&#125;&#125;function ye(t)&#123;if(null==this.p||null==this.q)return t.modPow(this.d,this.n);for(var e=t.mod(this.p).modPow(this.dmp1,this.p),i=t.mod(this.q).modPow(this.dmq1,this.q);e.compareTo(i)&lt;0;)e=e.add(this.p);return e.subtract(i).multiply(this.coeff).mod(this.p).multiply(this.q).add(i)&#125;function ve(t)&#123;var e=he(t,16),i=this.doPrivate(e);return null==i?null:le(i,this.n.bitLength()+7&gt;&gt;3)&#125;function be(t)&#123;var e,i,r=&quot;&quot;;for(e=0;e+3&lt;=t.length;e+=3)i=parseInt(t.substring(e,e+3),16),r+=Le.charAt(i&gt;&gt;6)+Le.charAt(63&amp;i);for(e+1==t.length?(i=parseInt(t.substring(e,e+1),16),r+=Le.charAt(i&lt;&lt;2)):e+2==t.length&amp;&amp;(i=parseInt(t.substring(e,e+2),16),r+=Le.charAt(i&gt;&gt;2)+Le.charAt((3&amp;i)&lt;&lt;4));(3&amp;r.length)&gt;0;)r+=qe;return r&#125;function Te(t)&#123;var e,i,r=&quot;&quot;,s=0;for(e=0;e&lt;t.length&amp;&amp;t.charAt(e)!=qe;++e)v=Le.indexOf(t.charAt(e)),v&lt;0||(0==s?(r+=o(v&gt;&gt;2),i=3&amp;v,s=1):1==s?(r+=o(i&lt;&lt;2|v&gt;&gt;4),i=15&amp;v,s=2):2==s?(r+=o(i),r+=o(v&gt;&gt;2),i=3&amp;v,s=3):(r+=o(i&lt;&lt;2|v&gt;&gt;4),r+=o(15&amp;v),s=0));return 1==s&amp;&amp;(r+=o(i&lt;&lt;2)),r&#125;// Copyright (c) 2005 Tom Wu// All Rights Reserved.// See &quot;LICENSE&quot; for details.var Se,Re=0xdeadbeefcafe,Ee=15715070==(16777215&amp;Re);Ee&amp;&amp;&quot;Microsoft Internet Explorer&quot;==navigator.appName?(e.prototype.am=s,Se=30):Ee&amp;&amp;&quot;Netscape&quot;!=navigator.appName?(e.prototype.am=r,Se=26):(e.prototype.am=n,Se=28),e.prototype.DB=Se,e.prototype.DM=(1&lt;&lt;Se)-1,e.prototype.DV=1&lt;&lt;Se;var De=52;e.prototype.FV=Math.pow(2,De),e.prototype.F1=De-Se,e.prototype.F2=2*Se-De;var we,xe,Be=&quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;,Ke=new Array;for(we=&quot;0&quot;.charCodeAt(0),xe=0;9&gt;=xe;++xe)Ke[we++]=xe;for(we=&quot;a&quot;.charCodeAt(0),xe=10;36&gt;xe;++xe)Ke[we++]=xe;for(we=&quot;A&quot;.charCodeAt(0),xe=10;36&gt;xe;++xe)Ke[we++]=xe;A.prototype.convert=U,A.prototype.revert=O,A.prototype.reduce=V,A.prototype.mulTo=N,A.prototype.sqrTo=J,P.prototype.convert=M,P.prototype.revert=L,P.prototype.reduce=q,P.prototype.mulTo=H,P.prototype.sqrTo=C,e.prototype.copyTo=a,e.prototype.fromInt=u,e.prototype.fromString=f,e.prototype.clamp=p,e.prototype.dlShiftTo=T,e.prototype.drShiftTo=S,e.prototype.lShiftTo=R,e.prototype.rShiftTo=E,e.prototype.subTo=D,e.prototype.multiplyTo=w,e.prototype.squareTo=x,e.prototype.divRemTo=B,e.prototype.invDigit=I,e.prototype.isEven=j,e.prototype.exp=k,e.prototype.toString=l,e.prototype.negate=d,e.prototype.abs=g,e.prototype.compareTo=m,e.prototype.bitLength=b,e.prototype.mod=K,e.prototype.modPowInt=F,e.ZERO=c(0),e.ONE=c(1),It.prototype.convert=Pt,It.prototype.revert=Pt,It.prototype.mulTo=Mt,It.prototype.sqrTo=Lt,jt.prototype.convert=kt,jt.prototype.revert=Ft,jt.prototype.reduce=_t,jt.prototype.mulTo=Zt,jt.prototype.sqrTo=zt;var Ae=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],Ue=(1&lt;&lt;26)/Ae[Ae.length-1];e.prototype.chunkSize=$,e.prototype.toRadix=W,e.prototype.fromRadix=Q,e.prototype.fromNumber=X,e.prototype.bitwiseTo=st,e.prototype.changeBit=St,e.prototype.addTo=wt,e.prototype.dMultiply=Nt,e.prototype.dAddOffset=Jt,e.prototype.multiplyLowerTo=Ct,e.prototype.multiplyUpperTo=Ht,e.prototype.modInt=Yt,e.prototype.millerRabin=Xt,e.prototype.clone=_,e.prototype.intValue=z,e.prototype.byteValue=Z,e.prototype.shortValue=G,e.prototype.signum=Y,e.prototype.toByteArray=tt,e.prototype.equals=et,e.prototype.min=it,e.prototype.max=rt,e.prototype.and=ot,e.prototype.or=at,e.prototype.xor=ct,e.prototype.andNot=pt,e.prototype.not=lt,e.prototype.shiftLeft=dt,e.prototype.shiftRight=gt,e.prototype.getLowestSetBit=yt,e.prototype.bitCount=bt,e.prototype.testBit=Tt,e.prototype.setBit=Rt,e.prototype.clearBit=Et,e.prototype.flipBit=Dt,e.prototype.add=xt,e.prototype.subtract=Bt,e.prototype.multiply=Kt,e.prototype.divide=Ut,e.prototype.remainder=Ot,e.prototype.divideAndRemainder=Vt,e.prototype.modPow=Gt,e.prototype.modInverse=Wt,e.prototype.pow=qt,e.prototype.gcd=$t,e.prototype.isProbablePrime=Qt,e.prototype.square=At,te.prototype.init=ee,te.prototype.next=ie;var Oe,Ve,Ne,Je=256;if(null==Ve)&#123;Ve=new Array,Ne=0;var Ie;if(window.crypto&amp;&amp;window.crypto.getRandomValues)&#123;var Pe=new Uint32Array(256);for(window.crypto.getRandomValues(Pe),Ie=0;Ie&lt;Pe.length;++Ie)Ve[Ne++]=255&amp;Pe[Ie]&#125;var Me=function(t)&#123;if(this.count=this.count||0,this.count&gt;=256||Ne&gt;=Je)return void(window.removeEventListener?window.removeEventListener(&quot;mousemove&quot;,Me,!1):window.detachEvent&amp;&amp;window.detachEvent(&quot;onmousemove&quot;,Me));try&#123;var e=t.x+t.y;Ve[Ne++]=255&amp;e,this.count+=1&#125;catch(i)&#123;&#125;&#125;;window.addEventListener?window.addEventListener(&quot;mousemove&quot;,Me,!1):window.attachEvent&amp;&amp;window.attachEvent(&quot;onmousemove&quot;,Me)&#125;oe.prototype.nextBytes=ne,ue.prototype.doPublic=fe,ue.prototype.setPublic=ce,ue.prototype.encrypt=pe,ue.prototype.doPrivate=ye,ue.prototype.setPrivate=de,ue.prototype.setPrivateEx=ge,ue.prototype.generate=me,ue.prototype.decrypt=ve,// Copyright (c) 2011 Kevin M Burns Jr.// All Rights Reserved.// See &quot;LICENSE&quot; for details.//// Extension to jsbn which adds facilities for asynchronous RSA key generation// Primarily created to avoid execution timeout on mobile devices//// http://www-cs-students.stanford.edu/~tjw/jsbn///// ---function()&#123;var t=function(t,r,s)&#123;var n=new oe,o=t&gt;&gt;1;this.e=parseInt(r,16);var h=new e(r,16),a=this,u=function()&#123;var r=function()&#123;if(a.p.compareTo(a.q)&lt;=0)&#123;var t=a.p;a.p=a.q,a.q=t&#125;var i=a.p.subtract(e.ONE),r=a.q.subtract(e.ONE),n=i.multiply(r);0==n.gcd(h).compareTo(e.ONE)?(a.n=a.p.multiply(a.q),a.d=h.modInverse(n),a.dmp1=a.d.mod(i),a.dmq1=a.d.mod(r),a.coeff=a.q.modInverse(a.p),setTimeout(function()&#123;s()&#125;,0)):setTimeout(u,0)&#125;,c=function()&#123;a.q=i(),a.q.fromNumberAsync(o,1,n,function()&#123;a.q.subtract(e.ONE).gcda(h,function(t)&#123;0==t.compareTo(e.ONE)&amp;&amp;a.q.isProbablePrime(10)?setTimeout(r,0):setTimeout(c,0)&#125;)&#125;)&#125;,f=function()&#123;a.p=i(),a.p.fromNumberAsync(t-o,1,n,function()&#123;a.p.subtract(e.ONE).gcda(h,function(t)&#123;0==t.compareTo(e.ONE)&amp;&amp;a.p.isProbablePrime(10)?setTimeout(c,0):setTimeout(f,0)&#125;)&#125;)&#125;;setTimeout(f,0)&#125;;setTimeout(u,0)&#125;;ue.prototype.generateAsync=t;var r=function(t,e)&#123;var i=this.s&lt;0?this.negate():this.clone(),r=t.s&lt;0?t.negate():t.clone();if(i.compareTo(r)&lt;0)&#123;var s=i;i=r,r=s&#125;var n=i.getLowestSetBit(),o=r.getLowestSetBit();if(0&gt;o)return void e(i);o&gt;n&amp;&amp;(o=n),o&gt;0&amp;&amp;(i.rShiftTo(o,i),r.rShiftTo(o,r));var h=function()&#123;(n=i.getLowestSetBit())&gt;0&amp;&amp;i.rShiftTo(n,i),(n=r.getLowestSetBit())&gt;0&amp;&amp;r.rShiftTo(n,r),i.compareTo(r)&gt;=0?(i.subTo(r,i),i.rShiftTo(1,i)):(r.subTo(i,r),r.rShiftTo(1,r)),i.signum()&gt;0?setTimeout(h,0):(o&gt;0&amp;&amp;r.lShiftTo(o,r),setTimeout(function()&#123;e(r)&#125;,0))&#125;;setTimeout(h,10)&#125;;e.prototype.gcda=r;var s=function(t,i,r,s)&#123;if(&quot;number&quot;==typeof i)if(2&gt;t)this.fromInt(1);else&#123;this.fromNumber(t,r),this.testBit(t-1)||this.bitwiseTo(e.ONE.shiftLeft(t-1),ht,this),this.isEven()&amp;&amp;this.dAddOffset(1,0);var n=this,o=function()&#123;n.dAddOffset(2,0),n.bitLength()&gt;t&amp;&amp;n.subTo(e.ONE.shiftLeft(t-1),n),n.isProbablePrime(i)?setTimeout(function()&#123;s()&#125;,0):setTimeout(o,0)&#125;;setTimeout(o,0)&#125;else&#123;var h=new Array,a=7&amp;t;h.length=(t&gt;&gt;3)+1,i.nextBytes(h),a&gt;0?h[0]&amp;=(1&lt;&lt;a)-1:h[0]=0,this.fromString(h,256)&#125;&#125;;e.prototype.fromNumberAsync=s&#125;();var Le=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,qe=&quot;=&quot;,Ce=Ce||&#123;&#125;;Ce.env=Ce.env||&#123;&#125;;var He=Ce,je=Object.prototype,ke=&quot;[object Function]&quot;,Fe=[&quot;toString&quot;,&quot;valueOf&quot;];Ce.env.parseUA=function(t)&#123;var e,i=function(t)&#123;var e=0;return parseFloat(t.replace(/\./g,function()&#123;return 1==e++?&quot;&quot;:&quot;.&quot;&#125;))&#125;,r=navigator,s=&#123;ie:0,opera:0,gecko:0,webkit:0,chrome:0,mobile:null,air:0,ipad:0,iphone:0,ipod:0,ios:null,android:0,webos:0,caja:r&amp;&amp;r.cajaVersion,secure:!1,os:null&#125;,n=t||navigator&amp;&amp;navigator.userAgent,o=window&amp;&amp;window.location,h=o&amp;&amp;o.href;return s.secure=h&amp;&amp;0===h.toLowerCase().indexOf(&quot;https&quot;),n&amp;&amp;(/windows|win32/i.test(n)?s.os=&quot;windows&quot;:/macintosh/i.test(n)?s.os=&quot;macintosh&quot;:/rhino/i.test(n)&amp;&amp;(s.os=&quot;rhino&quot;),/KHTML/.test(n)&amp;&amp;(s.webkit=1),e=n.match(/AppleWebKit\/([^\s]*)/),e&amp;&amp;e[1]&amp;&amp;(s.webkit=i(e[1]),/ Mobile\//.test(n)?(s.mobile=&quot;Apple&quot;,e=n.match(/OS ([^\s]*)/),e&amp;&amp;e[1]&amp;&amp;(e=i(e[1].replace(&quot;_&quot;,&quot;.&quot;))),s.ios=e,s.ipad=s.ipod=s.iphone=0,e=n.match(/iPad|iPod|iPhone/),e&amp;&amp;e[0]&amp;&amp;(s[e[0].toLowerCase()]=s.ios)):(e=n.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/),e&amp;&amp;(s.mobile=e[0]),/webOS/.test(n)&amp;&amp;(s.mobile=&quot;WebOS&quot;,e=n.match(/webOS\/([^\s]*);/),e&amp;&amp;e[1]&amp;&amp;(s.webos=i(e[1]))),/ Android/.test(n)&amp;&amp;(s.mobile=&quot;Android&quot;,e=n.match(/Android ([^\s]*);/),e&amp;&amp;e[1]&amp;&amp;(s.android=i(e[1])))),e=n.match(/Chrome\/([^\s]*)/),e&amp;&amp;e[1]?s.chrome=i(e[1]):(e=n.match(/AdobeAIR\/([^\s]*)/),e&amp;&amp;(s.air=e[0]))),s.webkit||(e=n.match(/Opera[\s\/]([^\s]*)/),e&amp;&amp;e[1]?(s.opera=i(e[1]),e=n.match(/Version\/([^\s]*)/),e&amp;&amp;e[1]&amp;&amp;(s.opera=i(e[1])),e=n.match(/Opera Mini[^;]*/),e&amp;&amp;(s.mobile=e[0])):(e=n.match(/MSIE\s([^;]*)/),e&amp;&amp;e[1]?s.ie=i(e[1]):(e=n.match(/Gecko\/([^\s]*)/),e&amp;&amp;(s.gecko=1,e=n.match(/rv:([^\s\)]*)/),e&amp;&amp;e[1]&amp;&amp;(s.gecko=i(e[1]))))))),s&#125;,Ce.env.ua=Ce.env.parseUA(),Ce.isFunction=function(t)&#123;return&quot;function&quot;==typeof t||je.toString.apply(t)===ke&#125;,Ce._IEEnumFix=Ce.env.ua.ie?function(t,e)&#123;var i,r,s;for(i=0;i&lt;Fe.length;i+=1)r=Fe[i],s=e[r],He.isFunction(s)&amp;&amp;s!=je[r]&amp;&amp;(t[r]=s)&#125;:function()&#123;&#125;,Ce.extend=function(t,e,i)&#123;if(!e||!t)throw new Error(&quot;extend failed, please check that all dependencies are included.&quot;);var r,s=function()&#123;&#125;;if(s.prototype=e.prototype,t.prototype=new s,t.prototype.constructor=t,t.superclass=e.prototype,e.prototype.constructor==je.constructor&amp;&amp;(e.prototype.constructor=e),i)&#123;for(r in i)He.hasOwnProperty(i,r)&amp;&amp;(t.prototype[r]=i[r]);He._IEEnumFix(t.prototype,i)&#125;&#125;,/* * asn1.js - ASN.1 DER encoder classes * * Copyright (c) 2013 Kenji Urushima (kenji.urushima@gmail.com) * * This software is licensed under the terms of the MIT License. * http://kjur.github.com/jsrsasign/license * * The above copyright and license notice shall be * included in all copies or substantial portions of the Software. *//** * @fileOverview * @name asn1-1.0.js * @author Kenji Urushima kenji.urushima@gmail.com * @version 1.0.2 (2013-May-30) * @since 2.1 * @license &lt;a href=&quot;http://kjur.github.io/jsrsasign/license/&quot;&gt;MIT License&lt;/a&gt; */&quot;undefined&quot;!=typeof KJUR&amp;&amp;KJUR||(KJUR=&#123;&#125;),&quot;undefined&quot;!=typeof KJUR.asn1&amp;&amp;KJUR.asn1||(KJUR.asn1=&#123;&#125;),KJUR.asn1.ASN1Util=new function()&#123;this.integerToByteHex=function(t)&#123;var e=t.toString(16);return e.length%2==1&amp;&amp;(e=&quot;0&quot;+e),e&#125;,this.bigIntToMinTwosComplementsHex=function(t)&#123;var i=t.toString(16);if(&quot;-&quot;!=i.substr(0,1))i.length%2==1?i=&quot;0&quot;+i:i.match(/^[0-7]/)||(i=&quot;00&quot;+i);else&#123;var r=i.substr(1),s=r.length;s%2==1?s+=1:i.match(/^[0-7]/)||(s+=2);for(var n=&quot;&quot;,o=0;s&gt;o;o++)n+=&quot;f&quot;;var h=new e(n,16),a=h.xor(t).add(e.ONE);i=a.toString(16).replace(/^-/,&quot;&quot;)&#125;return i&#125;,this.getPEMStringFromHex=function(t,e)&#123;var i=CryptoJS.enc.Hex.parse(t),r=CryptoJS.enc.Base64.stringify(i),s=r.replace(/(.&#123;64&#125;)/g,&quot;$1\r\n&quot;);return s=s.replace(/\r\n$/,&quot;&quot;),&quot;-----BEGIN &quot;+e+&quot;-----\r\n&quot;+s+&quot;\r\n-----END &quot;+e+&quot;-----\r\n&quot;&#125;&#125;,KJUR.asn1.ASN1Object=function()&#123;var t=&quot;&quot;;this.getLengthHexFromValue=function()&#123;if(&quot;undefined&quot;==typeof this.hV||null==this.hV)throw&quot;this.hV is null or undefined.&quot;;if(this.hV.length%2==1)throw&quot;value hex must be even length: n=&quot;+t.length+&quot;,v=&quot;+this.hV;var e=this.hV.length/2,i=e.toString(16);if(i.length%2==1&amp;&amp;(i=&quot;0&quot;+i),128&gt;e)return i;var r=i.length/2;if(r&gt;15)throw&quot;ASN.1 length too long to represent by 8x: n = &quot;+e.toString(16);var s=128+r;return s.toString(16)+i&#125;,this.getEncodedHex=function()&#123;return(null==this.hTLV||this.isModified)&amp;&amp;(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV&#125;,this.getValueHex=function()&#123;return this.getEncodedHex(),this.hV&#125;,this.getFreshValueHex=function()&#123;return&quot;&quot;&#125;&#125;,KJUR.asn1.DERAbstractString=function(t)&#123;KJUR.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function()&#123;return this.s&#125;,this.setString=function(t)&#123;this.hTLV=null,this.isModified=!0,this.s=t,this.hV=stohex(this.s)&#125;,this.setStringHex=function(t)&#123;this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.str?this.setString(t.str):&quot;undefined&quot;!=typeof t.hex&amp;&amp;this.setStringHex(t.hex))&#125;,Ce.extend(KJUR.asn1.DERAbstractString,KJUR.asn1.ASN1Object),KJUR.asn1.DERAbstractTime=function(t)&#123;KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(t)&#123;utc=t.getTime()+6e4*t.getTimezoneOffset();var e=new Date(utc);return e&#125;,this.formatDate=function(t,e)&#123;var i=this.zeroPadding,r=this.localDateToUTC(t),s=String(r.getFullYear());&quot;utc&quot;==e&amp;&amp;(s=s.substr(2,2));var n=i(String(r.getMonth()+1),2),o=i(String(r.getDate()),2),h=i(String(r.getHours()),2),a=i(String(r.getMinutes()),2),u=i(String(r.getSeconds()),2);return s+n+o+h+a+u+&quot;Z&quot;&#125;,this.zeroPadding=function(t,e)&#123;return t.length&gt;=e?t:new Array(e-t.length+1).join(&quot;0&quot;)+t&#125;,this.getString=function()&#123;return this.s&#125;,this.setString=function(t)&#123;this.hTLV=null,this.isModified=!0,this.s=t,this.hV=stohex(this.s)&#125;,this.setByDateValue=function(t,e,i,r,s,n)&#123;var o=new Date(Date.UTC(t,e-1,i,r,s,n,0));this.setByDate(o)&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;&#125;,Ce.extend(KJUR.asn1.DERAbstractTime,KJUR.asn1.ASN1Object),KJUR.asn1.DERAbstractStructured=function(t)&#123;KJUR.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(t)&#123;this.hTLV=null,this.isModified=!0,this.asn1Array=t&#125;,this.appendASN1Object=function(t)&#123;this.hTLV=null,this.isModified=!0,this.asn1Array.push(t)&#125;,this.asn1Array=new Array,&quot;undefined&quot;!=typeof t&amp;&amp;&quot;undefined&quot;!=typeof t.array&amp;&amp;(this.asn1Array=t.array)&#125;,Ce.extend(KJUR.asn1.DERAbstractStructured,KJUR.asn1.ASN1Object),KJUR.asn1.DERBoolean=function()&#123;KJUR.asn1.DERBoolean.superclass.constructor.call(this),this.hT=&quot;01&quot;,this.hTLV=&quot;0101ff&quot;&#125;,Ce.extend(KJUR.asn1.DERBoolean,KJUR.asn1.ASN1Object),KJUR.asn1.DERInteger=function(t)&#123;KJUR.asn1.DERInteger.superclass.constructor.call(this),this.hT=&quot;02&quot;,this.setByBigInteger=function(t)&#123;this.hTLV=null,this.isModified=!0,this.hV=KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(t)&#125;,this.setByInteger=function(t)&#123;var i=new e(String(t),10);this.setByBigInteger(i)&#125;,this.setValueHex=function(t)&#123;this.hV=t&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.bigint?this.setByBigInteger(t.bigint):&quot;undefined&quot;!=typeof t[&quot;int&quot;]?this.setByInteger(t[&quot;int&quot;]):&quot;undefined&quot;!=typeof t.hex&amp;&amp;this.setValueHex(t.hex))&#125;,Ce.extend(KJUR.asn1.DERInteger,KJUR.asn1.ASN1Object),KJUR.asn1.DERBitString=function(t)&#123;KJUR.asn1.DERBitString.superclass.constructor.call(this),this.hT=&quot;03&quot;,this.setHexValueIncludingUnusedBits=function(t)&#123;this.hTLV=null,this.isModified=!0,this.hV=t&#125;,this.setUnusedBitsAndHexValue=function(t,e)&#123;if(0&gt;t||t&gt;7)throw&quot;unused bits shall be from 0 to 7: u = &quot;+t;var i=&quot;0&quot;+t;this.hTLV=null,this.isModified=!0,this.hV=i+e&#125;,this.setByBinaryString=function(t)&#123;t=t.replace(/0+$/,&quot;&quot;);var e=8-t.length%8;8==e&amp;&amp;(e=0);for(var i=0;e&gt;=i;i++)t+=&quot;0&quot;;for(var r=&quot;&quot;,i=0;i&lt;t.length-1;i+=8)&#123;var s=t.substr(i,8),n=parseInt(s,2).toString(16);1==n.length&amp;&amp;(n=&quot;0&quot;+n),r+=n&#125;this.hTLV=null,this.isModified=!0,this.hV=&quot;0&quot;+e+r&#125;,this.setByBooleanArray=function(t)&#123;for(var e=&quot;&quot;,i=0;i&lt;t.length;i++)e+=1==t[i]?&quot;1&quot;:&quot;0&quot;;this.setByBinaryString(e)&#125;,this.newFalseArray=function(t)&#123;for(var e=new Array(t),i=0;t&gt;i;i++)e[i]=!1;return e&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.hex?this.setHexValueIncludingUnusedBits(t.hex):&quot;undefined&quot;!=typeof t.bin?this.setByBinaryString(t.bin):&quot;undefined&quot;!=typeof t.array&amp;&amp;this.setByBooleanArray(t.array))&#125;,Ce.extend(KJUR.asn1.DERBitString,KJUR.asn1.ASN1Object),KJUR.asn1.DEROctetString=function(t)&#123;KJUR.asn1.DEROctetString.superclass.constructor.call(this,t),this.hT=&quot;04&quot;&#125;,Ce.extend(KJUR.asn1.DEROctetString,KJUR.asn1.DERAbstractString),KJUR.asn1.DERNull=function()&#123;KJUR.asn1.DERNull.superclass.constructor.call(this),this.hT=&quot;05&quot;,this.hTLV=&quot;0500&quot;&#125;,Ce.extend(KJUR.asn1.DERNull,KJUR.asn1.ASN1Object),KJUR.asn1.DERObjectIdentifier=function(t)&#123;var i=function(t)&#123;var e=t.toString(16);return 1==e.length&amp;&amp;(e=&quot;0&quot;+e),e&#125;,r=function(t)&#123;var r=&quot;&quot;,s=new e(t,10),n=s.toString(2),o=7-n.length%7;7==o&amp;&amp;(o=0);for(var h=&quot;&quot;,a=0;o&gt;a;a++)h+=&quot;0&quot;;n=h+n;for(var a=0;a&lt;n.length-1;a+=7)&#123;var u=n.substr(a,7);a!=n.length-7&amp;&amp;(u=&quot;1&quot;+u),r+=i(parseInt(u,2))&#125;return r&#125;;KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT=&quot;06&quot;,this.setValueHex=function(t)&#123;this.hTLV=null,this.isModified=!0,this.s=null,this.hV=t&#125;,this.setValueOidString=function(t)&#123;if(!t.match(/^[0-9.]+$/))throw&quot;malformed oid string: &quot;+t;var e=&quot;&quot;,s=t.split(&quot;.&quot;),n=40*parseInt(s[0])+parseInt(s[1]);e+=i(n),s.splice(0,2);for(var o=0;o&lt;s.length;o++)e+=r(s[o]);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e&#125;,this.setValueName=function(t)&#123;if(&quot;undefined&quot;==typeof KJUR.asn1.x509.OID.name2oidList[t])throw&quot;DERObjectIdentifier oidName undefined: &quot;+t;var e=KJUR.asn1.x509.OID.name2oidList[t];this.setValueOidString(e)&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.oid?this.setValueOidString(t.oid):&quot;undefined&quot;!=typeof t.hex?this.setValueHex(t.hex):&quot;undefined&quot;!=typeof t.name&amp;&amp;this.setValueName(t.name))&#125;,Ce.extend(KJUR.asn1.DERObjectIdentifier,KJUR.asn1.ASN1Object),KJUR.asn1.DERUTF8String=function(t)&#123;KJUR.asn1.DERUTF8String.superclass.constructor.call(this,t),this.hT=&quot;0c&quot;&#125;,Ce.extend(KJUR.asn1.DERUTF8String,KJUR.asn1.DERAbstractString),KJUR.asn1.DERNumericString=function(t)&#123;KJUR.asn1.DERNumericString.superclass.constructor.call(this,t),this.hT=&quot;12&quot;&#125;,Ce.extend(KJUR.asn1.DERNumericString,KJUR.asn1.DERAbstractString),KJUR.asn1.DERPrintableString=function(t)&#123;KJUR.asn1.DERPrintableString.superclass.constructor.call(this,t),this.hT=&quot;13&quot;&#125;,Ce.extend(KJUR.asn1.DERPrintableString,KJUR.asn1.DERAbstractString),KJUR.asn1.DERTeletexString=function(t)&#123;KJUR.asn1.DERTeletexString.superclass.constructor.call(this,t),this.hT=&quot;14&quot;&#125;,Ce.extend(KJUR.asn1.DERTeletexString,KJUR.asn1.DERAbstractString),KJUR.asn1.DERIA5String=function(t)&#123;KJUR.asn1.DERIA5String.superclass.constructor.call(this,t),this.hT=&quot;16&quot;&#125;,Ce.extend(KJUR.asn1.DERIA5String,KJUR.asn1.DERAbstractString),KJUR.asn1.DERUTCTime=function(t)&#123;KJUR.asn1.DERUTCTime.superclass.constructor.call(this,t),this.hT=&quot;17&quot;,this.setByDate=function(t)&#123;this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,&quot;utc&quot;),this.hV=stohex(this.s)&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.str?this.setString(t.str):&quot;undefined&quot;!=typeof t.hex?this.setStringHex(t.hex):&quot;undefined&quot;!=typeof t.date&amp;&amp;this.setByDate(t.date))&#125;,Ce.extend(KJUR.asn1.DERUTCTime,KJUR.asn1.DERAbstractTime),KJUR.asn1.DERGeneralizedTime=function(t)&#123;KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this,t),this.hT=&quot;18&quot;,this.setByDate=function(t)&#123;this.hTLV=null,this.isModified=!0,this.date=t,this.s=this.formatDate(this.date,&quot;gen&quot;),this.hV=stohex(this.s)&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.str?this.setString(t.str):&quot;undefined&quot;!=typeof t.hex?this.setStringHex(t.hex):&quot;undefined&quot;!=typeof t.date&amp;&amp;this.setByDate(t.date))&#125;,Ce.extend(KJUR.asn1.DERGeneralizedTime,KJUR.asn1.DERAbstractTime),KJUR.asn1.DERSequence=function(t)&#123;KJUR.asn1.DERSequence.superclass.constructor.call(this,t),this.hT=&quot;30&quot;,this.getFreshValueHex=function()&#123;for(var t=&quot;&quot;,e=0;e&lt;this.asn1Array.length;e++)&#123;var i=this.asn1Array[e];t+=i.getEncodedHex()&#125;return this.hV=t,this.hV&#125;&#125;,Ce.extend(KJUR.asn1.DERSequence,KJUR.asn1.DERAbstractStructured),KJUR.asn1.DERSet=function(t)&#123;KJUR.asn1.DERSet.superclass.constructor.call(this,t),this.hT=&quot;31&quot;,this.getFreshValueHex=function()&#123;for(var t=new Array,e=0;e&lt;this.asn1Array.length;e++)&#123;var i=this.asn1Array[e];t.push(i.getEncodedHex())&#125;return t.sort(),this.hV=t.join(&quot;&quot;),this.hV&#125;&#125;,Ce.extend(KJUR.asn1.DERSet,KJUR.asn1.DERAbstractStructured),KJUR.asn1.DERTaggedObject=function(t)&#123;KJUR.asn1.DERTaggedObject.superclass.constructor.call(this),this.hT=&quot;a0&quot;,this.hV=&quot;&quot;,this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(t,e,i)&#123;this.hT=e,this.isExplicit=t,this.asn1Object=i,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=i.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,e),this.isModified=!1)&#125;,this.getFreshValueHex=function()&#123;return this.hV&#125;,&quot;undefined&quot;!=typeof t&amp;&amp;(&quot;undefined&quot;!=typeof t.tag&amp;&amp;(this.hT=t.tag),&quot;undefined&quot;!=typeof t.explicit&amp;&amp;(this.isExplicit=t.explicit),&quot;undefined&quot;!=typeof t.obj&amp;&amp;(this.asn1Object=t.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)))&#125;,Ce.extend(KJUR.asn1.DERTaggedObject,KJUR.asn1.ASN1Object),// Copyright (c) 2008-2013 Lapo Luchini &lt;lapo@lapo.it&gt;// copyright notice and this permission notice appear in all copies.// // THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.function(t)&#123;&quot;use strict&quot;;var e,i=&#123;&#125;;i.decode=function(i)&#123;var r;if(e===t)&#123;var s=&quot;0123456789ABCDEF&quot;,n=&quot; \f\n\r \u2028\u2029&quot;;for(e=[],r=0;16&gt;r;++r)e[s.charAt(r)]=r;for(s=s.toLowerCase(),r=10;16&gt;r;++r)e[s.charAt(r)]=r;for(r=0;r&lt;n.length;++r)e[n.charAt(r)]=-1&#125;var o=[],h=0,a=0;for(r=0;r&lt;i.length;++r)&#123;var u=i.charAt(r);if(&quot;=&quot;==u)break;if(u=e[u],-1!=u)&#123;if(u===t)throw&quot;Illegal character at offset &quot;+r;h|=u,++a&gt;=2?(o[o.length]=h,h=0,a=0):h&lt;&lt;=4&#125;&#125;if(a)throw&quot;Hex encoding incomplete: 4 bits missing&quot;;return o&#125;,window.Hex=i&#125;(),// Copyright (c) 2008-2013 Lapo Luchini &lt;lapo@lapo.it&gt;// copyright notice and this permission notice appear in all copies.// // THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.function(t)&#123;&quot;use strict&quot;;var e,i=&#123;&#125;;i.decode=function(i)&#123;var r;if(e===t)&#123;var s=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,n=&quot;= \f\n\r \u2028\u2029&quot;;for(e=[],r=0;64&gt;r;++r)e[s.charAt(r)]=r;for(r=0;r&lt;n.length;++r)e[n.charAt(r)]=-1&#125;var o=[],h=0,a=0;for(r=0;r&lt;i.length;++r)&#123;var u=i.charAt(r);if(&quot;=&quot;==u)break;if(u=e[u],-1!=u)&#123;if(u===t)throw&quot;Illegal character at offset &quot;+r;h|=u,++a&gt;=4?(o[o.length]=h&gt;&gt;16,o[o.length]=h&gt;&gt;8&amp;255,o[o.length]=255&amp;h,h=0,a=0):h&lt;&lt;=6&#125;&#125;switch(a)&#123;case 1:throw&quot;Base64 encoding incomplete: at least 2 bits missing&quot;;case 2:o[o.length]=h&gt;&gt;10;break;case 3:o[o.length]=h&gt;&gt;16,o[o.length]=h&gt;&gt;8&amp;255&#125;return o&#125;,i.re=/-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/,i.unarmor=function(t)&#123;var e=i.re.exec(t);if(e)if(e[1])t=e[1];else&#123;if(!e[2])throw&quot;RegExp out of sync&quot;;t=e[2]&#125;return i.decode(t)&#125;,window.Base64=i&#125;(),// Copyright (c) 2008-2013 Lapo Luchini &lt;lapo@lapo.it&gt;// copyright notice and this permission notice appear in all copies.// // THE SOFTWARE IS PROVIDED &quot;AS IS&quot; AND THE AUTHOR DISCLAIMS ALL WARRANTIES// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.function(t)&#123;&quot;use strict&quot;;function e(t,i)&#123;t instanceof e?(this.enc=t.enc,this.pos=t.pos):(this.enc=t,this.pos=i)&#125;function i(t,e,i,r,s)&#123;this.stream=t,this.header=e,this.length=i,this.tag=r,this.sub=s&#125;var r=100,s=&quot;…&quot;,n=&#123;tag:function(t,e)&#123;var i=document.createElement(t);return i.className=e,i&#125;,text:function(t)&#123;return document.createTextNode(t)&#125;&#125;;e.prototype.get=function(e)&#123;if(e===t&amp;&amp;(e=this.pos++),e&gt;=this.enc.length)throw&quot;Requesting byte offset &quot;+e+&quot; on a stream of length &quot;+this.enc.length;return this.enc[e]&#125;,e.prototype.hexDigits=&quot;0123456789ABCDEF&quot;,e.prototype.hexByte=function(t)&#123;return this.hexDigits.charAt(t&gt;&gt;4&amp;15)+this.hexDigits.charAt(15&amp;t)&#125;,e.prototype.hexDump=function(t,e,i)&#123;for(var r=&quot;&quot;,s=t;e&gt;s;++s)if(r+=this.hexByte(this.get(s)),i!==!0)switch(15&amp;s)&#123;case 7:r+=&quot; &quot;;break;case 15:r+=&quot;\n&quot;;break;default:r+=&quot; &quot;&#125;return r&#125;,e.prototype.parseStringISO=function(t,e)&#123;for(var i=&quot;&quot;,r=t;e&gt;r;++r)i+=String.fromCharCode(this.get(r));return i&#125;,e.prototype.parseStringUTF=function(t,e)&#123;for(var i=&quot;&quot;,r=t;e&gt;r;)&#123;var s=this.get(r++);i+=128&gt;s?String.fromCharCode(s):s&gt;191&amp;&amp;224&gt;s?String.fromCharCode((31&amp;s)&lt;&lt;6|63&amp;this.get(r++)):String.fromCharCode((15&amp;s)&lt;&lt;12|(63&amp;this.get(r++))&lt;&lt;6|63&amp;this.get(r++))&#125;return i&#125;,e.prototype.parseStringBMP=function(t,e)&#123;for(var i=&quot;&quot;,r=t;e&gt;r;r+=2)&#123;var s=this.get(r),n=this.get(r+1);i+=String.fromCharCode((s&lt;&lt;8)+n)&#125;return i&#125;,e.prototype.reTime=/^((?:1[89]|2\d)?\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d&#123;1,3&#125;))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/,e.prototype.parseTime=function(t,e)&#123;var i=this.parseStringISO(t,e),r=this.reTime.exec(i);return r?(i=r[1]+&quot;-&quot;+r[2]+&quot;-&quot;+r[3]+&quot; &quot;+r[4],r[5]&amp;&amp;(i+=&quot;:&quot;+r[5],r[6]&amp;&amp;(i+=&quot;:&quot;+r[6],r[7]&amp;&amp;(i+=&quot;.&quot;+r[7]))),r[8]&amp;&amp;(i+=&quot; UTC&quot;,&quot;Z&quot;!=r[8]&amp;&amp;(i+=r[8],r[9]&amp;&amp;(i+=&quot;:&quot;+r[9]))),i):&quot;Unrecognized time: &quot;+i&#125;,e.prototype.parseInteger=function(t,e)&#123;var i=e-t;if(i&gt;4)&#123;i&lt;&lt;=3;var r=this.get(t);if(0===r)i-=8;else for(;128&gt;r;)r&lt;&lt;=1,--i;return&quot;(&quot;+i+&quot; bit)&quot;&#125;for(var s=0,n=t;e&gt;n;++n)s=s&lt;&lt;8|this.get(n);return s&#125;,e.prototype.parseBitString=function(t,e)&#123;var i=this.get(t),r=(e-t-1&lt;&lt;3)-i,s=&quot;(&quot;+r+&quot; bit)&quot;;if(20&gt;=r)&#123;var n=i;s+=&quot; &quot;;for(var o=e-1;o&gt;t;--o)&#123;for(var h=this.get(o),a=n;8&gt;a;++a)s+=h&gt;&gt;a&amp;1?&quot;1&quot;:&quot;0&quot;;n=0&#125;&#125;return s&#125;,e.prototype.parseOctetString=function(t,e)&#123;var i=e-t,n=&quot;(&quot;+i+&quot; byte) &quot;;i&gt;r&amp;&amp;(e=t+r);for(var o=t;e&gt;o;++o)n+=this.hexByte(this.get(o));return i&gt;r&amp;&amp;(n+=s),n&#125;,e.prototype.parseOID=function(t,e)&#123;for(var i=&quot;&quot;,r=0,s=0,n=t;e&gt;n;++n)&#123;var o=this.get(n);if(r=r&lt;&lt;7|127&amp;o,s+=7,!(128&amp;o))&#123;if(&quot;&quot;===i)&#123;var h=80&gt;r?40&gt;r?0:1:2;i=h+&quot;.&quot;+(r-40*h)&#125;else i+=&quot;.&quot;+(s&gt;=31?&quot;bigint&quot;:r);r=s=0&#125;&#125;return i&#125;,i.prototype.typeName=function()&#123;if(this.tag===t)return&quot;unknown&quot;;var e=this.tag&gt;&gt;6,i=(this.tag&gt;&gt;5&amp;1,31&amp;this.tag);switch(e)&#123;case 0:switch(i)&#123;case 0:return&quot;EOC&quot;;case 1:return&quot;BOOLEAN&quot;;case 2:return&quot;INTEGER&quot;;case 3:return&quot;BIT_STRING&quot;;case 4:return&quot;OCTET_STRING&quot;;case 5:return&quot;NULL&quot;;case 6:return&quot;OBJECT_IDENTIFIER&quot;;case 7:return&quot;ObjectDescriptor&quot;;case 8:return&quot;EXTERNAL&quot;;case 9:return&quot;REAL&quot;;case 10:return&quot;ENUMERATED&quot;;case 11:return&quot;EMBEDDED_PDV&quot;;case 12:return&quot;UTF8String&quot;;case 16:return&quot;SEQUENCE&quot;;case 17:return&quot;SET&quot;;case 18:return&quot;NumericString&quot;;case 19:return&quot;PrintableString&quot;;case 20:return&quot;TeletexString&quot;;case 21:return&quot;VideotexString&quot;;case 22:return&quot;IA5String&quot;;case 23:return&quot;UTCTime&quot;;case 24:return&quot;GeneralizedTime&quot;;case 25:return&quot;GraphicString&quot;;case 26:return&quot;VisibleString&quot;;case 27:return&quot;GeneralString&quot;;case 28:return&quot;UniversalString&quot;;case 30:return&quot;BMPString&quot;;default:return&quot;Universal_&quot;+i.toString(16)&#125;case 1:return&quot;Application_&quot;+i.toString(16);case 2:return&quot;[&quot;+i+&quot;]&quot;;case 3:return&quot;Private_&quot;+i.toString(16)&#125;&#125;,i.prototype.reSeemsASCII=/^[ -~]+$/,i.prototype.content=function()&#123;if(this.tag===t)return null;var e=this.tag&gt;&gt;6,i=31&amp;this.tag,n=this.posContent(),o=Math.abs(this.length);if(0!==e)&#123;if(null!==this.sub)return&quot;(&quot;+this.sub.length+&quot; elem)&quot;;var h=this.stream.parseStringISO(n,n+Math.min(o,r));return this.reSeemsASCII.test(h)?h.substring(0,2*r)+(h.length&gt;2*r?s:&quot;&quot;):this.stream.parseOctetString(n,n+o)&#125;switch(i)&#123;case 1:return 0===this.stream.get(n)?&quot;false&quot;:&quot;true&quot;;case 2:return this.stream.parseInteger(n,n+o);case 3:return this.sub?&quot;(&quot;+this.sub.length+&quot; elem)&quot;:this.stream.parseBitString(n,n+o);case 4:return this.sub?&quot;(&quot;+this.sub.length+&quot; elem)&quot;:this.stream.parseOctetString(n,n+o);case 6:return this.stream.parseOID(n,n+o);case 16:case 17:return&quot;(&quot;+this.sub.length+&quot; elem)&quot;;case 12:return this.stream.parseStringUTF(n,n+o);case 18:case 19:case 20:case 21:case 22:case 26:return this.stream.parseStringISO(n,n+o);case 30:return this.stream.parseStringBMP(n,n+o);case 23:case 24:return this.stream.parseTime(n,n+o)&#125;return null&#125;,i.prototype.toString=function()&#123;return this.typeName()+&quot;@&quot;+this.stream.pos+&quot;[header:&quot;+this.header+&quot;,length:&quot;+this.length+&quot;,sub:&quot;+(null===this.sub?&quot;null&quot;:this.sub.length)+&quot;]&quot;&#125;,i.prototype.print=function(e)&#123;if(e===t&amp;&amp;(e=&quot;&quot;),document.writeln(e+this),null!==this.sub)&#123;e+=&quot; &quot;;for(var i=0,r=this.sub.length;r&gt;i;++i)this.sub[i].print(e)&#125;&#125;,i.prototype.toPrettyString=function(e)&#123;e===t&amp;&amp;(e=&quot;&quot;);var i=e+this.typeName()+&quot; @&quot;+this.stream.pos;if(this.length&gt;=0&amp;&amp;(i+=&quot;+&quot;),i+=this.length,32&amp;this.tag?i+=&quot; (constructed)&quot;:3!=this.tag&amp;&amp;4!=this.tag||null===this.sub||(i+=&quot; (encapsulates)&quot;),i+=&quot;\n&quot;,null!==this.sub)&#123;e+=&quot; &quot;;for(var r=0,s=this.sub.length;s&gt;r;++r)i+=this.sub[r].toPrettyString(e)&#125;return i&#125;,i.prototype.toDOM=function()&#123;var t=n.tag(&quot;div&quot;,&quot;node&quot;);t.asn1=this;var e=n.tag(&quot;div&quot;,&quot;head&quot;),i=this.typeName().replace(/_/g,&quot; &quot;);e.innerHTML=i;var r=this.content();if(null!==r)&#123;r=String(r).replace(/&lt;/g,&quot;&lt;&quot;);var s=n.tag(&quot;span&quot;,&quot;preview&quot;);s.appendChild(n.text(r)),e.appendChild(s)&#125;t.appendChild(e),this.node=t,this.head=e;var o=n.tag(&quot;div&quot;,&quot;value&quot;);if(i=&quot;Offset: &quot;+this.stream.pos+&quot;&lt;br/&gt;&quot;,i+=&quot;Length: &quot;+this.header+&quot;+&quot;,i+=this.length&gt;=0?this.length:-this.length+&quot; (undefined)&quot;,32&amp;this.tag?i+=&quot;&lt;br/&gt;(constructed)&quot;:3!=this.tag&amp;&amp;4!=this.tag||null===this.sub||(i+=&quot;&lt;br/&gt;(encapsulates)&quot;),null!==r&amp;&amp;(i+=&quot;&lt;br/&gt;Value:&lt;br/&gt;&lt;b&gt;&quot;+r+&quot;&lt;/b&gt;&quot;,&quot;object&quot;==typeof oids&amp;&amp;6==this.tag))&#123;var h=oids[r];h&amp;&amp;(h.d&amp;&amp;(i+=&quot;&lt;br/&gt;&quot;+h.d),h.c&amp;&amp;(i+=&quot;&lt;br/&gt;&quot;+h.c),h.w&amp;&amp;(i+=&quot;&lt;br/&gt;(warning!)&quot;))&#125;o.innerHTML=i,t.appendChild(o);var a=n.tag(&quot;div&quot;,&quot;sub&quot;);if(null!==this.sub)for(var u=0,c=this.sub.length;c&gt;u;++u)a.appendChild(this.sub[u].toDOM());return t.appendChild(a),e.onclick=function()&#123;t.className=&quot;node collapsed&quot;==t.className?&quot;node&quot;:&quot;node collapsed&quot;&#125;,t&#125;,i.prototype.posStart=function()&#123;return this.stream.pos&#125;,i.prototype.posContent=function()&#123;return this.stream.pos+this.header&#125;,i.prototype.posEnd=function()&#123;return this.stream.pos+this.header+Math.abs(this.length)&#125;,i.prototype.fakeHover=function(t)&#123;this.node.className+=&quot; hover&quot;,t&amp;&amp;(this.head.className+=&quot; hover&quot;)&#125;,i.prototype.fakeOut=function(t)&#123;var e=/ ?hover/;this.node.className=this.node.className.replace(e,&quot;&quot;),t&amp;&amp;(this.head.className=this.head.className.replace(e,&quot;&quot;))&#125;,i.prototype.toHexDOM_sub=function(t,e,i,r,s)&#123;if(!(r&gt;=s))&#123;var o=n.tag(&quot;span&quot;,e);o.appendChild(n.text(i.hexDump(r,s))),t.appendChild(o)&#125;&#125;,i.prototype.toHexDOM=function(e)&#123;var i=n.tag(&quot;span&quot;,&quot;hex&quot;);if(e===t&amp;&amp;(e=i),this.head.hexNode=i,this.head.onmouseover=function()&#123;this.hexNode.className=&quot;hexCurrent&quot;&#125;,this.head.onmouseout=function()&#123;this.hexNode.className=&quot;hex&quot;&#125;,i.asn1=this,i.onmouseover=function()&#123;var t=!e.selected;t&amp;&amp;(e.selected=this.asn1,this.className=&quot;hexCurrent&quot;),this.asn1.fakeHover(t)&#125;,i.onmouseout=function()&#123;var t=e.selected==this.asn1;this.asn1.fakeOut(t),t&amp;&amp;(e.selected=null,this.className=&quot;hex&quot;)&#125;,this.toHexDOM_sub(i,&quot;tag&quot;,this.stream,this.posStart(),this.posStart()+1),this.toHexDOM_sub(i,this.length&gt;=0?&quot;dlen&quot;:&quot;ulen&quot;,this.stream,this.posStart()+1,this.posContent()),null===this.sub)i.appendChild(n.text(this.stream.hexDump(this.posContent(),this.posEnd())));else if(this.sub.length&gt;0)&#123;var r=this.sub[0],s=this.sub[this.sub.length-1];this.toHexDOM_sub(i,&quot;intro&quot;,this.stream,this.posContent(),r.posStart());for(var o=0,h=this.sub.length;h&gt;o;++o)i.appendChild(this.sub[o].toHexDOM(e));this.toHexDOM_sub(i,&quot;outro&quot;,this.stream,s.posEnd(),this.posEnd())&#125;return i&#125;,i.prototype.toHexString=function(t)&#123;return this.stream.hexDump(this.posStart(),this.posEnd(),!0)&#125;,i.decodeLength=function(t)&#123;var e=t.get(),i=127&amp;e;if(i==e)return i;if(i&gt;3)throw&quot;Length over 24 bits not supported at position &quot;+(t.pos-1);if(0===i)return-1;e=0;for(var r=0;i&gt;r;++r)e=e&lt;&lt;8|t.get();return e&#125;,i.hasContent=function(t,r,s)&#123;if(32&amp;t)return!0;if(3&gt;t||t&gt;4)return!1;var n=new e(s);3==t&amp;&amp;n.get();var o=n.get();if(o&gt;&gt;6&amp;1)return!1;try&#123;var h=i.decodeLength(n);return n.pos-s.pos+h==r&#125;catch(a)&#123;return!1&#125;&#125;,i.decode=function(t)&#123;t instanceof e||(t=new e(t,0));var r=new e(t),s=t.get(),n=i.decodeLength(t),o=t.pos-r.pos,h=null;if(i.hasContent(s,n,t))&#123;var a=t.pos;if(3==s&amp;&amp;t.get(),h=[],n&gt;=0)&#123;for(var u=a+n;t.pos&lt;u;)h[h.length]=i.decode(t);if(t.pos!=u)throw&quot;Content size is not correct for container starting at offset &quot;+a&#125;else try&#123;for(;;)&#123;var c=i.decode(t);if(0===c.tag)break;h[h.length]=c&#125;n=a-t.pos&#125;catch(f)&#123;throw&quot;Exception while decoding undefined length content: &quot;+f&#125;&#125;else t.pos+=n;return new i(r,o,n,s,h)&#125;,i.test=function()&#123;for(var t=[&#123;value:[39],expected:39&#125;,&#123;value:[129,201],expected:201&#125;,&#123;value:[131,254,220,186],expected:16702650&#125;],r=0,s=t.length;s&gt;r;++r)&#123;var n=new e(t[r].value,0),o=i.decodeLength(n);o!=t[r].expected&amp;&amp;document.write(&quot;In test[&quot;+r+&quot;] expected &quot;+t[r].expected+&quot; got &quot;+o+&quot;\n&quot;)&#125;&#125;,window.ASN1=i&#125;(),ASN1.prototype.getHexStringValue=function()&#123;var t=this.toHexString(),e=2*this.header,i=2*this.length;return t.substr(e,i)&#125;,ue.prototype.parseKey=function(t)&#123;try&#123;var e=0,i=0,r=/^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/,s=r.test(t)?Hex.decode(t):Base64.unarmor(t),n=ASN1.decode(s);if(3===n.sub.length&amp;&amp;(n=n.sub[2].sub[0]),9===n.sub.length)&#123;e=n.sub[1].getHexStringValue(),this.n=he(e,16),i=n.sub[2].getHexStringValue(),this.e=parseInt(i,16);var o=n.sub[3].getHexStringValue();this.d=he(o,16);var h=n.sub[4].getHexStringValue();this.p=he(h,16);var a=n.sub[5].getHexStringValue();this.q=he(a,16);var u=n.sub[6].getHexStringValue();this.dmp1=he(u,16);var c=n.sub[7].getHexStringValue();this.dmq1=he(c,16);var f=n.sub[8].getHexStringValue();this.coeff=he(f,16)&#125;else&#123;if(2!==n.sub.length)return!1;var p=n.sub[1],l=p.sub[0];e=l.sub[0].getHexStringValue(),this.n=he(e,16),i=l.sub[1].getHexStringValue(),this.e=parseInt(i,16)&#125;return!0&#125;catch(d)&#123;return!1&#125;&#125;,ue.prototype.getPrivateBaseKey=function()&#123;var t=&#123;array:[new KJUR.asn1.DERInteger(&#123;&quot;int&quot;:0&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.n&#125;),new KJUR.asn1.DERInteger(&#123;&quot;int&quot;:this.e&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.d&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.p&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.q&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.dmp1&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.dmq1&#125;),new KJUR.asn1.DERInteger(&#123;bigint:this.coeff&#125;)]&#125;,e=new KJUR.asn1.DERSequence(t);return e.getEncodedHex()&#125;,ue.prototype.getPrivateBaseKeyB64=function()&#123;return be(this.getPrivateBaseKey())&#125;,ue.prototype.getPublicBaseKey=function()&#123;var t=&#123;array:[new KJUR.asn1.DERObjectIdentifier(&#123;oid:&quot;1.2.840.113549.1.1.1&quot;&#125;),new KJUR.asn1.DERNull]&#125;,e=new KJUR.asn1.DERSequence(t);t=&#123;array:[new KJUR.asn1.DERInteger(&#123;bigint:this.n&#125;),new KJUR.asn1.DERInteger(&#123;&quot;int&quot;:this.e&#125;)]&#125;;var i=new KJUR.asn1.DERSequence(t);t=&#123;hex:&quot;00&quot;+i.getEncodedHex()&#125;;var r=new KJUR.asn1.DERBitString(t);t=&#123;array:[e,r]&#125;;var s=new KJUR.asn1.DERSequence(t);return s.getEncodedHex()&#125;,ue.prototype.getPublicBaseKeyB64=function()&#123;return be(this.getPublicBaseKey())&#125;,ue.prototype.wordwrap=function(t,e)&#123;if(e=e||64,!t)return t;var i=&quot;(.&#123;1,&quot;+e+&quot;&#125;)( +|$\n?)|(.&#123;1,&quot;+e+&quot;&#125;)&quot;;return t.match(RegExp(i,&quot;g&quot;)).join(&quot;\n&quot;)&#125;,ue.prototype.getPrivateKey=function()&#123;var t=&quot;-----BEGIN RSA PRIVATE KEY-----\n&quot;;return t+=this.wordwrap(this.getPrivateBaseKeyB64())+&quot;\n&quot;,t+=&quot;-----END RSA PRIVATE KEY-----&quot;&#125;,ue.prototype.getPublicKey=function()&#123;var t=&quot;-----BEGIN PUBLIC KEY-----\n&quot;;return t+=this.wordwrap(this.getPublicBaseKeyB64())+&quot;\n&quot;,t+=&quot;-----END PUBLIC KEY-----&quot;&#125;,ue.prototype.hasPublicKeyProperty=function(t)&#123;return t=t||&#123;&#125;,t.hasOwnProperty(&quot;n&quot;)&amp;&amp;t.hasOwnProperty(&quot;e&quot;)&#125;,ue.prototype.hasPrivateKeyProperty=function(t)&#123;return t=t||&#123;&#125;,t.hasOwnProperty(&quot;n&quot;)&amp;&amp;t.hasOwnProperty(&quot;e&quot;)&amp;&amp;t.hasOwnProperty(&quot;d&quot;)&amp;&amp;t.hasOwnProperty(&quot;p&quot;)&amp;&amp;t.hasOwnProperty(&quot;q&quot;)&amp;&amp;t.hasOwnProperty(&quot;dmp1&quot;)&amp;&amp;t.hasOwnProperty(&quot;dmq1&quot;)&amp;&amp;t.hasOwnProperty(&quot;coeff&quot;)&#125;,ue.prototype.parsePropertiesFrom=function(t)&#123;this.n=t.n,this.e=t.e,t.hasOwnProperty(&quot;d&quot;)&amp;&amp;(this.d=t.d,this.p=t.p,this.q=t.q,this.dmp1=t.dmp1,this.dmq1=t.dmq1,this.coeff=t.coeff)&#125;;var _e=function(t)&#123;ue.call(this),t&amp;&amp;(&quot;string&quot;==typeof t?this.parseKey(t):(this.hasPrivateKeyProperty(t)||this.hasPublicKeyProperty(t))&amp;&amp;this.parsePropertiesFrom(t))&#125;;_e.prototype=new ue,_e.prototype.constructor=_e;var ze=function(t)&#123;t=t||&#123;&#125;,this.default_key_size=parseInt(t.default_key_size)||1024,this.default_public_exponent=t.default_public_exponent||&quot;010001&quot;,this.log=t.log||!1,this.key=null&#125;;ze.prototype.setKey=function(t)&#123;this.log&amp;&amp;this.key&amp;&amp;console.warn(&quot;A key was already set, overriding existing.&quot;),this.key=new _e(t)&#125;,ze.prototype.setPrivateKey=function(t)&#123;this.setKey(t)&#125;,ze.prototype.setPublicKey=function(t)&#123;this.setKey(t)&#125;,ze.prototype.decrypt=function(t)&#123;try&#123;return this.getKey().decrypt(Te(t))&#125;catch(e)&#123;return!1&#125;&#125;,ze.prototype.encrypt=function(t)&#123;try&#123;return be(this.getKey().encrypt(t))&#125;catch(e)&#123;return!1&#125;&#125;,ze.prototype.getKey=function(t)&#123;if(!this.key)&#123;if(this.key=new _e,t&amp;&amp;&quot;[object Function]&quot;===&#123;&#125;.toString.call(t))return void this.key.generateAsync(this.default_key_size,this.default_public_exponent,t);this.key.generate(this.default_key_size,this.default_public_exponent)&#125;return this.key&#125;,ze.prototype.getPrivateKey=function()&#123;return this.getKey().getPrivateKey()&#125;,ze.prototype.getPrivateKeyB64=function()&#123;return this.getKey().getPrivateBaseKeyB64()&#125;,ze.prototype.getPublicKey=function()&#123;return this.getKey().getPublicKey()&#125;,ze.prototype.getPublicKeyB64=function()&#123;return this.getKey().getPublicBaseKeyB64()&#125;,ze.version=&quot;2.3.1&quot;,t.JSEncrypt=ze&#125;);//]]></content>
  </entry>
  <entry>
    <title><![CDATA[base64编码和解码（JS）]]></title>
    <url>%2F2017%2F02%2F21%2F%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%2Fbase64%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81%EF%BC%88JS%EF%BC%89%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var base64EncodeChars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;var base64DecodeChars = new Array(-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1);/** * base64编码 * @param &#123;Object&#125; str */function base64encode(str) &#123; var out, i, len; var c1, c2, c3; len = str.length; i = 0; out = &quot;&quot;; while(i &lt; len) &#123; c1 = str.charCodeAt(i++) &amp; 0xff; if(i == len) &#123; out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt((c1 &amp; 0x3) &lt;&lt; 4); out += &quot;==&quot;; break; &#125; c2 = str.charCodeAt(i++); if(i == len) &#123; out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt(((c1 &amp; 0x3) &lt;&lt; 4) | ((c2 &amp; 0xF0) &gt;&gt; 4)); out += base64EncodeChars.charAt((c2 &amp; 0xF) &lt;&lt; 2); out += &quot;=&quot;; break; &#125; c3 = str.charCodeAt(i++); out += base64EncodeChars.charAt(c1 &gt;&gt; 2); out += base64EncodeChars.charAt(((c1 &amp; 0x3) &lt;&lt; 4) | ((c2 &amp; 0xF0) &gt;&gt; 4)); out += base64EncodeChars.charAt(((c2 &amp; 0xF) &lt;&lt; 2) | ((c3 &amp; 0xC0) &gt;&gt; 6)); out += base64EncodeChars.charAt(c3 &amp; 0x3F); &#125; return out;&#125;/** * base64解码 * @param &#123;Object&#125; str */function base64decode(str) &#123; var c1, c2, c3, c4; var i, len, out; len = str.length; i = 0; out = &quot;&quot;; while(i &lt; len) &#123; /* c1 */ do &#123; c1 = base64DecodeChars[str.charCodeAt(i++) &amp; 0xff]; &#125; while (i &lt; len &amp;&amp; c1 == -1); if(c1 == -1) break; /* c2 */ do &#123; c2 = base64DecodeChars[str.charCodeAt(i++) &amp; 0xff]; &#125; while (i &lt; len &amp;&amp; c2 == -1); if(c2 == -1) break; out += String.fromCharCode((c1 &lt;&lt; 2) | ((c2 &amp; 0x30) &gt;&gt; 4)); /* c3 */ do &#123; c3 = str.charCodeAt(i++) &amp; 0xff; if(c3 == 61) return out; c3 = base64DecodeChars[c3]; &#125; while (i &lt; len &amp;&amp; c3 == -1); if(c3 == -1) break; out += String.fromCharCode(((c2 &amp; 0XF) &lt;&lt; 4) | ((c3 &amp; 0x3C) &gt;&gt; 2)); /* c4 */ do &#123; c4 = str.charCodeAt(i++) &amp; 0xff; if(c4 == 61) return out; c4 = base64DecodeChars[c4]; &#125; while (i &lt; len &amp;&amp; c4 == -1); if(c4 == -1) break; out += String.fromCharCode(((c3 &amp; 0x03) &lt;&lt; 6) | c4); &#125; return out;&#125;]]></content>
  </entry>
</search>
