<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">






















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.2.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  



<!-- <meta name="referrer" content="never"/> -->

<style>
#footer .footer-inner .powered-by{
display: none;
}
#footer .footer-inner .post-meta-divider{
display: none;
}
#footer .footer-inner .theme-info{
display: none;
}
#comments.comments .info{
display: none !important;
}
</style>
<script>
  function blogLog() {
    if (window.location.hostname.indexOf('zhoujie16') !== -1) {
      var url = "https://s.zhoujie16.cn/mdapi/applog_zhoujie_blog";
      const key = "zhoujie_blog_uuid";
      var uuid = localStorage.getItem(key);
      if (!uuid) {
        uuid = guid2();
        localStorage.setItem(key, uuid);
      }
      const params = {
        uuid,
        page: window.location.href,
        remark: ""
      };
      $.post(url, params);
      function guid2() {
        function S4() {
          return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return (
          S4() +
          S4() +
          "-" +
          S4() +
          "-" +
          S4() +
          "-" +
          S4() +
          "-" +
          S4() +
          S4() +
          S4()
        );
      }
    }
  }

  window.onload = function () {
    console.log('window onload')
    setTimeout(function () {
      blogLog()
    }, 1000)
  }
</script>


  <meta name="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
<meta property="og:type" content="website">
<meta property="og:title" content="ZJ_16">
<meta property="og:url" content="http://zhoujie16.cn/page/4/index.html">
<meta property="og:site_name" content="ZJ_16">
<meta property="og:description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ZJ_16">
<meta name="twitter:description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">





  
  
  <link rel="canonical" href="http://zhoujie16.cn/page/4/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>ZJ_16</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ZJ_16</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">ZJ_16的个人网站</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
      
    

    
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
      
    

    
      
    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
      
    

    
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类<span class="badge">1</span></a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
      
    

    
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档<span class="badge">59</span></a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/07/我的文章/css3属性box-decoration-break/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/07/我的文章/css3属性box-decoration-break/" class="post-title-link" itemprop="url">css3属性box-decoration-break</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-07 14:20:40" itemprop="dateCreated datePublished" datetime="2019-03-07T14:20:40+08:00">2019-03-07</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/07/我的文章/css3属性box-decoration-break/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/07/我的文章/css3属性box-decoration-break/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这两天接触到一个很有意思的 CSS 属性 – <code>box-decoration-break</code>。下面就一起去一探究竟。</p>
<p>因为 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box-decoration-break" target="_blank" rel="noopener">MDN</a> 上关于这个属性，没有中文文档，所以一直在想一个合理贴切的中文翻译。直译一下：</p>
<ul>
<li>box – 盒，可以理解为元素盒模型</li>
<li>decoration – 装饰，理解为元素样式</li>
<li>break – 断行，参考<code>word-break</code> ，理解为断行时候的表现</li>
</ul>
<p>那么，这个属性可以先理解为，元素在发生断行时其样式的表现形式。</p>
<blockquote>
<p>MDN 上英文释意为：The box-decoration-break CSS property specifies how an element’s fragments should be rendered when broken across multiple lines, columns, or pages。大意是 box-decoration-break 属性规定了一个元素片段在发生折行/断行时，应该如何被渲染。</p>
</blockquote>
<p>可选取值只有两个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    box-decoration-break: slice;   // 默认取值</span><br><span class="line">    box-decoration-break: clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="换行示例"><a href="#换行示例" class="headerlink" title="换行示例"></a>换行示例</h2><p>这个属性通常作用于内联元素。假设我们存在如下结构，并且给它添加一个边框：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;ABCDEFGHIJKLMN&lt;/span&gt;</span><br><span class="line">span &#123;</span><br><span class="line">    border: 2px solid #999;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，效果如下，平平无奇：<br><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7kz3arvj308y02074c.jpg" alt></p>
<p>好，接下来就是 break，我们把上面一行的文字断行，样式不变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;ABCD &lt;br/&gt;EFG &lt;br/&gt; HI&lt;br/&gt; JKLMN&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>得到如下结果：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7mi2kzhj303k07njrg.jpg" alt></p>
<p>O，可以看到，文字换行的同时，边框也随之变化，头尾两行都有 3 边边框，中间两行只有上下两边边框。如果将 4 行合起来，可以拼成图一，这个是正常的展示效果。</p>
<p>接下来，我们加上本文的主角 <code>box-decoration-break: clone</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">span &#123;</span><br><span class="line">    border: 2px solid #999;</span><br><span class="line">+   box-decoration-break: clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生效后，我们将会得到这样的结果：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7mtbftkj303x07g0su.jpg" alt></p>
<h2 id="box-decoration-break-clone-使用小结"><a href="#box-decoration-break-clone-使用小结" class="headerlink" title="box-decoration-break: clone 使用小结"></a>box-decoration-break: clone 使用小结</h2><p>看到这里，我们已经可以大概理解这个属性的作用了：</p>
<p><strong>使用了 box-decoration-break: clone 的内联元素，如果存在折行显示，那么每一行都将拥有原本单行的所有完整样式</strong>。</p>
<p>再看个例子加深下理解，存在如下结构，其使用了 <code>box-decoration-break: clone</code> 前后两种效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span &gt;每一行 &lt;br/&gt;样式 &lt;br/&gt; 都 &lt;br/&gt; 保持&lt;br/&gt; 完整独立&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7n3fjpqj30m80bct9w.jpg" alt></p>
<p><a href="https://codepen.io/Chokcoco/pen/NJKoNq" target="_blank" rel="noopener">CodePen Demo – box-decoration-break</a>点击预览</p>
<h3 id="box-decoration-break-clone-生效样式影响范围"><a href="#box-decoration-break-clone-生效样式影响范围" class="headerlink" title="box-decoration-break: clone 生效样式影响范围"></a>box-decoration-break: clone 生效样式影响范围</h3><p>当然，使用了 <code>box-decoration-break: clone</code> 的元素并非对每一个样式都会生效，只会作用于下列样式：</p>
<ul>
<li>background</li>
<li>border</li>
<li>border-image</li>
<li>box-shadow</li>
<li>clip-path</li>
<li>margin</li>
<li>padding</li>
<li>Syntax</li>
</ul>
<h2 id="box-decoration-break-clone-实际应用"><a href="#box-decoration-break-clone-实际应用" class="headerlink" title="box-decoration-break: clone 实际应用"></a>box-decoration-break: clone 实际应用</h2><p>接下来看看，有没有什么靠谱的实际应用场景。</p>
<h3 id="box-decoration-break-clone-实现文本选中效果"><a href="#box-decoration-break-clone-实现文本选中效果" class="headerlink" title="box-decoration-break: clone 实现文本选中效果"></a>box-decoration-break: clone 实现文本选中效果</h3><p>会有这样的场景，我们希望对一个多行文本中的特定一段文本进行着重展示。这个时候，我们可以通过 <code>&lt;p&gt;</code> 嵌套 <code>&lt;span&gt;</code> ，对 <code>&lt;span&gt;</code> 包裹的文字进行一些特定的展示。</p>
<p>譬如我们有这样一段文案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">The &lt;span&gt;box-decoration-break&lt;/span&gt; CSS property specifies how an element&apos;s fragments should be rendered when broken across multiple lines, columns, or pages..Each box fragment is rendered independently with the &lt;span&gt;specified border, padding, and margin wrapping each fragment.&lt;/span&gt; The border-radius, border-image, and box-shadow are applied to each &lt;span&gt;fragment independently.&lt;/span&gt; </span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>其中，我们将需要强调的内容通过 <code>&lt;span&gt;</code> 标签包裹起来，赋予特定样式并且加上 <code>box-decoration-break: clone</code>，这样，无论强调文案是否换行，每一处的强调背景都是一致的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    font-size: 22px;</span><br><span class="line">    line-height: 36px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">span &#123;</span><br><span class="line">    background-image: linear-gradient(135deg, deeppink, yellowgreen);</span><br><span class="line">    color: #fff;</span><br><span class="line">    padding: 2px 10px;</span><br><span class="line">    border-radius: 50% 3em 50% 3em;</span><br><span class="line">    box-decoration-break: clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到如下效果：<br><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7nxolstj30m8050gn0.jpg" alt></p>
<p>如果不加 <code>box-decoration-break: clone</code> 呢？那么如果存在换行，效果会大打折扣：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7oat7qdj30m804x3zx.jpg" alt></p>
<p><a href="https://codepen.io/Chokcoco/pen/rRaLqo" target="_blank" rel="noopener">CodePen Demo – text-decoration-break 文本选中效果</a>点击预览</p>
<h3 id="box-decoration-break-每行文字带特定边框"><a href="#box-decoration-break-每行文字带特定边框" class="headerlink" title="box-decoration-break 每行文字带特定边框"></a>box-decoration-break 每行文字带特定边框</h3><p>又会有这样的场景，我们希望每一行文案都带有特定的边框样式，像这样：<br><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7ooa56jj30m804z75t.jpg" alt></p>
<p>怎么实现呢？也许可以每一行都是一个 <code>&lt;p&gt;</code>，每一行 <code>&lt;p&gt;</code> 设定上述样式。<strong>但是如果文本内容不确定，容器的宽度也不确定呢</strong>？</p>
<p>这种场景，使用 <code>box-decoration-break</code> 也非常便捷。当然这里有个小技巧，正常而言， <code>box-decoration-break: clone</code>只对 <code>inline</code> 元素生效，如果我们的文案像是这样包裹在 <code>&lt;p&gt;</code> 标签内：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;</span><br><span class="line">The box-decoration-break CSS property specifies how an element&apos;s fragments should be rendered when broken across multiple lines, columns, or pages..Each box fragment is rendered independently with the specified border, padding, and margin wrapping each fragment. The border-radius, border-image, and box-shadow are applied to each fragment independently. </span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>要使 <code>box-decoration-break: clone</code> 对 <code>&lt;p&gt;</code> 生效，可以通过设定 <code>&lt;p&gt;</code> 的 <code>display: inline</code> 来实现。如此一来，要实现上述效果，我们只需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p &#123;</span><br><span class="line">    display: inline;</span><br><span class="line">    box-decoration-break: clone;</span><br><span class="line">    background:linear-gradient(110deg, deeppink 0%, deeppink 98%, transparent 98%, transparent 100%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论文本内容或者容器宽度如何变化，都能完美适配：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7ppinxcg30m807ohdo.gif" alt></p>
<p><a href="https://codepen.io/Chokcoco/pen/gEbMGr?editors=1100" target="_blank" rel="noopener">CodePen Demo – box-decoration-break 每行文字带特定边框</a>点击预览</p>
<h3 id="box-decoration-break-结合过渡动画"><a href="#box-decoration-break-结合过渡动画" class="headerlink" title="box-decoration-break 结合过渡动画"></a>box-decoration-break 结合过渡动画</h3><p>结合上面的内容，我们还可以考虑将 <code>box-decoration-break</code> 与过渡效果或者动画效果结合起来。</p>
<p>譬如，我们希望当我们 hover 文字内容的时候，一些重点需要展示的文字段落能够被强调展示，可能是这样：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7qh939pg30jd07ejz0.gif" alt></p>
<p><a href="https://codepen.io/Chokcoco/pen/ZPGpmd" target="_blank" rel="noopener">CodePen Demo – box-decoration-break 过渡动画</a>点击预览</p>
<p>又或者是这样：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7r7d3ywg30jd07eh1k.gif" alt></p>
<p><a href="https://codepen.io/Chokcoco/pen/ZPGpmd" target="_blank" rel="noopener">CodePen Demo – box-decoration-break 结合过渡动画</a>点击预览</p>
<p>你可以尝试点进 Demo ，然后去掉 <code>box-decoration-break: clone</code> ，会发现效果大打折扣。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>额，按照惯例兼容性应该都不太行。并且 MDN 也给出了这样的提示：</p>
<blockquote>
<p>This is an experimental technology. Check the Browser compatibility table carefully before using this in production.</p>
</blockquote>
<p>看看 <a href="https://caniuse.com/#search=box-decoration-break" target="_blank" rel="noopener">Can I Use</a>，其实还好，除了 IE 系列全军覆没，所以可以考虑应用在移动端。即便这个属性不兼容，降级展示对页面不会造成什么影响：<br><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0u7ro8oq6j30m8092abe.jpg" alt></p>
<p>另外，本文中，给出的代码都是 <code>box-decoration-break: clone</code> ，CodePen 自带了 <code>autoprefixer</code> 实际中可能需要写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    box-decoration-break: clone;</span><br><span class="line">    -webkit-box-decoration-break: clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>国内看到了大漠老师和张鑫旭大大都已经写过这个属性，大家可以对比着看看，加深理解：</p>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2019/01/css-css3-box-decoration-break/" target="_blank" rel="noopener">CSS/CSS3 box-decoration-break属性简介</a></li>
<li><a href="https://www.w3cplus.com/css3/multi-line-padded-text-css-box-decoration-break.html" target="_blank" rel="noopener">初探box-decoration-break</a></li>
</ul>
<p>更多精彩 CSS 技术文章汇总在我的 <a href="https://github.com/chokcoco/iCSS" target="_blank" rel="noopener">Github – iCSS</a> ，持续更新，欢迎点个 star 订阅收藏。</p>
<p>好了，本文到此结束，希望对你有帮助 :)</p>
<p>如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/07/我的文章/浏览器多标签页通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/07/我的文章/浏览器多标签页通信/" class="post-title-link" itemprop="url">浏览器多标签页通信</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-07 14:11:43" itemprop="dateCreated datePublished" datetime="2019-03-07T14:11:43+08:00">2019-03-07</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:54" itemprop="dateModified" datetime="2019-07-25T17:27:54+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/07/我的文章/浏览器多标签页通信/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/07/我的文章/浏览器多标签页通信/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>浏览器多标签页通信有助于降低服务器负载，提高运营人员的工作效率，提高用户体验。是前端开发优化的一个重要环节。</p>
</blockquote>
<h2 id="需求来源"><a href="#需求来源" class="headerlink" title="需求来源"></a>需求来源</h2><p>在多数CMS（内容管理系统）后台上，常见的是一个文章列表页面，点击列表项会打开一个新的文章详情页面。编辑人员经常在这个详情页面上对文章操作，比如修改标题、配图、摘要等内容。操作完毕之后，由于文章页和列表页是两个页面，文章内容数据不能及时同步到列表，这样就照成运营人员多次误操作，这大大降低了运营人员的工作效率。</p>
<p>对于前端工程师来讲，实现浏览器多个页卡之间的通信，及时更新相关数据更改，是一件重要的事情。</p>
<p>例如有一个需求：当文章详情页面更新的时候，会同步到文章列表页。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="方式一：cookie-setInterval"><a href="#方式一：cookie-setInterval" class="headerlink" title="方式一：cookie+setInterval"></a>方式一：cookie+setInterval</h3><p>cookie最初是在客户端用于存储用户的会话信息的。由于HTTP是一种无状态的协议，服务器单从网络连接上无法知道客户身份。通过cookie就给客户端们颁发一个通行证，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个cookie。客户端浏览器会把cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该cookie一同提交给服务器。服务器检查该cookie，以此来辨认用户状态。服务器还可以根据需要修改cookie的内容。</p>
<p>在JavaScript中，cookie的操作接口即document.cookie，通过这个接口可以读取、写入、删除cookie。这个操作其实不太友好，所以很多工具库提供了cookie的操作方法。我这里提供一个简单的封装方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var QQ = &#123;&#125;;</span><br><span class="line">QQ.Cookie=&#123;</span><br><span class="line">    set:function(name,value,expires,path,domain)&#123;</span><br><span class="line">        if(typeof expires==&quot;undefined&quot;)&#123;</span><br><span class="line">            expires=new Date(new Date().getTime()+3600*1000);</span><br><span class="line">        &#125;</span><br><span class="line">        document.cookie=name+&quot;=&quot;+escape(value)+((expires)?&quot;; expires=&quot;+expires.toGMTString():&quot;&quot;)+((path)?&quot;; path=&quot;+path:&quot;; path=/&quot;)+((domain)?&quot;;domain=&quot;+domain:&quot;&quot;);</span><br><span class="line">    &#125;,</span><br><span class="line">    get:function(name)&#123;</span><br><span class="line">        var arr=document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class="line">        if(arr!=null)&#123;</span><br><span class="line">            return unescape(arr[2]);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;,</span><br><span class="line">    clear:function(name,path,domain)&#123;</span><br><span class="line">        if(this.get(name))&#123;</span><br><span class="line">            document.cookie=name+&quot;=&quot;+((path)?&quot;; path=&quot;+path:&quot;; path=/&quot;)+((domain)?&quot;; domain=&quot;+domain:&quot;&quot;)+&quot;;expires=Fri, 02-Jan-1970 00:00:00 GMT&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> cookie有个特性，一个页面产生的cookie能被与这个页面的同一目录或者其他子目录下的页面访问，这样页面之间就产生了一个共享的存储空间。通常把cookie的path设置为一个更高级别的目录，比如默认“/”，从而使更多的页面共享cookie，实现多页面之间相互通信。 cookie所在的域，默认为请求的地址，也可以通过设置document.domain为父域等方式扩大cookie可被访问的域。</p>
<h4 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h4><p>列表页通过setInterval定时器循环监听cookie的数据变动<br>列表页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;</span><br><span class="line">    var tid =  &apos;&apos;;</span><br><span class="line">    setInterval(function()&#123;    </span><br><span class="line">        if(tid != QQ.Cookie.get(&quot;tid&quot;))&#123;</span><br><span class="line">            alert(&apos;数据更新！&apos;)；</span><br><span class="line">            tid = QQ.Cookie.get(&quot;tid&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当详情页有数据修改时后，写入cookie<br>详情页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;content&quot; type=&quot;text&quot;&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload=function()&#123;</span><br><span class="line">        var oBtn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">        var oInput=document.getElementById(&quot;content&quot;);</span><br><span class="line">        oBtn.onclick=function()&#123;</span><br><span class="line">            var val=oInput.value;</span><br><span class="line">            QQ.Cookie.set(&quot;tid&quot;,val);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="cookie-setInterval的不足："><a href="#cookie-setInterval的不足：" class="headerlink" title="cookie+setInterval的不足："></a>cookie+setInterval的<strong>不足</strong>：</h4><p>1、cookie空间有限，浏览器在每一个域名下最多能设置30-50个cookie，容量最多4K左右。<br>2、每次HTTP请求会把当前域的cookie发送到服务器上，而有些cookie只是浏览器才用的到，浪费网络带宽。<br>3、setInterval的频率设置，过大会影响浏览器性能，过小会影响时效性。</p>
<h4 id="cookie-setInterval的优点："><a href="#cookie-setInterval的优点：" class="headerlink" title="cookie+setInterval的优点："></a>cookie+setInterval的优点：</h4><p>兼容性好，几乎所有的浏览器都支持。</p>
<h3 id="方式二：localStorage"><a href="#方式二：localStorage" class="headerlink" title="方式二：localStorage"></a>方式二：localStorage</h3><p>在HTML5中，新加入了一个localStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。<br>localStorage的API也很简单，提供了JS的读写操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">if(！window.localStorage)&#123;</span><br><span class="line">    alert(&quot;浏览器不支持localstorage&quot;);</span><br><span class="line">    return false;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    var storage = window.localStorage;</span><br><span class="line">    //通过属性写入a字段</span><br><span class="line">    storage.a = 1;</span><br><span class="line">    //通过方法写入b字段</span><br><span class="line">    storage.setItem(&quot;b&quot;,2);</span><br><span class="line"></span><br><span class="line">    storage.getItem(&quot;a&quot;);</span><br><span class="line">    storage.b;</span><br><span class="line">    storage.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 它还比cookie多了一个优点，提供了onstorage以及storage事件，可以绑定一个回调函数，使用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onstorage = function(e)&#123;console.log(e)&#125;</span><br><span class="line">// 或者</span><br><span class="line">window.addEventListener(&apos;storage&apos;, function()&#123; console.log(e)&#125;)</span><br></pre></td></tr></table></figure>

<p>localStorage是Storage对象的实例。对Storage对象进行任何修改，都会在触发storage事件。当通过属性或者setItem()方法保存数据，或者使用delete操作符或removeItem()删除数据，或者调用clear()方法时，都会触发该事件。通过这个事件，我们可以实现页卡之间的变动监听。</p>
<h4 id="实现原理：-1"><a href="#实现原理：-1" class="headerlink" title="实现原理："></a>实现原理：</h4><p>列表页通过storage监听localStorage的数据变动<br>列表页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.addEventListener(&quot;storage&quot;,function(event)&#123;</span><br><span class="line">        console.log(&quot;newValue is&quot;+localStorage.getItem(&quot;tid&quot;));</span><br><span class="line">        console.log(&quot;oldValue is&quot;+event.oldValue);</span><br><span class="line">        window.alert(&apos;数据更新！&apos;);</span><br><span class="line">    &#125;,false);    </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当详情页有数据修改时后，写入localStorage<br>详情页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;content&quot; type=&quot;text&quot;/&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload=function()&#123;</span><br><span class="line">        var oBtn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">        var oInput=document.getElementById(&quot;content&quot;);</span><br><span class="line">        oBtn.onclick=function()&#123;</span><br><span class="line">            var val=oInput.value;</span><br><span class="line">            localStorage.setItem(&quot;tid&quot;,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>不过，onstorage以及storage事件，针对都是非当前页面对localStorage进行修改时才会触发，当前页面修改localStorage不会触发监听函数。还有就是在对原有的数据的值进行修改时才会触发，比如原本已经有一个key为a，值为1的localStorage，再执行：localStorage.setItem(‘a’, 1)代码，同样是不会触发监听函数的。</p>
<h4 id="localStorage的不足："><a href="#localStorage的不足：" class="headerlink" title="localStorage的不足："></a>localStorage的<strong>不足</strong>：</h4><p>1、浏览器的容量大小不统一（比cookie大很多了），并且在高版本的浏览器才支持localStorage这个属性<br>2、目前所有的浏览器中都会把localStorage的值类型限定为string类型，需要JSON转换。<br>3、localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡。<br>4、localStorage只能监听非己页面的数据变化，这一点严重影响使用。</p>
<h4 id="localStorage的优点："><a href="#localStorage的优点：" class="headerlink" title="localStorage的优点："></a>localStorage的<strong>优点</strong>：</h4><p>1、解决了cookie容量小和时效性不足的问题。</p>
<h3 id="方式三：WebSocket"><a href="#方式三：WebSocket" class="headerlink" title="方式三：WebSocket"></a>方式三：WebSocket</h3><p>WebSocket API是下一代客户端–服务器的异步通信方法，已被W3C进行了标准化。WebSocket API最伟大之处在于服务器和客户端可以双向实时通信。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。</p>
<p>它的使用很简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 创建一个Socket实例</span><br><span class="line">var socket = new WebSocket(&apos;ws://localhost:8080&apos;); </span><br><span class="line"></span><br><span class="line">// 打开Socket </span><br><span class="line">socket.onopen = function(event) &#123; </span><br><span class="line">    // 发送一个初始化消息</span><br><span class="line">    socket.send(&apos;I am the client and I\&apos;m listening!&apos;); </span><br><span class="line">    // 监听消息</span><br><span class="line">    socket.onmessage = function(event) &#123; </span><br><span class="line">        console.log(&apos;Client received a message&apos;,event); </span><br><span class="line">    &#125;; </span><br><span class="line">    // 监听Socket的关闭</span><br><span class="line">    socket.onclose = function(event) &#123; </span><br><span class="line">        console.log(&apos;Client notified socket has closed&apos;,event); </span><br><span class="line">    &#125;; </span><br><span class="line">    // 关闭Socket.... </span><br><span class="line">    socket.close() </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>WebSocket提供了send方法和onmessage事件，用来发送和接收数据。onmessage事件提供了一个data属性，它可以包含消息的Body部分。消息的Body部分必须是一个字符串，可以进行序列化/反序列化操作，以便传递更多的数据。</p>
<h4 id="实现原理：-2"><a href="#实现原理：-2" class="headerlink" title="实现原理："></a>实现原理：</h4><p>列表页通过onmessage监听socket服务器发送过来的消息<br>列表页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var socket = new WebSocket(&apos;ws://localhost:8080&apos;); </span><br><span class="line">    socket.onopen = function(event) &#123; </span><br><span class="line">        socket.onmessage = function(event) &#123; </span><br><span class="line">            console.log(&apos;Client received a message&apos;, event); </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当详情页有数据修改时后，通过socket连接，通知列表页更新数据。<br>详情页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;content&quot; type=&quot;text&quot;/&gt;</span><br><span class="line">&lt;button id=&quot;btn&quot;&gt;Click&lt;/button&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var socket = new WebSocket(&apos;ws://localhost:8080&apos;); </span><br><span class="line">    window.onload=function()&#123;</span><br><span class="line">        var oBtn=document.getElementById(&quot;btn&quot;);</span><br><span class="line">        var oInput=document.getElementById(&quot;content&quot;);</span><br><span class="line">        oBtn.onclick=function()&#123;</span><br><span class="line">            var val=oInput.value;</span><br><span class="line">            socket.onopen = function(event) &#123;</span><br><span class="line">                // 发送数据类型必须是string、ArrayBuffer、Blob之一</span><br><span class="line">                socket.send(&apos;数据更新!&apos;); </span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>WebSocket的语法非常简单，不过需要IE10+浏览器才支持WebSocket通信。如果你的业务需要兼容IE8，9。业界通常使用第三方库来解决这个问题，比如Socket.IO，它使用检测功能来判断是否建立WebSocket连接，或者是AJAX long-polling连接，或Flash等，可快速创建实时的应用程序。Socket.IO还提供了一个NodeJS API，它看起来非常像浏览器的API。</p>
<h4 id="WebSocket的不足："><a href="#WebSocket的不足：" class="headerlink" title="WebSocket的不足："></a>WebSocket的不足：</h4><p>1、它需要服务端的支持才能完成任务。如果socket数据量比较大的话，会严重消耗服务器的资源。</p>
<h4 id="WebSocket的优点："><a href="#WebSocket的优点：" class="headerlink" title="WebSocket的优点："></a>WebSocket的优点：</h4><p>1、使用简单，功能灵活、强大，如果部署了WebSocket服务器，可以实现很多实时的功能。</p>
<h3 id="方式四：BroadcastChannel"><a href="#方式四：BroadcastChannel" class="headerlink" title="方式四：BroadcastChannel"></a>方式四：BroadcastChannel</h3><p>BroadcastChannel即广播频道，是window下面的一个API，该API是用于同源不同页面之间完成通信的功能。我们可以理解它是一个广播台，所有的广播实例，都会接入这个广播台（中介者模式中的控制中心），所以，只要在初始化实例时，传入相同的频道值，就会被接入到一个相同的广播频道中。它的实现最简单，很多第三方JS库都实现了一套自己的BroadcastChannel。</p>
<h4 id="实现原理：-3"><a href="#实现原理：-3" class="headerlink" title="实现原理："></a>实现原理：</h4><p>列表页通过onmessage监听其他页面发送过来的消息<br>列表页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 接收广播</span><br><span class="line">let articleCast = new BroadcastChannel(&apos;mychannel&apos;);</span><br><span class="line">articleCast.onmessage = function (e) &#123;</span><br><span class="line">    console.log(e.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当详情页有数据修改时后，通过postMessage，传递数据。<br>详情页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 创建广播并发送</span><br><span class="line">let listCast = new BroadcastChannel(&apos;mychannel&apos;); </span><br><span class="line">myObj = &#123; tid: &quot;123&quot;, title: &quot;更改后的标题&quot; &#125;;</span><br><span class="line">listCast.postMessage(myObj);</span><br></pre></td></tr></table></figure>

<h4 id="BroadcastChannel的不足："><a href="#BroadcastChannel的不足：" class="headerlink" title="BroadcastChannel的不足："></a>BroadcastChannel的不足：</h4><p>1、兼容性极差，只支持最新版的Chrome和Firefox，完全不支持IE和Safari。</p>
<h4 id="BroadcastChannel的优点："><a href="#BroadcastChannel的优点：" class="headerlink" title="BroadcastChannel的优点："></a>BroadcastChannel的优点：</h4><p>1、使用简单，功能单一，跨页面通信的理想选择。</p>
<h3 id="方式五：SharedWorker"><a href="#方式五：SharedWorker" class="headerlink" title="方式五：SharedWorker"></a>方式五：SharedWorker</h3><p>SharedWorker也是HTML5提供的新的浏览器API，叫共享工作线程。它允许多个页面共享使用线程，每个页面都链接到该共享工作线程的某个端口号上。页面通过该端口与共享工作线程进行通信。目前的Web所有程序的操作都基于页面的，而SharedWorker的引入开辟了一个“Web程序”在后台线程的概念。而且它还可以和页面交互，相当于把所有页面都聚拢起来了。上例讲为每个页面都维护一份WebSocket代码不仅耗费大量的连接数，而且还拖慢性能。这些通用的连接最好当然做成可跨域页面共用的，在SharedWorker引入之前并没有一个完美的跨页面通信解决方案。</p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>列表页通过onmessage监听SharedWoker发送过来的消息<br>列表页代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var s = new SharedWorker(&apos;x.js&apos;);</span><br><span class="line">    s.port.onmessage = function(e)&#123;</span><br><span class="line">        console.log(e.data);</span><br><span class="line">        window.alert(&quot;数据变化！&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line">    s.port.start();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当详情页有数据修改时后，通过SharedWorker，通知列表页更新数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=&quot;content&quot; /&gt;&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot; /&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var s = new SharedWorker(&apos;x.js&apos;);</span><br><span class="line">    btn.onclick=function()&#123;</span><br><span class="line">        s.port.postMessage(document.getElementById(&apos;content&apos;).value);</span><br><span class="line">    &#125;;</span><br><span class="line">    s.port.start();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p> 其中共享线程x.js的代码也很简单，它的工作是双向的，每一个页面都可以用来接收和发送数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//x.js</span><br><span class="line">var pool = [];</span><br><span class="line">onconnect = function(e) &#123;</span><br><span class="line">    pool.push(e.ports[0]);</span><br><span class="line">    e.ports[0].onmessage = function(e)&#123;</span><br><span class="line">        for(var i=0; i&lt;pool.length; i++)</span><br><span class="line">        pool[i].postMessage(e.data);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> SharedWorker就像运行在浏览器后端的守卫者，可以被多个window同时使用，但必须保证这些标签页都是同源的(相同的协议，主机和端口号)。</p>
<h4 id="SharedWorker的不足："><a href="#SharedWorker的不足：" class="headerlink" title="SharedWorker的不足："></a>SharedWorker的不足：</h4><p>1、兼容性较差，IE完全不支持，chrome和Firefox支持很完善，Safari部分支持，如果你的业务是内部系统，不考虑IE，可以使用。<br>2、API比较简单，配置繁琐，使用起来还是比较麻烦。</p>
<h4 id="SharedWorker的优点："><a href="#SharedWorker的优点：" class="headerlink" title="SharedWorker的优点："></a>SharedWorker的优点：</h4><p>1、功能强大，不限于浏览器通信，还有共享数据，方法等功能。由于是另启的一个新线程，不影响主线程代码业务，性能优秀，无需借助服务器，是一个完美的跨页面通信解决方案。</p>
<h4 id="我们做了什么？（划重点）"><a href="#我们做了什么？（划重点）" class="headerlink" title="我们做了什么？（划重点）"></a>我们做了什么？（划重点）</h4><p>SharedWorker提供的API很少，使用比较简单，如果需要完成复杂的页面通信，还是有一定难度。基于此，我实现了一款基于SharedWorker的封装库，叫作superSharedWorker</p>
<p>它是一款页面之间通信的JavaScript框架，它通过shared worker 实现纯浏览器页卡之间的通信。你无需了解shared worker，可以快速使用页面之间的数据传递，快捷，强大。它的优点就是通过原生JS实现，无需依赖任何JS库实现了对sharedWorker的封装。开箱即用，配置简单。</p>
<p>两种使用方式：<br>1、ES6 import的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import superSharedWorker from &apos;./src/index.js&apos;;</span><br><span class="line">let superSharedWorker = new superSharedWorker(&apos;page1&apos;, callback); //注册</span><br><span class="line">superSharedWorker.send(&apos;hello world!&apos;); //发送消息</span><br></pre></td></tr></table></figure>

<p>2、script标签外链的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;./build/super-sharedworker.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    //&lt;!--</span><br><span class="line">        var superSharedWorker = new SuperShared(&apos;page1&apos;, onRecvMsg);</span><br><span class="line">        function onRecvMsg(message) &#123;</span><br><span class="line">           console.log(message)</span><br><span class="line">        &#125;</span><br><span class="line">        superSharedWorker.send(&apos;hello, world&apos;);</span><br><span class="line">    //--&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>更多用法举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let superSharedWorker = new superSharedWorker(&apos;page1&apos;, callback); //注册</span><br><span class="line">superSharedWorker.add(&#123;name:&apos;chunpengliu&apos;, sex:1&#125;);</span><br><span class="line">superSharedWorker.del(&apos;sex&apos;);// 删除缓冲区数据</span><br><span class="line">superSharedWorker.send(&#123;&apos;time&apos;:2019&#125;, &apos;page2&apos;); //一次性发送缓冲区数据，只发送给name=&quot;page2&quot;的页面</span><br><span class="line">superSharedWorker.close(); //关闭线程，节省资源</span><br></pre></td></tr></table></figure>

<p>它提供了很多强大的功能，可一对一，一对多发送消息。像使用git一样传递数据。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>通过讨论，实现了四种实现浏览器标签页之间的通信，分别是使用cookie、使用websocket协议、通过localstorage、以及使用html5浏览器的新特性SharedWorker，每种方法各有利弊。如果不考虑兼容旧的浏览器，superSharedWorker 或许是最好的解决方案，优化使用效率，提升用户体验，赶快使用浏览器多标签页通信功能吧！</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/07/我的文章/JavaScript多线程编程-worker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/07/我的文章/JavaScript多线程编程-worker/" class="post-title-link" itemprop="url">JavaScript多线程编程-worker</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-07 14:03:32" itemprop="dateCreated datePublished" datetime="2019-03-07T14:03:32+08:00">2019-03-07</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/07/我的文章/JavaScript多线程编程-worker/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/07/我的文章/JavaScript多线程编程-worker/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>远离浏览器卡顿，提高用户体验，提升代码运行效率，使用多线程编程方法。</p>
</blockquote>
<p>浏览器端JavaScript是以单线程的方式执行的，也就是说JavaScript和UI渲染占用同一个主线程，那就意味着，如果JavaScript进行高负载的数据处理，UI渲染就很有可能被阻断，浏览器就会出现卡顿，降低了用户体验。</p>
<p>为此，JavaScript提供了异步操作，比如定时器(setTimeout、setInterval)事件、Ajax请求、I/O回调等。我们可以把高负载的任务使用异步处理，它们将会被放入浏览器的事件任务队列（event loop）中去，等到JavaScript运行时执行线程空闲时候，事件队列才会按照先进先出的原则被一一执行。</p>
<p><img src="http://pic1.zhoujie16.cn/squares.svg" alt="nodejs引以为荣的异步处理"></p>
<p>通过类似定时器，回调函数等异步编程方式在平常的工作中已经足够，但是如果做复杂运算，这种方式的不足就逐渐体现出来，比如settimeout拿到的值并不正确，或者页面有复杂运算的时候很容易触发假死状态，异步代码会影响主线程的代码执行，异步终究还是单线程，不能从根本上解决问题。</p>
<p>多线程（Web Worker）就应运而生，它是HTML5标准的一部分，这一规范定义了一套 API，允许一段JavaScript程序运行在主线程之外的另外一个线程中。将一些任务分配给后者运行。在主线程运行的同时，Worker（子）线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<h2 id="什么是web-worker"><a href="#什么是web-worker" class="headerlink" title="什么是web worker"></a>什么是web worker</h2><p><img src="http://pic1.zhoujie16.cn/squares.svg" alt="img"></p>
<p>worker是window对象的一个方法，就是用它来创建多线程。可以通过以下方式来检测你的浏览器是否支持worker</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (window.Worker) &#123;…… your code ……&#125;</span><br></pre></td></tr></table></figure>

<p>一个worker是使用一个构造函数（Worker()）创建的一个对象，这个构造函数需要传入一个的JavaScript文件，这个文件包含将在工作线程中运行的代码。类似于这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let myWorker = new Worker(&apos;worker.js&apos;);</span><br></pre></td></tr></table></figure>

<p>主线程和子线程的数据不是共享的，worker通过postMessage() 方法和onmessage事件进行数据通信。主线程和子线程是双向的，都可以发送和监听事件。向一个worker发送消息需要这样做（main.js）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">myWorker.postMessage(&apos;hello, world&apos;); // 发送</span><br><span class="line">worker.onmessage = function (event) &#123; // 接收</span><br><span class="line">    console.log(&apos;Received message &apos; + event.data);</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> postMessage所传的数据都是拷贝传递（ArrayBuffer类型除外），所以子线程也是类似传递（worker.js）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(&apos;message&apos;, function (e) &#123;</span><br><span class="line">    postMessage(&apos;You said: &apos; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p> 当子线程运行结束后，使用完毕，为了节省系统资源，可以手动关闭子线程。如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，它就会自动关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 在主线程中关闭</span><br><span class="line">worker.terminate();</span><br><span class="line">// 在子线程里线程</span><br><span class="line">close();</span><br><span class="line">Worker也提供了错误处理机制，当出错时会触发error事件。</span><br><span class="line">// 监听 error 事件</span><br><span class="line">worker.addEventListener(&apos;error&apos;, function (e) &#123;</span><br><span class="line">  console.log(&apos;ERROR&apos;, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>web worker本身很简单，但是它的限制特别多。</p>
<h2 id="使用的问题"><a href="#使用的问题" class="headerlink" title="使用的问题"></a>使用的问题</h2><h3 id="1、同源限制"><a href="#1、同源限制" class="headerlink" title="1、同源限制"></a>1、同源限制</h3><p>分配给Worker 线程运行的脚本文件（worker.js），必须与主线程的脚本文件(main.js)同源。这里的同源限制包括协议、域名和端口，不支持本地地址（file://）。这会带来一个问题，我们经常使用CDN来存储js文件，主线程的worker.js的域名指的是html文件所在的域，通过new Worker（url）加载的url属于CDN的域，会带来跨域的问题，实际开发中我们不会吧所有的代码都放在一个文件中让子线程加载，肯定会选择模块化开发。通过工具或库把代码合并到一个文件中，然后把子线程的代码生成一个文件url。<br>解决方法：<br>(1)将动态生成的脚本转换成Blob对象。<br>(2)然后给这个Blob对象创建一个URL。<br>(3)最后将这个创建好的URL作为地址传给Worker的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let script = &apos;console.log(&quot;hello world!&quot;);&apos;</span><br><span class="line">let workerBlob = new Blob([script], &#123; type: &quot;text/javascript&quot; &#125;);</span><br><span class="line">let url = URL.createObjectURL(workerBlob);</span><br><span class="line">let worker = new Worker(url);</span><br></pre></td></tr></table></figure>

<h3 id="2、访问限制"><a href="#2、访问限制" class="headerlink" title="2、访问限制"></a>2、访问限制</h3><p>Worker子线程所在的全局对象，与主线程不在同一个上下文环境，无法读取主线程所在网页的 DOM 对象，也无法使用document、window、parent这些对象，global对象的指向有变更，window需要改写成self，不能执行alert()方法和confirm()等方法，只能读取部分navigator对象内的数据。另外chrome的console.log()倒是可以使用，也支持debugger断点，增加调试的便利性。</p>
<h3 id="3、使用异步"><a href="#3、使用异步" class="headerlink" title="3、使用异步"></a>3、使用异步</h3><p>Worker子线程中可以使用XMLHttpRequest 对象发出 AJAX 请求，可以使用setTimeout() setInterval()方法，也可使用websocket进行持续链接。也可以通过importScripts(url)加载另外的脚本文件，但是仍然不能跨域。</p>
<h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><h3 id="1、使用专用线程进行数学运算"><a href="#1、使用专用线程进行数学运算" class="headerlink" title="1、使用专用线程进行数学运算"></a>1、使用专用线程进行数学运算</h3><p>Web Worke设计的初衷就是用来做计算耗时任务，大数据的处理，而这种计算放在worker中并不会中断前台用户的操作，避免代码卡顿带来不必要的用户体验。例如处理ajax返回的大批量数据，读取用户上传文件，计算MD5，canvas的位图的过滤，分析视频和声频文件等。worker中除了缺失了DOM和BOM操作能力以外，还是拥有非常强大的js逻辑运算处理的能力的，相当于nodejs一个级别的的运行环境。</p>
<h3 id="2、高频的用户交互"><a href="#2、高频的用户交互" class="headerlink" title="2、高频的用户交互"></a>2、高频的用户交互</h3><p>高频的用户交互适用于根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等类似场景，用户频繁输入的响应处理同样可以考虑放在web worker中执行。例如，我们可以 做一个像Word一样的应用：当用户打字时，后台立即在词典中进行查找，帮助用户自动纠错等等。</p>
<h3 id="3、数据的预取"><a href="#3、数据的预取" class="headerlink" title="3、数据的预取"></a>3、数据的预取</h3><p>对于一些有大量数据的前后台交互产品，可以新开一个线程专门用来进行数据的预取和缓冲数据，worker可以用在本地web数据库的行写入和更改，长时间持续的运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断，也有利于随时响应主线程的通信。也可以配合XMLHttpRequest和websocket进行不断开的通信，实现守卫进程。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p><img src="http://pic1.zhoujie16.cn/squares.svg" alt="img"></p>
<p>总体来说，兼容性还是不错的， 移动端可以放心使用，桌面端要求不高的话，也可以使用。</p>
<h2 id="superWorker"><a href="#superWorker" class="headerlink" title="superWorker"></a>superWorker</h2><p>为了更方便快捷的使用web worker，我们封装了一个工具，可以通过模块化的方式编写运行在web worker中的脚本，避免同源策略，减少服务端发送一个额外的url请求，无需了解web worker，就像使用setTimeout一样，快速使用superWorker，提升你的编码效率和运行效率，它有以下优点：<br>1、原生JS实现，无任何依赖库。<br>2、简单快速，摈弃繁琐的创建文件、绑定事件，实现无侵入、无感知运行新线程的代码。<br>3、返回Promise类型的数据，支持链式调用，清晰明了。<br>4、支持多种方式新建worker，包括匿名函数、函数列表、文本文件、html片段、url、类，方便快捷。<br>5、gzipped压缩后仅仅 1.2kb。</p>
<h3 id="使用教程："><a href="#使用教程：" class="headerlink" title="使用教程："></a>使用教程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import superWorker from &apos;superWorker&apos;</span><br><span class="line">let worker = superWorker(function (a, b) &#123;</span><br><span class="line">    // 子线程中要运行的代码</span><br><span class="line">    return a + b;</span><br><span class="line">&#125;);</span><br><span class="line">worker.start(1, 2).then((r)=&gt;console.log(r)); // 3</span><br></pre></td></tr></table></figure>

<p>用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">superWorker（code， [type]）</span><br></pre></td></tr></table></figure>

<p>参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code：运行的代码， type（非必须）：代码类型，目前支持0、1、2、3、4。</span><br></pre></td></tr></table></figure>

<h3 id="实现原理："><a href="#实现原理：" class="headerlink" title="实现原理："></a>实现原理：</h3><p>先进行源代码转文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let workerBlob = new Blob(code, &#123; type: &quot;text/javascript&quot; &#125;);</span><br><span class="line">let url = URL.createObjectURL(workerBlob);</span><br></pre></td></tr></table></figure>

<p>对类型拆分，code参数支持传入匿名函数、函数列表、文本文件、url、HTML内嵌标签、类等功能，首先对传入的代码进行分类匹配，字符串化，然后进行拼接运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code = `($&#123;Function.prototype.toString.call(code)&#125;)($&#123;exportsObjName&#125;)`;</span><br></pre></td></tr></table></figure>

<p> 对于传入的方法，分别在主线程中的exports对象进行标记，和worker子线程中的exportsObjName对象中进行赋值。对于ES6 模块化的代码，进行过滤转译。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 处理 \nexport default function xxx()&#123;&#125;  =&gt; exports.default = true; exportsObjName.default = function xx()&#123;&#125;</span><br><span class="line">code = code.replace(/^(\s*)export\s+default\s+/m, (s, before) =&gt; &#123;</span><br><span class="line">    exports.default = true;</span><br><span class="line">    return `$&#123;before&#125;$&#123;exportsObjName&#125;.default=`;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> 形成主线程exports和子线程exportsObjName中的方法进行一一对应。</p>
<p>worker主线程与主线程进行通讯则是仍然需要通过postMessage方法和onmessage回调事件来进行，这个我们统一进行了双向绑定，分别对主线程和子线程执行setup。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function setup(ctx, pmMethods, callbacks) &#123;</span><br><span class="line">    ctx.addEventListener(&apos;message&apos;, (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">    // ……</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在主线程中对worker封装了一些快捷的方法，比如关闭线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate = () =&gt; &#123;</span><br><span class="line">    URL.revokeObjectURL(url);</span><br><span class="line">    term.call(this);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 并把子线程拥有的方法、属性，暴露出来，方便主线程通过传递参数调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.expose = methodName =&gt; &#123;</span><br><span class="line">    worker[i] = function () &#123;</span><br><span class="line">        return worker[&apos;call&apos;](methodName, [].slice.call(arguments));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 大致如下图：<br><img src="http://pic1.zhoujie16.cn/squares.svg" alt="img"></p>
<p>欢迎小伙伴们使用以及批评指正。有问题多多反馈，多多交流。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>对于web worker这项新技术，无论在PC还是在移动web，都很实用，腾讯新闻前端组进行了广泛的尝试，Web Worker 的实现为前端程序带来了后台计算的能力，实现了主 UI 线程与复杂计运算线程的分离，从而极大减轻了因计算量大而造成 UI 阻塞而出现的界面渲染卡、掉帧的情况，并且更大程度地利用了终端硬件的性能。superWorker能解决掉事件绑定，同源策略等繁琐的问题，它目前最大的问题在于不兼容IE9，在兼容性要求不是那么严格的地方，尽可能的使用吧！</p>
<p><img src="http://pic1.zhoujie16.cn/squares.svg" alt="img"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/04/我的文章/为啥程序员下班后只关显示器从不关电脑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/我的文章/为啥程序员下班后只关显示器从不关电脑/" class="post-title-link" itemprop="url">为啥程序员下班后只关显示器从不关电脑</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 16:38:29" itemprop="dateCreated datePublished" datetime="2019-03-04T16:38:29+08:00">2019-03-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/04/我的文章/为啥程序员下班后只关显示器从不关电脑/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/我的文章/为啥程序员下班后只关显示器从不关电脑/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://pic1.zhoujie16.cn/006tNc79ly1g3zkhlup4wj30u00j3t9z.jpg" alt="img"></p>
<p>你下班时是不是只将显示器一关，揣上手机就走了？</p>
<p>曾有安保人员晚上来办公室巡查时问，为什么这些人不关机就下班呢？</p>
<p>作为程序员，你会心一笑。对方不明白如果关机了，第二天程序员上班可能会崩溃：</p>
<blockquote>
<p>打开IDEA，并定位到昨天的代码，十分钟</p>
<p>打开Navicat，两分钟</p>
<p>打开笔记软件，一分钟</p>
<p>打开浏览器，找到昨天的历史记录，五分钟</p>
<p>打开Charles，三分钟</p>
<p>打开各种IM软件，五分钟</p>
<p>打开Xshell，连上，五分钟</p>
<p>打开邮箱，两分钟</p>
<p>……</p>
</blockquote>
<p>等一切工具准备就绪后，半个小时已经过去了。你知道程序员的时薪有多贵吗？</p>
<p>对程序员来说，关机不仅意味着第二天需要开一堆软件浪费时间，更重要的是工作思路也随之断了，第二天重回昨天的思路也挺费劲的。</p>
<p>笔者分别采访了几个不同岗位的程序员，一起来探索程序员界的两大未解之谜：</p>
<p>为什么程序员下班从不关机？</p>
<p>程序员多久才关一次机？</p>
<p>1</p>
<p>Joker，运维工程师，上一次关机是前年</p>
<p>我不关机是因为太懒了。一般公司给程序员配置的电脑多数性能不会太高，服役时间较长，开机关机一次需要很长的时间。</p>
<p>从开机到打开各种软件，再进入工作状态，天知道要多久。再说了平常程序员的工作状态是有电话打过来说线上出问题了，赶紧处理一下。</p>
<p>时间紧急，光开机的时间就可以把问题解决了。时间就是金钱，所以我从来不关机。</p>
<p>曾经遇到一次故障，涉及核心业务级别比较高。我当时正开车回家，挂了电话后立即靠边停，打开电脑修复故障（老婆不在时，电脑坐副驾）。</p>
<p>消息群里我们几个人几乎同时响应正在处理。一分钟后，我修复好了，在群里周知大伙。</p>
<p>有同学说，“艾玛，我这才刚开机！”</p>
<p>呵呵，他竟然下班关机，不过那位同事现在即使送他钱也不敢下班关机。</p>
<p>至于什么时候才关机？我貌似从公司拿过笔记本后就没再关机过。不对，前年电脑升级时重启过一次，耽误不少事，之后再也没关过机了。</p>
<p><img src="http://pic1.zhoujie16.cn/006tNc79ly1g3zkhmpllfj30e50120sm.jpg" alt="img"></p>
<p>Joker电脑的任务栏</p>
<p>2</p>
<p>刘海，前端工程师，绝不关机</p>
<p>我从不关机是因为启动前端项目开发环境需要各种前置命令，很麻烦。</p>
<p>还有的是浏览器还打开着当时查到的解决方案呢，关机那不就丢了吗？其实关机最怕的是会丢了重要的东西，但是我忘了会丢什么，算了，对于前端来说，淡定才是主流。</p>
<p>多久关一次机？能不关机绝不关机，就像熬鹰一样，这里就是熬电脑，它啥时候扛不住了，就放它重启一次，做人不能太苛刻。</p>
<p>笔者：熬鹰……给跪了。</p>
<p><img src="http://pic1.zhoujie16.cn/006tNc79ly1g3zkhn9r99j30u001ndg0.jpg" alt="img"></p>
<p>刘海电脑的任务栏</p>
<p>3</p>
<p>赵越，Java工程师，工作完成就关机</p>
<p>我不关机是因为今天的工作没有做完，电脑得留着思路现场。例如当时浏览器搜索资料页面、项目中类的位置、SQL语句等等，那样第二天来了，可以快速地接上前一天的思路。</p>
<p>有一回下班时我把没写完的SQL给关了，第二天上班后完全忘了前一天写到一半的思路了。毕竟程序员是属鱼的嘛。</p>
<p>如果下班时我的工作做完了，我还是会关机的。</p>
<p>笔者：对了，工作能做完吗？</p>
<p><img src="http://pic1.zhoujie16.cn/006tNc79ly1g3zkhnnuqbj30u001aglw.jpg" alt="img"></p>
<p>赵越电脑的任务栏</p>
<p>4</p>
<p>李奇，数据分析工程师，从不关机</p>
<p>我不关机是要保护现场，方便第二天能快速接上前一天的工作思路。平常打开了很多开发工具像IDEA这种不想关，毕竟上面都是程序员的操作痕迹，标志着上次工作进行到哪里了，上班时一开显示屏思路就可以无缝连接。</p>
<p>有的时候到了下班时间，但机子还在跑着数据呢，我不能在公司干等着。于是电脑开机运行，我到家后远程电脑看数据是否跑完了，等跑完了直接发给需求方。</p>
<p>有时候周末接到报警了，我就立刻远程公司的电脑解决。</p>
<p>我从来不关机，每次关机都是被迫关机：一次是公司停电了，一次是公司搬工位。</p>
<p>而且如果电脑关机了，心理上就是要把工作抛在脑后了。要过另一种生活，不关机就是工作一直在我心中。</p>
<p>笔者：此人单身。</p>
<p>5</p>
<p>任凯，测试工程师，一周关一次</p>
<p>我会在每周五下班时关机让它周末休息。我来公司时间长了，电脑老化但又懒得换，于是每次开机都是一个考验。要么机子起不来，要么重启后发现有软件不好用了，每次都要和电脑战斗半天。</p>
<p>以前曾试过重启电脑后起不来，把电脑送去给 IT维修，结果换了一台更烂的，安装了一天的软件都不好使。</p>
<p>通过采访得知，程序员是“不下班”一族。即使人下班回家了，但电脑不下班。下班不关机除了第二天能快速进入工作状态外，还便于程序员在非工作时间还在跑数据、快速解决突发故障、远程电脑解决问题等。</p>
<p>肩膀始终有责任的程序员们，给你们点赞。</p>
<p>·END·</p>
<p>转自：<a href="https://www.cnblogs.com/gdjk/p/10468994.html" target="_blank" rel="noopener">https://www.cnblogs.com/gdjk/p/10468994.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/04/我的文章/JS数组去重10种方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/我的文章/JS数组去重10种方法/" class="post-title-link" itemprop="url">数组去重10种方法</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 16:05:06" itemprop="dateCreated datePublished" datetime="2019-03-04T16:05:06+08:00">2019-03-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/04/我的文章/JS数组去重10种方法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/我的文章/JS数组去重10种方法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="string">'true'</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, &#123;&#125;, &#123;&#125;, <span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure>

<h4 id="1、ES6-的-Set-对象"><a href="#1、ES6-的-Set-对象" class="headerlink" title="1、ES6 的 Set 对象"></a>1、ES6 的 Set 对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resultArr = <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(originalArray));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者用扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> resultArr = [...new <span class="built_in">Set</span>(originalArray)];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>这是最简单快捷的去重方法，但是细心的同学会发现，这里的 <code>{}</code> 没有去重。可是又转念一想，2 个空对象的地址并不相同，所以这里并没有问题，结果 ok。</p>
<h4 id="2、Map-的-has-方法"><a href="#2、Map-的-has-方法" class="headerlink" title="2、Map 的 has 方法"></a>2、Map 的 has 方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 没有该 key 值</span></span><br><span class="line">    <span class="keyword">if</span> (!map.has(originalArray[i])) &#123;</span><br><span class="line">        map.set(originalArray[i], <span class="literal">true</span>);</span><br><span class="line">        resultArr.push(originalArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>但是它与 Set 的数据结构比较相似，结果 ok。</p>
<h4 id="3、indexOf-和-includes"><a href="#3、indexOf-和-includes" class="headerlink" title="3、indexOf 和 includes"></a>3、indexOf 和 includes</h4><p>建立一个新的空数组，遍历源数组，往这个空数组里塞值，每次 push 之前，先判断是否已有相同的值。</p>
<p>判断的方法有 2 个：indexOf 和 includes，但它们的结果之间有细微的差别。先看 indexOf。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (resultArr.indexOf(originalArray[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        resultArr.push(originalArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN]</span></span><br></pre></td></tr></table></figure>

<p>indexOf 并不没处理 <code>NaN</code>。</p>
<p>再来看 includes，它是在 ES7 中正式提出的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultArr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!resultArr.includes(originalArray[i])) &#123;</span><br><span class="line">        resultArr.push(originalArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>includes 处理了 <code>NaN</code></p>
<h4 id="4、sort"><a href="#4、sort" class="headerlink" title="4、sort"></a>4、sort</h4><p>先将原数组排序，生成新的数组，然后遍历排序后的数组，相邻的两两进行比较，如果不同则存入新数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sortedArr = originalArray.sort();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resultArr = [sortedArr[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; sortedArr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sortedArr[i] !== resultArr[resultArr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">        resultArr.push(sortedArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, NaN, NaN, &#123;…&#125;, &#123;…&#125;, "abc", false, null, true, "true", undefined]</span></span><br></pre></td></tr></table></figure>

<p>从结果可以看出，对源数组进行了排序。但同样的没有处理 <code>NaN</code>。</p>
<h4 id="5、双层-for-循环-splice"><a href="#5、双层-for-循环-splice" class="headerlink" title="5、双层 for 循环 + splice"></a>5、双层 for 循环 + splice</h4><p>双层循环，外层遍历源数组，内层从 i+1 开始遍历比较，相同时删除这个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = (i + <span class="number">1</span>); j &lt; originalArray.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 第一个等于第二个，splice去掉第二个</span></span><br><span class="line">        <span class="keyword">if</span> (originalArray[i] === originalArray[j]) &#123;</span><br><span class="line">            originalArray.splice(j, <span class="number">1</span>);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(originalArray);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN]</span></span><br></pre></td></tr></table></figure>

<p>splice 方法会修改源数组，所以这里我们并没有新开空数组去存储，最终输出的是修改之后的源数组。但同样的没有处理 <code>NaN</code>。</p>
<h4 id="6、原始去重"><a href="#6、原始去重" class="headerlink" title="6、原始去重"></a>6、原始去重</h4><p>定义一个新数组，并存放原数组的第一个元素，然后将源数组一一和新数组的元素对比，若不同则存放在新数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resultArr = [originalArray[<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; originalArray.length; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> repeat = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; resultArr.length; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(originalArray[i] === resultArr[j])&#123;</span><br><span class="line">            repeat = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!repeat)&#123;</span><br><span class="line">       resultArr.push(originalArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN, NaN]</span></span><br></pre></td></tr></table></figure>

<p>这是最原始的去重方法，很好理解，但写法繁琐。同样的没有处理 <code>NaN</code>。</p>
<h4 id="7、ES5-的-reduce"><a href="#7、ES5-的-reduce" class="headerlink" title="7、ES5 的 reduce"></a>7、ES5 的 reduce</h4><p>reduce 是 ES5 中方法，常用于值的累加。它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback[, initialValue])</span><br></pre></td></tr></table></figure>

<p>reduce 的第一个参数是一个 callback，callback 中的参数分别为： Accumulator(累加器)、currentValue(当前正在处理的元素)、currentIndex(当前正在处理的元素索引，可选)、array(调用 reduce 的数组，可选)。</p>
<p>reduce 的第二个参数，是作为第一次调用 callback 函数时的第一个参数的值。如果没有提供初始值，则将使用数组中的第一个元素。</p>
<p>利用 reduce 的特性，再结合之前的 includes(也可以用 indexOf)，就能得到新的去重方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">acc, cur</span>) =&gt;</span> acc.includes(cur) ? acc : [...acc, cur];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> resultArr = originalArray.reduce(reducer, []);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>[]</code> 就是初始值(initialValue)。acc 是累加器，在这里的作用是将没有重复的值塞入新数组（它一开始是空的）。 reduce 的写法很简单，但需要多加理解。它可以处理 <code>NaN</code>，结果 ok。</p>
<h4 id="8、对象的属性"><a href="#8、对象的属性" class="headerlink" title="8、对象的属性"></a>8、对象的属性</h4><p>每次取出原数组的元素，然后在对象中访问这个属性，如果存在就说明重复。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resultArr = [];</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; originalArray.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj[originalArray[i]])&#123;</span><br><span class="line">        resultArr.push(originalArray[i]);</span><br><span class="line">        obj[originalArray[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, 2, true, false, null, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>但这种方法有缺陷。从结果看，它貌似只关心值，不关注类型。还把 {} 给处理了，但这不是正统的处理办法，所以 <strong>不推荐使用</strong>。</p>
<h4 id="9、filter-hasOwnProperty"><a href="#9、filter-hasOwnProperty" class="headerlink" title="9、filter + hasOwnProperty"></a>9、filter + hasOwnProperty</h4><p>filter 方法会返回一个新的数组，新数组中的元素，通过 hasOwnProperty 来检查是否为符合条件的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> resultArr = originalArray.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + item) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + item] = <span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(resultArr);</span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>这 <code>貌似</code> 是目前看来最完美的解决方案了。这里稍加解释一下：</p>
<ul>
<li>hasOwnProperty 方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性。</li>
<li><code>typeof item + item</code> 的写法，是为了保证值相同，但类型不同的元素被保留下来。例如：第一个元素为 number1，第二第三个元素都是 string1，所以第三个元素就被去除了。</li>
<li><code>obj[typeof item + item] = true</code> 如果 hasOwnProperty 没有找到该属性，则往 obj 里塞键值对进去，以此作为下次循环的判断依据。</li>
<li>如果 hasOwnProperty 没有检测到重复的属性，则告诉 filter 方法可以先积攒着，最后一起输出。</li>
</ul>
<p><code>看似</code> 完美解决了我们源数组的去重问题，但在实际的开发中，一般不会给两个空对象给我们去重。所以稍加改变源数组，给两个空对象中加入键值对。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> originalArray = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">2</span>, <span class="literal">true</span>, <span class="string">'true'</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">null</span>, <span class="literal">null</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">a</span>: <span class="number">2</span>&#125;, <span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br></pre></td></tr></table></figure>

<p>然后再用 filter + hasOwnProperty 去重。</p>
<p>然而，结果竟然把 <code>{a: 2}</code> 给去除了！！！这就不对了。</p>
<p>所以，这种方法有点去重 <code>过头</code> 了，也是存在问题的。</p>
<h4 id="10、lodash-中的-uniq"><a href="#10、lodash-中的-uniq" class="headerlink" title="10、lodash 中的 _.uniq"></a>10、lodash 中的 _.uniq</h4><p>灵机一动，让我想到了 lodash 的去重方法 _.uniq，那就尝试一把：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(_.uniq(originalArray));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, "1", 2, true, "true", false, null, &#123;…&#125;, &#123;…&#125;, "abc", undefined, NaN]</span></span><br></pre></td></tr></table></figure>

<p>用法很简单，可以在实际工作中正确处理去重问题。</p>
<p>然后，我在好奇心促使下，看了它的源码，指向了 baseUniq 文件，它的源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseUniq</span>(<span class="params">array, iteratee, comparator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">-1</span></span><br><span class="line">  <span class="keyword">let</span> includes = arrayIncludes</span><br><span class="line">  <span class="keyword">let</span> isCommon = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; length &#125; = array</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">let</span> seen = result</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (comparator) &#123;</span><br><span class="line">    isCommon = <span class="literal">false</span></span><br><span class="line">    includes = arrayIncludesWith</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (length &gt;= LARGE_ARRAY_SIZE) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">set</span> = iteratee ? null : createSet(array)</span><br><span class="line">    if (<span class="keyword">set</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> setToArray(<span class="keyword">set</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    isCommon = false</span><br><span class="line">    includes = cacheHas</span><br><span class="line">    seen = new SetCache</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    seen = iteratee ? [] : result</span><br><span class="line">  &#125;</span><br><span class="line">  outer:</span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = array[index]</span><br><span class="line">    <span class="keyword">const</span> computed = iteratee ? iteratee(value) : value</span><br><span class="line"></span><br><span class="line">    value = (comparator || value !== <span class="number">0</span>) ? value : <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (isCommon &amp;&amp; computed === computed) &#123;</span><br><span class="line">      <span class="keyword">let</span> seenIndex = seen.length</span><br><span class="line">      <span class="keyword">while</span> (seenIndex--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (seen[seenIndex] === computed) &#123;</span><br><span class="line">          <span class="keyword">continue</span> outer</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (iteratee) &#123;</span><br><span class="line">        seen.push(computed)</span><br><span class="line">      &#125;</span><br><span class="line">      result.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!includes(seen, computed, comparator)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (seen !== result) &#123;</span><br><span class="line">        seen.push(computed)</span><br><span class="line">      &#125;</span><br><span class="line">      result.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有比较多的干扰项，那是为了兼容另外两个方法，_.uniqBy 和 _.uniqWith。去除掉之后，就会更容易发现它是用 while 做了循环。当遇到相同的值得时候，continue outer 再次进入循环进行比较，将没有重复的值塞进 result 里，最终输出。</p>
<p>另外，_.uniqBy 方法可以通过指定 key，来专门去重对象列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.uniqBy([&#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span> &#125;], <span class="string">'x'</span>);</span><br><span class="line"><span class="comment">// =&gt; [&#123; 'x': 1 &#125;, &#123; 'x': 2 &#125;]</span></span><br></pre></td></tr></table></figure>

<p>_.uniqWith 方法可以完全地给对象中所有的键值对，进行比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objects = [&#123; <span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">2</span>, <span class="string">'y'</span>: <span class="number">1</span> &#125;, &#123; <span class="string">'x'</span>: <span class="number">1</span>, <span class="string">'y'</span>: <span class="number">2</span> &#125;];</span><br><span class="line"></span><br><span class="line">_.uniqWith(objects, _.isEqual);</span><br><span class="line"><span class="comment">// =&gt; [&#123; 'x': 1, 'y': 2 &#125;, &#123; 'x': 2, 'y': 1 &#125;]</span></span><br></pre></td></tr></table></figure>

<p>这两个方法，都还挺实用的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上述的这些方法来看，ES6 开始出现的方法（如 Set、Map、includes），都能完美地解决我们日常开发中的去重需求，关键它们还都是原生的，写法还更简单。</p>
<p>所以，我们提倡拥抱原生，因为它们真的没有那么难以理解，至少在这里我觉得它比 lodash 里 _.uniq 的源码要好理解得多，关键是还能解决问题。</p>
<p>摘录自：<a href="https://segmentfault.com/a/1190000018371055" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018371055</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/04/我的文章/vue组件之间通信方式总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/04/我的文章/vue组件之间通信方式总结/" class="post-title-link" itemprop="url">vue组件之间8种组件通信方式总结</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-04 15:30:10" itemprop="dateCreated datePublished" datetime="2019-03-04T15:30:10+08:00">2019-03-04</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/04/我的文章/vue组件之间通信方式总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/04/我的文章/vue组件之间通信方式总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于vue来说，组件之间的消息传递是非常重要的，下面是我对组件之间消息传递的各种方式的总结，总共有8种方式。</p>
<h2 id="1-props和-emit"><a href="#1-props和-emit" class="headerlink" title="1.props和$emit"></a>1.props和$emit</h2><p>父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="keyword">this</span>.message</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       props:[<span class="string">'message'</span>],<span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line">       methods:&#123;</span><br><span class="line">           passData(val)&#123;</span><br><span class="line">               <span class="comment">//触发父组件中的事件</span></span><br><span class="line">               <span class="keyword">this</span>.$emit(<span class="string">'getChildData'</span>,val)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   Vue.component(<span class="string">'parent'</span>,&#123;</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;p&gt;this is parent compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">               &lt;child :message="message" v-on:getChildData="getChildData"&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               message:<span class="string">'hello'</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           <span class="comment">//执行子组件触发的事件</span></span><br><span class="line">           getChildData(val)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(val)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el:<span class="string">'#app'</span>,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;parent&gt;&lt;/parent&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，有父组件parent和子组件child。<br>1).父组件传递了message数据给子组件，并且通过v-on绑定了一个getChildData事件来监听子组件的触发事件；<br>2).子组件通过props得到相关的message数据,最后通过this.$emit触发了getChildData事件。</p>
<h2 id="2-attrs和-listeners"><a href="#2-attrs和-listeners" class="headerlink" title="2. $attrs和$listeners"></a>2. $attrs和$listeners</h2><p>第一种方式处理父子组件之间的数据传输有一个问题：如果父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢？<br>如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C；要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。Vue 2.4开始提供了$attrs和$listeners来解决这个问题，能够让组件A之间传递消息给组件C。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'C'</span>,&#123;</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="$attrs.messagec" @input="passCData($attrs.messagec)"&gt; &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line"></span><br><span class="line">       methods:&#123;</span><br><span class="line">           passCData(val)&#123;</span><br><span class="line">               <span class="comment">//触发父组件A中的事件</span></span><br><span class="line">               <span class="keyword">this</span>.$emit(<span class="string">'getCData'</span>,val)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   Vue.component(<span class="string">'B'</span>,&#123;</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="keyword">this</span>.message</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; </span></span><br><span class="line"><span class="string">               &lt;!-- C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性 --&gt;</span></span><br><span class="line"><span class="string">               &lt;!-- 通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的） --&gt;</span></span><br><span class="line"><span class="string">               &lt;C v-bind="$attrs" v-on="$listeners"&gt;&lt;/C&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       props:[<span class="string">'message'</span>],<span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line">       methods:&#123;</span><br><span class="line">           passData(val)&#123;</span><br><span class="line">               <span class="comment">//触发父组件中的事件</span></span><br><span class="line">               <span class="keyword">this</span>.$emit(<span class="string">'getChildData'</span>,val)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   Vue.component(<span class="string">'A'</span>,&#123;</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;p&gt;this is parent compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">               &lt;B :messagec="messagec" :message="message" v-on:getCData="getCData" v-on:getChildData="getChildData(message)"&gt;&lt;/B&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               message:<span class="string">'hello'</span>,</span><br><span class="line">               messagec:<span class="string">'hello c'</span> <span class="comment">//传递给c组件的数据</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           getChildData(val)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">'这是来自B组件的数据'</span>)</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="comment">//执行C子组件触发的事件</span></span><br><span class="line">           getCData(val)&#123;</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">"这是来自C组件的数据："</span>+val)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el:<span class="string">'#app'</span>,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;A&gt;&lt;/A&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="3-中央事件总线"><a href="#3-中央事件总线" class="headerlink" title="3.中央事件总线"></a>3.中央事件总线</h2><p>上面两种方式处理的都是父子组件之间的数据传递，而如果两个组件不是父子关系呢？这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'brother1'</span>,&#123;</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="string">'hello brother1'</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;p&gt;this is brother1 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="mymessage" @input="passData(mymessage)"&gt; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           passData(val)&#123;</span><br><span class="line">               <span class="comment">//触发全局事件globalEvent</span></span><br><span class="line">               bus.$emit(<span class="string">'globalEvent'</span>,val)</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   Vue.component(<span class="string">'brother2'</span>,&#123;</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;p&gt;this is brother2 compoent!&lt;/p&gt;</span></span><br><span class="line"><span class="string">               &lt;p&gt;brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;&lt;/p&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span>,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="string">'hello brother2'</span>,</span><br><span class="line"></span><br><span class="line">               brothermessage:<span class="string">''</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       mounted()&#123;</span><br><span class="line">           <span class="comment">//绑定全局事件globalEvent</span></span><br><span class="line">           bus.$on(<span class="string">'globalEvent'</span>,(val)=&gt;&#123;</span><br><span class="line">               <span class="keyword">this</span>.brothermessage=val;</span><br><span class="line">           &#125;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">   <span class="comment">//中央事件总线</span></span><br><span class="line">   <span class="keyword">var</span> bus=<span class="keyword">new</span> Vue();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> app=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">       el:<span class="string">'#app'</span>,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;brother1&gt;&lt;/brother1&gt;</span></span><br><span class="line"><span class="string">               &lt;brother2&gt;&lt;/brother2&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">       `</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="4-provide和inject"><a href="#4-provide和inject" class="headerlink" title="4.provide和inject"></a>4.provide和inject</h2><p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">       inject:[<span class="string">'for'</span>],<span class="comment">//得到父组件传递过来的数据</span></span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="keyword">this</span>.for</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="tet" v-model="mymessage"&gt; </span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">   &#125;)</span></span><br><span class="line"><span class="string">   Vue.component('parent',&#123;</span></span><br><span class="line"><span class="string">       template:`</span></span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;p&gt;<span class="keyword">this</span> is parent compoent!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">               &lt;child&gt;<span class="xml"><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span></span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `,</span></span><br><span class="line"><span class="regexp">       provide:&#123;</span></span><br><span class="line"><span class="regexp">           for:'test'</span></span><br><span class="line"><span class="regexp">       &#125;,</span></span><br><span class="line"><span class="regexp">       data()&#123;</span></span><br><span class="line"><span class="regexp">           return &#123;</span></span><br><span class="line"><span class="regexp">               message:'hello'</span></span><br><span class="line"><span class="regexp">           &#125;</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br><span class="line"><span class="regexp">   var app=new Vue(&#123;</span></span><br><span class="line"><span class="regexp">       el:'#app',</span></span><br><span class="line"><span class="regexp">       template:`</span></span><br><span class="line"><span class="regexp">           &lt;div&gt;</span></span><br><span class="line"><span class="regexp">               &lt;parent&gt;&lt;/</span>parent&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="5-v-model"><a href="#5-v-model" class="headerlink" title="5.v-model"></a>5.v-model</h2><p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">       props:&#123;</span><br><span class="line">           value:<span class="built_in">String</span>, <span class="comment">//v-model会自动传递一个字段为value的prop属性</span></span><br><span class="line">       &#125;,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="keyword">this</span>.value</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           changeValue()&#123;</span><br><span class="line">               <span class="keyword">this</span>.$emit(<span class="string">'input'</span>,<span class="keyword">this</span>.mymessage);<span class="comment">//通过如此调用可以改变父组件上v-model绑定的值</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; </span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">   &#125;)</span></span><br><span class="line"><span class="string">   Vue.component('parent',&#123;</span></span><br><span class="line"><span class="string">       template:`</span></span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;p&gt;<span class="keyword">this</span> is parent compoent!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">               &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">               &lt;child v-model="message"&gt;&lt;/</span>child&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `,</span></span><br><span class="line"><span class="regexp">       data()&#123;</span></span><br><span class="line"><span class="regexp">           return &#123;</span></span><br><span class="line"><span class="regexp">               message:'hello'</span></span><br><span class="line"><span class="regexp">           &#125;</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br><span class="line"><span class="regexp">   var app=new Vue(&#123;</span></span><br><span class="line"><span class="regexp">       el:'#app',</span></span><br><span class="line"><span class="regexp">       template:`</span></span><br><span class="line"><span class="regexp">           &lt;div&gt;</span></span><br><span class="line"><span class="regexp">               &lt;parent&gt;&lt;/</span>parent&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="6-parent和-children"><a href="#6-parent和-children" class="headerlink" title="6.$parent和$children"></a>6.$parent和$children</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'child'</span>,&#123;</span><br><span class="line">       props:&#123;</span><br><span class="line">           value:<span class="built_in">String</span>, <span class="comment">//v-model会自动传递一个字段为value的prop属性</span></span><br><span class="line">       &#125;,</span><br><span class="line">       data()&#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               mymessage:<span class="keyword">this</span>.value</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       methods:&#123;</span><br><span class="line">           changeValue()&#123;</span><br><span class="line">               <span class="keyword">this</span>.$parent.message = <span class="keyword">this</span>.mymessage;<span class="comment">//通过如此调用可以改变父组件的值</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">       template:<span class="string">`</span></span><br><span class="line"><span class="string">           &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;input type="text" v-model="mymessage" @change="changeValue"&gt; </span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">   &#125;)</span></span><br><span class="line"><span class="string">   Vue.component('parent',&#123;</span></span><br><span class="line"><span class="string">       template:`</span></span><br><span class="line">           &lt;div&gt;</span><br><span class="line">               &lt;p&gt;<span class="keyword">this</span> is parent compoent!<span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">               &lt;button @click=<span class="string">"changeChildValue"</span>&gt;test&lt;<span class="regexp">/button &gt;</span></span><br><span class="line"><span class="regexp">               &lt;child&gt;&lt;/</span>child&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `,</span></span><br><span class="line"><span class="regexp">       methods:&#123;</span></span><br><span class="line"><span class="regexp">           changeChildValue()&#123;</span></span><br><span class="line"><span class="regexp">               this.$children[0].mymessage = 'hello';</span></span><br><span class="line"><span class="regexp">           &#125;</span></span><br><span class="line"><span class="regexp">       &#125;,</span></span><br><span class="line"><span class="regexp">       data()&#123;</span></span><br><span class="line"><span class="regexp">           return &#123;</span></span><br><span class="line"><span class="regexp">               message:'hello'</span></span><br><span class="line"><span class="regexp">           &#125;</span></span><br><span class="line"><span class="regexp">       &#125;</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br><span class="line"><span class="regexp">   var app=new Vue(&#123;</span></span><br><span class="line"><span class="regexp">       el:'#app',</span></span><br><span class="line"><span class="regexp">       template:`</span></span><br><span class="line"><span class="regexp">           &lt;div&gt;</span></span><br><span class="line"><span class="regexp">               &lt;parent&gt;&lt;/</span>parent&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">       `</span></span><br><span class="line"><span class="regexp">   &#125;)</span></span><br></pre></td></tr></table></figure>

<h2 id="7-vuex处理组件之间的数据交互"><a href="#7-vuex处理组件之间的数据交互" class="headerlink" title="7.vuex处理组件之间的数据交互"></a>7.vuex处理组件之间的数据交互</h2><p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/01/我的文章/常用Git命令清单/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/我的文章/常用Git命令清单/" class="post-title-link" itemprop="url">常用Git命令清单</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 14:45:30" itemprop="dateCreated datePublished" datetime="2019-03-01T14:45:30+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:54" itemprop="dateModified" datetime="2019-07-25T17:27:54+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/01/我的文章/常用Git命令清单/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/我的文章/常用Git命令清单/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我每天使用 Git ，但是很多命令记不住。</p>
<p>一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。</p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<blockquote>
<p>Workspace：工作区<br>Index / Stage：暂存区<br>Repository：仓库区（或本地仓库）<br>Remote：远程仓库</p>
</blockquote>
<p><strong>一、新建代码库</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>

<p><strong>二、配置</strong></p>
<p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>

<p><strong>三、增加/删除文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<p><strong>四、代码提交</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<p><strong>五、分支</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>

<p><strong>六、标签</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<p><strong>七、查看信息</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<p><strong>八、远程同步</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<p><strong>九、撤销</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<p><strong>十、其他</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>

<blockquote>
<p>转自：阮一峰(<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a>)</p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/01/我的文章/40条常见的移动端Web页面问题解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/我的文章/40条常见的移动端Web页面问题解决方案/" class="post-title-link" itemprop="url">40条常见的移动端Web页面问题解决方案</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 12:53:52" itemprop="dateCreated datePublished" datetime="2019-03-01T12:53:52+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/01/我的文章/40条常见的移动端Web页面问题解决方案/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/我的文章/40条常见的移动端Web页面问题解决方案/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1、安卓浏览器看背景图片，有些设备会模糊。</strong></p>
<p>用同等比例的图片在PC机上很清楚，但是手机上很模糊，原因是什么呢？</p>
<p>经过研究，是devicePixelRatio作怪，因为手机分辨率太小，如果按照分辨率来显示网页，这样字会非常小，所以苹果当初就把iPhone 4的960640分辨率，在网页里只显示了480320，这样devicePixelRatio＝2。现在android比较乱，有1.5的，有2的也有3的。</p>
<p>想让图片在手机里显示更为清晰，必须使用2x的背景图来代替img标签（一般情况都是用2倍）。例如一个div的宽高是100100，背景图必须得200200，然后background-size:contain;，这样显示出来的图片就比较清晰了。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">background: url(../images/icon/all.png) no-repeat center center;</span><br><span class="line">-webkit-background-size: 50px 50px;</span><br><span class="line">background-size: 50px 50px;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 100%;</span><br><span class="line">height: 50px;</span><br></pre></td></tr></table></figure>

<p>或者指定 background-size:contain;都可以，大家试试！</p>
<p><strong>2、图片加载</strong></p>
<p>若您遇到图片加载很慢的问题，对这种情况，手机开发一般用canvas方法加载：</p>
<p>具体的canvas API 参见：<a href="http://javascript.ruanyifeng.com/htmlapi/canvas.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/htmlapi/canvas.html</a></p>
<p>下面举例说明一个canvas的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>js动态加载图片和li 总共举例17张图片！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = <span class="number">17</span>;</span><br><span class="line"><span class="keyword">var</span> zWin = $(<span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> padding = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> winWidth = zWin.width();</span><br><span class="line">  <span class="keyword">var</span> picWidth = <span class="built_in">Math</span>.floor((winWidth - padding * <span class="number">3</span>) / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">var</span> tmpl = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= totla; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = padding;</span><br><span class="line">    <span class="keyword">var</span> imgSrc = <span class="string">'img/'</span> + i + <span class="string">'.jpg'</span>;</span><br><span class="line">    <span class="keyword">if</span> (i % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">      p = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tmpl += <span class="string">'&lt;li style="width:'</span> + picWidth + <span class="string">'px;height:'</span> + picWidth + <span class="string">'px;padding-left:'</span> + p + <span class="string">'px;padding-top:'</span> + padding + <span class="string">'px;"&gt;&lt;canvas id="cvs_'</span> + i + <span class="string">'"&gt;&lt;/canvas&gt;&lt;/li&gt;'</span>;</span><br><span class="line">    <span class="keyword">var</span> imageObj = <span class="keyword">new</span> Image();</span><br><span class="line">    imageObj.index = i;</span><br><span class="line">    imageObj.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> cvs = $(<span class="string">'#cvs_'</span> + <span class="keyword">this</span>.index)[<span class="number">0</span>].getContext(<span class="string">'2d'</span>);</span><br><span class="line">      cvs.width = <span class="keyword">this</span>.width;</span><br><span class="line">      cvs.height = <span class="keyword">this</span>.height;</span><br><span class="line">      cvs.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    imageObj.src = imgSrc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></figure>

<p><strong>3、假如手机网站不用兼容IE浏览器，一般我们会使用zeptojs</strong>。</p>
<p>zeptojs内置Touch events方法，具体可以看<a href="http://zeptojs.com/#Touch" target="_blank" rel="noopener">http://zeptojs.com/#Touch</a> events</p>
<p>看了一下zeptio新版的API，已经支持IE10以上浏览器，对zeptojs可以选择使用！</p>
<p><strong>4、防止手机中网页放大和缩小。</strong></p>
<p>这点是最基本的，最为手机网站开发者来说应该都知道的，就是设置meta中的viewport</p>
<p>还有就是，有些手机网站我们看到如下声明：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.0//EN" "http://www.wapforum.org/DTD/xhtml-mobile10.dtd"&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置了DTD的方式是XHTML的写法，假如我们页面运用的是html5，可以不用设置DTD,直接声明<!DOCTYPE html>。</p>
<p>使用viewport使页面禁止缩放。 通常把user-scalable设置为0来关闭用户对页面视图缩放的行为</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"user-scalable=0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是为了更好的兼容，我们会使用完整的viewport设置。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，user-scalable=0,有的人也写成user-scalable=no，都可以的。</p>
<p><strong>5、apple-mobile-web-app-capable</strong></p>
<p>apple-mobile-web-app-capable是设置Web应用是否以全屏模式运行。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>如果content设置为yes，Web应用会以全屏模式运行，反之，则不会。content的默认值是no，表示正常显示。你可以通过只读属性window.navigator.standalone来确定网页是否以全屏模式显示。</p>
<p><strong>6、format-detection</strong></p>
<p>format-detection 启动或禁用自动识别页面中的电话号码。</p>
<p>语法：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>默认情况下，设备会自动识别任何可能是电话号码的字符串。设置telephone=no可以禁用这项功能。</p>
<p><strong>7、html5调用安卓或者ios的拨号功能</strong></p>
<p>html5提供了自动调用拨号的标签，只要在a标签的href中添加tel:就可以了。</p>
<p>如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"tel:10010"</span>&gt;</span>10010<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>8、html5GPS定位功能</strong></p>
<p>具体请看：<a href="http://www.w3school.com.cn/html5/html_5_geolocation.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/html5/html_5_geolocation.asp</a></p>
<p>9、上下拉动滚动条时卡顿、慢</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">    <span class="attribute">overflow-scrolling</span>: touch;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>10、禁止复制、选中文本</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Element</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-khtml-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>解决移动设备可选中页面文本(视产品需要而定)</p>
<p><strong>11、长时间按住页面出现闪退</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">element</span> &#123;  <span class="attribute">-webkit-touch-callout</span>: none;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>12、iphone及ipad下输入框默认内阴影</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element&#123;  -webkit-appearance: none; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>13、ios和android下触摸元素时出现半透明灰色遮罩</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element &#123;  -webkit-tap-highlight-color:rgba(255,255,255,0)&#125;</span><br></pre></td></tr></table></figure>

<p><strong>14、active兼容处理 即 伪类 :active 失效</strong></p>
<p>方法一：body添加ontouchstart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body ontouchstart=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>方法二：js给 document 绑定 touchstart 或 touchend 事件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">a &#123;</span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">&#125;<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">herf</span>=<span class="string">foo</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">  &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>15、动画定义3D启用硬件加速</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Element</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>16、Retina屏的1px边框</strong></p>
<p>具体请百度谷歌关键字，解决方案有很多</p>
<p><strong>17、webkit mask 兼容处理</strong></p>
<p>某些低端手机不支持css3 mask，可以选择性的降级处理。</p>
<p>比如可以使用js判断来引用不同class：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'WebkitMask'</span> <span class="keyword">in</span> <span class="built_in">document</span>.documentElement.style) &#123;</span><br><span class="line">  alert(<span class="string">'支持mask'</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">'不支持mask'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>18、旋转屏幕时，字体大小调整的问题</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">p</span>, <span class="selector-tag">div</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-text-size-adjust</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>19、transition闪屏</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ele</span> &#123;</span><br><span class="line">    <span class="comment">/*设置内嵌的元素在 3D 空间如何呈现：保留3D */</span></span><br><span class="line">    <span class="attribute">-webkit-transform-style</span>: preserve-<span class="number">3</span>d;</span><br><span class="line">    <span class="comment">/* 设置进行转换的元素的背面在面对用户时是否可见：隐藏 */</span></span><br><span class="line">    <span class="attribute">-webkit-backface-visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>20、圆角bug</strong></p>
<p>某些Android手机圆角失效</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ele</span> &#123;</span><br><span class="line">    <span class="attribute">background-clip</span>: padding-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>21、顶部状态栏背景色</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>除非你先使用apple-mobile-web-app-capable指定全屏模式，否则这个meta标签不会起任何作用。</p>
<p>如果content设置为default，则状态栏正常显示。如果设置为blank，则状态栏会有一个黑色的背景。如果设置为blank-translucent，则状态栏显示为黑色半透明。</p>
<p>如果设置为default或blank，则页面显示在状态栏的下方，即状态栏占据上方部分，页面占据下方部分，二者没有遮挡对方或被遮挡。</p>
<p>如果设置为blank-translucent，则页面会充满屏幕，其中页面顶部会被状态栏遮盖住（会覆盖页面20px高度，而iphone4和itouch4的Retina屏幕为40px）。</p>
<p>默认值是default。</p>
<p><strong>22、设置缓存</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。</p>
<p><strong>23、桌面图标</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">href</span>=<span class="string">"touch-icon-iphone.png"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"76x76"</span> <span class="attr">href</span>=<span class="string">"touch-icon-ipad.png"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"120x120"</span> <span class="attr">href</span>=<span class="string">"touch-icon-iphone-retina.png"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon"</span> <span class="attr">sizes</span>=<span class="string">"152x152"</span> <span class="attr">href</span>=<span class="string">"touch-icon-ipad-retina.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>iOS下针对不同设备定义不同的桌面图标。如果不定义则以当前屏幕截图作为图标。</p>
<p>上面的写法可能大家会觉得会有默认光泽，下面这种设置方法可以去掉光泽效果，还原设计图的效果！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">href</span>=<span class="string">"touch-icon-iphone.png"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>图片尺寸可以设定为57<em>57（px）或者Retina可以定为114</em>114（px），ipad尺寸为72*72（px)</p>
<p><strong>24、启动画面</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-startup-image"</span> <span class="attr">href</span>=<span class="string">"start.png"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>iOS下页面启动加载时显示的画面图片，避免加载时的白屏。</p>
<p>可以通过madia来指定不同的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--iPhone--&gt;&lt;link href=&quot;apple-touch-startup-image-320x460.png&quot; media=&quot;(device-width: 320px)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone Retina --&gt;&lt;link href=&quot;apple-touch-startup-image-640x920.png&quot; media=&quot;(device-width: 320px) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPhone 5 --&gt;&lt;link rel=&quot;apple-touch-startup-image&quot; media=&quot;(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)&quot; href=&quot;apple-touch-startup-image-640x1096.png&quot;&gt; &lt;!-- iPad portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-768x1004.png&quot; media=&quot;(device-width: 768px) and (orientation: portrait)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-748x1024.png&quot; media=&quot;(device-width: 768px) and (orientation: landscape)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina portrait --&gt;&lt;link href=&quot;apple-touch-startup-image-1536x2008.png&quot; media=&quot;(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)&quot; rel=&quot;apple-touch-startup-image&quot; /&gt; &lt;!-- iPad Retina landscape --&gt;&lt;link href=&quot;apple-touch-startup-image-1496x2048.png&quot;media=&quot;(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)&quot;rel=&quot;apple-touch-startup-image&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>25、浏览器私有及其它meta</strong></p>
<p>以下属性在项目中没有应用过，可以写一个demo测试以下！</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- QQ浏览器私有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全屏模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制横屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"landscape"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-page-mode"</span> <span class="attr">content</span>=<span class="string">"app"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- UC浏览器私有 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 全屏模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"screen-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制横屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"screen-orientation"</span> <span class="attr">content</span>=<span class="string">"landscape"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"browsermode"</span> <span class="attr">content</span>=<span class="string">"application"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其它,针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;HandheldFriendly&quot; content=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>微软的老式浏览器</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"MobileOptimized"</span> <span class="attr">content</span>=<span class="string">"320"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>windows phone 点击无高光</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>26、 IOS中input键盘事件keyup、keydown、keypress支持不是很好</strong></p>
<p>问题是这样的，用input search做模糊搜索的时候，在键盘里面输入关键词，会通过ajax后台查询，然后返回数据，然后再对返回的数据进行关键词标红。</p>
<p>用input监听键盘keyup事件，在安卓手机浏览器中是可以的，但是在ios手机浏览器中变红很慢，用输入法输入之后，并未立刻相应keyup事件，只有在通过删除之后才能相应！</p>
<p>解决办法：</p>
<p>可以用html5的oninput事件去代替keyup</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"testInput"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> value = e.target.value;</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后就达到类似keyup的效果！</p>
<p><strong>27、h5网站input 设置为type=number的问题</strong></p>
<p>h5网页input 的type设置为number一般会产生三个问题，一个问题是maxlength属性不好用了。另外一个是form提交的时候，默认给取整了。三是部分安卓手机出现样式问题。</p>
<p>问题一解决，我目前用的是js。如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">oninput</span>=<span class="string">"checkTextLength(this ,10)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">checkTextLength</span>(<span class="params">obj, length</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (obj.value.length &gt; length) &#123;</span></span><br><span class="line">      obj.value = obj.value.substr(0, length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>问题二，是因为form提交默认做了表单验证，step默认是1,要设置step属性，假如保留2位小数，写法如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"0.01"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>关于step，我在这里做简单的介绍，input 中type=number，一般会自动生成一个上下箭头，点击上箭头默认增加一个step，点击下箭头默认会减少一个step。number中默认step是1。也就是step=0.01,可以允许输入2位小数，并且点击上下箭头分别增加0.01和减少0.01。</p>
<p>假如step和min一起使用，那么数值必须在min和max之间。</p>
<p>看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">step</span>=<span class="string">"3.1"</span> <span class="attr">min</span>=<span class="string">"1"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>输入框可以输入哪些数字？</p>
<p>首先，最小值是1，那么可以输入1.0，第二个是可以输入（1+3.1）那就是4.1,以此类推，每次点击上下箭头都会增加或者减少3.1，输入其他数字无效。这就是step的简单介绍。</p>
<p>问题三，去除input默认样式</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=number]</span> &#123;</span><br><span class="line">  <span class="attribute">-moz-appearance</span>: textfield;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=number]</span><span class="selector-pseudo">::-webkit-inner-spin-button</span>, <span class="selector-tag">input</span><span class="selector-attr">[type=number]</span><span class="selector-pseudo">::-webkit-outer-spin-button</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-appearance</span>: none;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>28、ios 设置input 按钮样式会被默认样式覆盖</strong></p>
<p>解决方式如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span>,<span class="selector-tag">textarea</span> &#123;  </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;  </span><br><span class="line">    <span class="attribute">-webkit-appearance</span>: none; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置默认样式为none</p>
<p><strong>29、IOS键盘字母输入，默认首字母大写</strong></p>
<p>解决方案，设置如下属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autocapitalize</span>=<span class="string">"off"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>30、select 下拉选择设置右对齐</strong></p>
<p>设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select option &#123;direction: rtl;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>31、通过transform进行skew变形，rotate旋转会造成出现锯齿现象</strong></p>
<p>可以设置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-webkit-transform: rotate(-4deg) skew(10deg) translateZ(0); </span><br><span class="line">transform: rotate(-4deg) skew(10deg) translateZ(0); </span><br><span class="line">outline: 1px solid rgba(255,255,255,0);</span><br></pre></td></tr></table></figure>

<p><strong>32、移动端点击300ms延迟</strong></p>
<p>300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。</p>
<p>推荐两个js，一个是fastclick，一个是tap.js</p>
<p>关于300ms延迟，具体请看：<a href="http://thx.github.io/mobile/300ms-click-delay/" target="_blank" rel="noopener">http://thx.github.io/mobile/300ms-click-delay/</a></p>
<p><strong>33、移动端点透问题</strong></p>
<p>案例如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"haorooms"</span>&gt;</span>点头事件测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span>&gt;</span>www.xxx.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>div是绝对定位的蒙层,并且z-index高于a。而a标签是页面中的一个链接，我们给div绑定tap事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#haorooms'</span>).on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#haorooms'</span>).hide();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们点击蒙层时 div正常消失，但是当我们在a标签上点击蒙层时，发现a链接被触发，这就是所谓的点透事件。</p>
<p>原因：</p>
<p>touchstart 早于 touchend 早于click。 亦即click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上。</p>
<p>解决：</p>
<p>（1）尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。<br>（2）用fastclick，<a href="https://github.com/ftlabs/fastclick" target="_blank" rel="noopener">https://github.com/ftlabs/fastclick</a><br>（3）用preventDefault阻止a标签的click<br>（4）延迟一定的时间(300ms+)来处理事件 （不推荐）<br>（5）以上一般都能解决，实在不行就换成click事件。</p>
<p>下面介绍一下touchend事件，如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#haorooms"</span>).on(<span class="string">"touchend"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>34、消除 IE10 里面的那个叉号</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input:-ms-clear&#123;display:none;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>35、关于 iOS 与 OS X 端字体的优化(横竖屏会出现字体加粗不一致等)</strong></p>
<p>iOS 浏览器横屏时会重置字体大小，设置 text-size-adjust 为 none 可以解决 iOS 上的问题，但桌面版 Safari 的字体缩放功能会失效，因此最佳方案是将 text-size-adjust 为 100% 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-webkit-text-size-adjust: 100%;</span><br><span class="line">-ms-text-size-adjust: 100%;</span><br><span class="line">text-size-adjust: 100%;</span><br></pre></td></tr></table></figure>

<p><strong>36、关于 iOS 系统中，中文输入法输入英文时，字母之间可能会出现一个六分之一空格</strong></p>
<p>可以通过正则去掉</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.value.replace(<span class="regexp">/\u2006/g</span>, <span class="string">''</span>);</span><br></pre></td></tr></table></figure>

<p><strong>37、移动端 HTML5 audio autoplay 失效问题</strong></p>
<p>这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。</p>
<p>解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。</p>
<p>解决代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'audio'</span>)[<span class="number">0</span>].play();</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">'audio'</span>)[<span class="number">0</span>].pause();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>38、移动端 HTML5 input date 不支持 placeholder 问题</strong></p>
<p>这个我感觉没有什么好的解决方案，用如下方法</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">"Date"</span> <span class="attr">class</span>=<span class="string">"textbox-n"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">onfocus</span>=<span class="string">"(this.type='date')"</span>  <span class="attr">id</span>=<span class="string">"date"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有的浏览器可能要点击两遍！</p>
<p><strong>39、部分机型存在type为search的input，自带close按钮样式修改方法</strong></p>
<p>有些机型的搜索input控件会自带close按钮（一个伪元素），而通常为了兼容所有浏览器，我们会自己实现一个，此时去掉原生close按钮的方法为</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#Search</span><span class="selector-pseudo">::-webkit-search-cancel-button</span>&#123;  <span class="attribute">display</span>: none; &#125;</span><br></pre></td></tr></table></figure>

<p>如果想使用原生close按钮，又想使其符合设计风格，可以对这个伪元素的样式进行修改。</p>
<p><strong>40、唤起select的option展开</strong></p>
<p>zepto方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(sltElement).trrgger(<span class="string">"mousedown"</span>);</span><br></pre></td></tr></table></figure>

<p>原生js方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showDropdown</span>(<span class="params">sltElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event;</span><br><span class="line">  event = <span class="built_in">document</span>.createEvent(<span class="string">'MouseEvents'</span>);</span><br><span class="line">  event.initMouseEvent(<span class="string">'mousedown'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="built_in">window</span>);</span><br><span class="line">  sltElement.dispatchEvent(event);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/01/我的文章/利用IntersectionObserve-API轻松实现惰性加载和无限滚动/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/我的文章/利用IntersectionObserve-API轻松实现惰性加载和无限滚动/" class="post-title-link" itemprop="url">利用IntersectionObserve-API轻松实现惰性加载和无限滚动</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 12:34:19" itemprop="dateCreated datePublished" datetime="2019-03-01T12:34:19+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:54" itemprop="dateModified" datetime="2019-07-25T17:27:54+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/01/我的文章/利用IntersectionObserve-API轻松实现惰性加载和无限滚动/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/我的文章/利用IntersectionObserve-API轻松实现惰性加载和无限滚动/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>网页开发时，常常需要了解某个元素是否进入了”视口”（viewport），即用户能不能看到它。</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n77qbn45g308w0i1n11.gif" alt></p>
<p>上图的绿色方块不断滚动，顶部会提示它的可见性。<br>传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于scroll事件密集发生，计算量很大，容易造成性能问题。<br>目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见（visible）的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。</p>
<h4 id="一、API"><a href="#一、API" class="headerlink" title="一、API"></a>一、API</h4><p>它的用法非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(callback, option);</span><br></pre></td></tr></table></figure>

<p>上面代码中，IntersectionObserver是浏览器原生提供的构造函数，接受两个参数：callback是可见性变化时的回调函数，option是配置对象（该参数可选）。<br>构造函数的返回值是一个观察器实例。实例的observe方法可以指定观察哪个 DOM 节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">io.observe(<span class="built_in">document</span>.getElementById(<span class="string">'example'</span>)); </span><br><span class="line"><span class="comment">// 停止观察</span></span><br><span class="line">io.unobserve(element); </span><br><span class="line"><span class="comment">// 关闭观察器</span></span><br><span class="line">io.disconnect();</span><br></pre></td></tr></table></figure>

<p>上面代码中，observe的参数是一个 DOM 节点对象。如果要观察多个节点，就要多次调用这个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.observe(elementA);</span><br><span class="line">io.observe(elementB);</span><br></pre></td></tr></table></figure>

<h4 id="二、callback-参数"><a href="#二、callback-参数" class="headerlink" title="二、callback 参数"></a>二、callback 参数</h4><p>目标元素的可见性变化时，就会调用观察器的回调函数callback。<br>callback一般会触发两次。一次是目标元素刚刚进入视口（开始可见），另一次是完全离开视口（开始不可见）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = <span class="keyword">new</span> IntersectionObserver(<span class="function"><span class="params">entries</span> =&gt;</span> &#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(entries);  </span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，回调函数采用的是箭头函数的写法。callback函数的参数（entries）是一个数组，每个成员都是一个IntersectionObserverEntry对象。举例来说，如果同时有两个被观察的对象的可见性发生变化，entries数组就会有两个成员。</p>
<h4 id="三、IntersectionObserverEntry-对象"><a href="#三、IntersectionObserverEntry-对象" class="headerlink" title="三、IntersectionObserverEntry 对象"></a>三、IntersectionObserverEntry 对象</h4><p>IntersectionObserverEntry对象提供目标元素的信息，一共有六个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  time: 3893.92,</span><br><span class="line">  rootBounds: ClientRect &#123;</span><br><span class="line">    bottom: 920,</span><br><span class="line">    height: 1024,</span><br><span class="line">    left: 0,</span><br><span class="line">    right: 1024,</span><br><span class="line">    top: 0,</span><br><span class="line">    width: 920</span><br><span class="line">  &#125;,</span><br><span class="line">  boundingClientRect: ClientRect &#123;</span><br><span class="line">     // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  intersectionRect: ClientRect &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;,</span><br><span class="line">  intersectionRatio: 0.54,</span><br><span class="line">  target: element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个属性的含义如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time：可见性发生变化的时间，是一个高精度时间戳，单位为毫秒</span><br><span class="line">target：被观察的目标元素，是一个 DOM 节点对象</span><br><span class="line">rootBounds：根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null</span><br><span class="line">boundingClientRect：目标元素的矩形区域的信息</span><br><span class="line">intersectionRect：目标元素与视口（或根元素）的交叉区域的信息</span><br><span class="line">intersectionRatio：目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0</span><br></pre></td></tr></table></figure>

<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n6we1hsuj30fa0f4taj.jpg" alt></p>
<p>上图中，灰色的水平方框代表视口，深红色的区域代表四个被观察的目标元素。它们各自的intersectionRatio图中都已经注明。<br>我写了一个 Demo[<a href="http://jsbin.com/canuze/edit?js,console,output]，演示IntersectionObserverEntry对象。**注意，这个" target="_blank" rel="noopener">http://jsbin.com/canuze/edit?js,console,output]，演示IntersectionObserverEntry对象。**注意，这个</a> Demo 只能在 Chrome 51+ 运行**。</p>
<h4 id="四、实例：惰性加载（lazy-load）"><a href="#四、实例：惰性加载（lazy-load）" class="headerlink" title="四、实例：惰性加载（lazy load）"></a>四、实例：惰性加载（lazy load）</h4><p>有时，我们希望某些静态资源（比如图片），只有用户向下滚动，它们进入视口时才加载，这样可以节省带宽，提高网页性能。这就叫做”惰性加载”。<br>有了 IntersectionObserver API，实现起来就很容易了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">query</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">document</span>.querySelectorAll(selector));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>) </span>&#123;</span><br><span class="line">    changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> container = change.target;</span><br><span class="line">      <span class="keyword">var</span> content = container.querySelector(<span class="string">'template'</span>).content;</span><br><span class="line">      container.appendChild(content);</span><br><span class="line">      observer.unobserve(container);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line">query(<span class="string">'.lazy-loaded'</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  observer.observe(item);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有目标区域可见时，才会将模板内容插入真实 DOM，从而引发静态资源的加载。</p>
<h4 id="五、实例：无限滚动"><a href="#五、实例：无限滚动" class="headerlink" title="五、实例：无限滚动"></a>五、实例：无限滚动</h4><p>无限滚动（infinite scroll）的实现也很简单。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intersectionObserver = <span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">entries</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果不可见，就返回</span></span><br><span class="line">    <span class="keyword">if</span> (entries[<span class="number">0</span>].intersectionRatio &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    loadItems(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Loaded new items'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 开始观察</span></span><br><span class="line">intersectionObserver.observe(</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'.scrollerFooter'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>无限滚动时，最好在页面底部有一个页尾栏（又称sentinels）。一旦页尾栏可见，就表示用户到达了页面底部，从而加载新的条目放在页尾栏前面。这样做的好处是，不需要再一次调用observe()方法，现有的IntersectionObserver可以保持使用。</p>
<h4 id="六、Option-对象"><a href="#六、Option-对象" class="headerlink" title="六、Option 对象"></a>六、Option 对象</h4><p>IntersectionObserver构造函数的第二个参数是一个配置对象。它可以设置以下属性。</p>
<h5 id="6-1-threshold-属性"><a href="#6-1-threshold-属性" class="headerlink" title="6.1 threshold 属性"></a>6.1 threshold 属性</h5><p>threshold属性决定了什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  entries =&gt; &#123;<span class="comment">/* ... */</span>&#125;, </span><br><span class="line">  &#123;</span><br><span class="line">    threshold: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n788lmu6g308w0i1tb1.gif" alt></p>
<h5 id="6-2-root-属性，rootMargin-属性"><a href="#6-2-root-属性，rootMargin-属性" class="headerlink" title="6.2 root 属性，rootMargin 属性"></a>6.2 root 属性，rootMargin 属性</h5><p>很多时候，目标元素不仅会随着窗口滚动，还会在容器里面滚动（比如在iframe窗口里滚动）。容器内滚动也会影响目标元素的可见性，参见本文开始时的那张示意图。<br>IntersectionObserver API 支持容器内滚动。root属性指定目标元素所在的容器节点（即根元素）。注意，容器元素必须是目标元素的祖先节点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> opts = &#123; </span><br><span class="line">  root: <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>),</span><br><span class="line">  rootMargin: <span class="string">"500px 0px"</span> </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> observer = <span class="keyword">new</span> IntersectionObserver(</span><br><span class="line">  callback,</span><br><span class="line">  opts</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，除了root属性，还有rootMargin属性。后者定义根元素的margin，用来扩展或缩小rootBounds这个矩形的大小，从而影响intersectionRect交叉区域的大小。它使用CSS的定义方法，比如10px 20px 30px 40px，表示 top、right、bottom 和 left 四个方向的值。<br>这样设置以后，不管是窗口滚动或者容器内滚动，只要目标元素可见性变化，都会触发观察器。</p>
<h4 id="七、注意点"><a href="#七、注意点" class="headerlink" title="七、注意点"></a>七、注意点</h4><p>IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。<br>规格写明，IntersectionObserver的实现，应该采用requestIdleCallback()，即只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。</p>
<h4 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h4><p>IntersectionObserver’s Coming into View[<a href="https://developers.google.com/web/updates/2016/04/intersectionobserver]" target="_blank" rel="noopener">https://developers.google.com/web/updates/2016/04/intersectionobserver]</a><br>Intersection Observers Explained[<a href="https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md]" target="_blank" rel="noopener">https://github.com/WICG/IntersectionObserver/blob/gh-pages/explainer.md]</a></p>
<p>转自：<a href="http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/11/intersectionobserver_api.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhoujie16.cn/2019/03/01/我的文章/JavaScript排序-冒泡-选择-插入-归并/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="周杰">
      <meta itemprop="description" content="没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。">
      <meta itemprop="image" content="http://pic1.zhoujie16.cn/20190725180925.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ZJ_16">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/03/01/我的文章/JavaScript排序-冒泡-选择-插入-归并/" class="post-title-link" itemprop="url">JavaScript排序,冒泡,选择,插入,归并</a>
              
            
          </h1>
        

        <div class="post-meta">

          
          
          

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-03-01 11:32:15" itemprop="dateCreated datePublished" datetime="2019-03-01T11:32:15+08:00">2019-03-01</time>
            </span>
          

          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-25 17:27:53" itemprop="dateModified" datetime="2019-07-25T17:27:53+08:00">2019-07-25</time>
              </span>
            
          

          

          
            
            
              
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/03/01/我的文章/JavaScript排序-冒泡-选择-插入-归并/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/03/01/我的文章/JavaScript排序-冒泡-选择-插入-归并/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          <br>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>不过说到排序，最容易想到的就是冒泡排序，选择排序，插入排序了。</p>
<p><strong>冒泡排序</strong></p>
<p>依次比较相邻的两个元素，如果后一个小于前一个，则交换，这样从头到尾一次，就将最大的放到了末尾。</p>
<p>从头到尾再来一次，由于每进行一轮，最后的都已经是最大的了，因此后一轮需要比较次数可以比上一次少一个。虽然你还是可以让他从头到尾来比较，但是后面的比较是没有意义的无用功，为了效率，你应该对代码进行优化。</p>
<p>图片演示如下</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n50274n9g30my075te6.gif" alt></p>
<p>代码实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> len = arr.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;		<span class="comment">// 相邻元素两两对比</span></span><br><span class="line">				<span class="keyword">var</span> temp = arr[j + <span class="number">1</span>];		<span class="comment">// 元素交换</span></span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">				arr[j] = temp</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>选择排序</strong></p>
<p>选择排序我觉得是最简单的了，大一学VB的时候，就只记住了这个排序方法，原理非常简单：每次都找一个最大或者最小的排在开始即可。</p>
<p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置<br>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br>重复第二步，直到所有元素均排序完毕。<br>动图演示：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n51jmdukg30mj06wtil.gif" alt></p>
<p>代码演示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = arr.length;</span><br><span class="line">    <span class="keyword">var</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序</strong></p>
<p>插入排序也比较简单。就像打扑克一样，依次将拿到的元素插入到正确的位置即可。</p>
<p>1.将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>2.从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<p>动图演示：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n52zq7kxg30mj0e1agh.gif" alt></p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> len = arr.length;</span><br><span class="line">	<span class="keyword">var</span> preIndex, current;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		preIndex = i - <span class="number">1</span>;</span><br><span class="line">		current = arr[i];</span><br><span class="line">		<span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">			arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">			preIndex--</span><br><span class="line">		&#125;</span><br><span class="line">		arr[preIndex + <span class="number">1</span>] = current</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的代价是低效</p>
<p>上面三种都是非常简单的排序方法，简单的同时呢，效率也会比较低，还是拿这本书里的对比图来说明：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n53x1k55j30hs0aumzj.jpg" alt></p>
<p>时间复杂度都高达O(n^2),而它们后面的一些排序算法时间复杂度基本都只有O(n log n)。</p>
<p>我的强迫症又犯了，我想要高效率一点的排序方法。</p>
<p><strong>归并排序</strong></p>
<p>简单把这本书的内容过了一遍，当时就理解了这个归并排序，因此这里就谈一下这个归并排序吧。</p>
<p>基本原理是分治法，就是分开并且递归来排序。</p>
<p>步骤如下：</p>
<p>1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>4.重复步骤 3 直到某一指针达到序列尾；<br>5.将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<p>动图演示：</p>
<p><img src="http://pic1.zhoujie16.cn/006tKfTcly1g0n54fx733j30mj0e1dgf.jpg" alt></p>
<p>代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;  <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">	<span class="keyword">var</span> len = arr.length;</span><br><span class="line">	<span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">	left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">	right = arr.slice(middle);</span><br><span class="line">	<span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = [];</span><br><span class="line">	<span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">		<span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">			result.push(left.shift())</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result.push(right.shift())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line">	<span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然是个爱折腾的人，折腾了总得看看效果吧。</p>
<p><strong>效率测试</strong></p>
<p>由于我学这个来进行排序不是对简单数组，数组内都是对象，要对对象的某个属性进行排序，还要考虑升降序。</p>
<p>因此我的代码实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [归并排序]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[Array]&#125; arr   [要排序的数组]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[String]&#125; prop  [排序字段，用于数组成员是对象时，按照其某个属性进行排序，简单数组直接排序忽略此参数]</span></span><br><span class="line"><span class="comment"> * @param  &#123;[String]&#125; order [排序方式 省略或asc为升序 否则降序]</span></span><br><span class="line"><span class="comment"> * @return &#123;[Array]&#125;       [排序后数组，新数组，并非在原数组上的修改]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mergeSort = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 合并</span></span><br><span class="line">    <span class="keyword">var</span> _merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right, prop</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = [];</span><br><span class="line">        <span class="comment">// 对数组内成员的某个属性排序</span></span><br><span class="line">        <span class="keyword">if</span> (prop) &#123;</span><br><span class="line">            <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[<span class="number">0</span>][prop] &lt;= right[<span class="number">0</span>][prop]) &#123;</span><br><span class="line">                    result.push(left.shift());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push(right.shift());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 数组成员直接排序</span></span><br><span class="line">            <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">                    result.push(left.shift());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.push(right.shift());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left.length)</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        <span class="keyword">while</span> (right.length)</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> _mergeSort = <span class="function"><span class="keyword">function</span>(<span class="params">arr, prop</span>) </span>&#123; <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">        <span class="keyword">var</span> len = arr.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">            left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">            right = arr.slice(middle);</span><br><span class="line">        <span class="keyword">return</span> _merge(_mergeSort(left, prop), _mergeSort(right, prop), prop);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arr, prop, order</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> result = _mergeSort(arr, prop);</span><br><span class="line">        <span class="keyword">if</span> (!order || order.toLowerCase() === <span class="string">'asc'</span>) &#123;</span><br><span class="line">            <span class="comment">// 升序</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 降序</span></span><br><span class="line">            <span class="keyword">var</span> _ = [];</span><br><span class="line">            result.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">                _.unshift(item);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>需要对哪个属性进行排序是不确定，可以随意指定，因此写成了参数。有由于不想让这些东西在每次循环都进行判断，因此代码有点冗余。</p>
<p>关于降序的问题，也没有加入参数中，而是简单的升序后再逆序输出。原因是不想让每次循环递归里都去判断条件，所以简单处理了。</p>
<p>下面就是见证效率的时候了，一段数据模拟：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getData = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Mock.mock(&#123;</span><br><span class="line">		<span class="string">"list|1000"</span>: [&#123;</span><br><span class="line">			name: <span class="string">'@cname'</span>,</span><br><span class="line">			age: <span class="string">'@integer(0,500)'</span></span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;).list</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面使用Mock进行了模拟数据，关于Mock ： <a href="http://mockjs.com/" target="_blank" rel="noopener">http://mockjs.com/</a></p>
<p>实际测试来啦：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 效率测试</span></span><br><span class="line"><span class="keyword">var</span> arr = getData();</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'归并排序'</span>);</span><br><span class="line">mergeSort(arr, <span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'归并排序'</span>);</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'冒泡排序'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = arr.length; i &lt; l - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; l - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age) &#123;</span><br><span class="line">            temp = arr[j + <span class="number">1</span>];</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'冒泡排序'</span>);</span><br></pre></td></tr></table></figure>

<p>进行了五次，效果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 归并排序: 6.592ms</span><br><span class="line">// 冒泡排序: 25.959ms</span><br><span class="line"></span><br><span class="line">// 归并排序: 1.334ms</span><br><span class="line">// 冒泡排序: 20.078ms</span><br><span class="line"></span><br><span class="line">// 归并排序: 1.085ms</span><br><span class="line">// 冒泡排序: 16.420ms</span><br><span class="line"></span><br><span class="line">// 归并排序: 1.200ms</span><br><span class="line">// 冒泡排序: 16.574ms</span><br><span class="line"></span><br><span class="line">// 归并排序: 2.593ms</span><br><span class="line">// 冒泡排序: 12.653ms</span><br></pre></td></tr></table></figure>

<p>最低4倍，最高近16倍的效率之差还是比较满意的。</p>
<p>虽然1000条数据让前端排序的可能性不大，但是几十上百条的情况还是有的。另外由于node，JavaScript也能运行的服务端了，这个效率的提升也还是有用武之地的。</p>
<p><strong>一点疑问</strong></p>
<p>归并排序里面使用了递归，在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p>
<blockquote>
<p>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle. </p>
</blockquote>
<p>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。<br>gitbook上这本书的作者对此有疑问，我也有疑问。</p>
<p>归并中虽然用了递归，但是他是放在return后的呀。关于在renturn后的递归是有尾递归优化的呀。</p>
<p>关于尾递归优化是指：本来外层函数内部再调用一个函数的话，由于外层函数需要等待内层函数返回后才能返回结果，进入内层函数后，外层函数的信息，内存中是必须记住的，也就是调用堆栈。而内部函数放在return关键字后，就表示外层函数到此也就结束了，进入内层函数后，没有必要再记住外层函数内的所有信息。</p>
<p>上面是我的理解的描述，不知道算不算准确。chrome下已经可以开启尾递归优化的功能了，我觉得这个递归是不该影响他在JavaScript下的使用的。</p>
<p><strong>最后</strong></p>
<p>有兴趣的话，推荐读读这本书，进行排序的时候，可以考虑一些更高效的方法。</p>
<p>不过需要注意的是，这些高效率的排序方法，一般都需要相对较多的额外内存空间，需要权衡一下。</p>
<p>另外，非常小规模的数据就没有必要了。一是影响太小，而是我们人的效率问题，一分钟能从头写个冒泡、选择、插入的排序方法，而换成是归并排序呢？</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="http://pic1.zhoujie16.cn/20190725180925.png" alt="周杰">
            
              <p class="site-author-name" itemprop="name">周杰</p>
              <div class="site-description motion-element" itemprop="description">没有高深的知识，没有进阶的技巧。只是，万丈高楼平地起，千里之行始于足下，千里长提溃于蚁穴。能把简单的做好就是不简单，你能走多远，不是在于你有多聪明，而是取决于你有多勤奋，共勉。</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">59</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">周杰</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.2.0"></script>

  <script src="/js/motion.js?v=7.2.0"></script>



  
  


  <script src="/js/affix.js?v=7.2.0"></script>

  <script src="/js/schemes/pisces.js?v=7.2.0"></script>



  

  


  <script src="/js/next-boot.js?v=7.2.0"></script>


  

  

  

  
  

<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'FACWrlWQfYlbP4DQNHWwWEEU-9Nh9j0Va',
    appKey: 'v6nHIKG1Dokj9WE70FmH8HWW',
    placeholder: '留个言吧 ~ 😊',
    avatar: 'mp',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: 'zh-cn' || 'zh-cn'
  });
</script>





  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
